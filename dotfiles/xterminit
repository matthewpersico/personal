# -*- sh -*-

# xterminit

## Cygwin use only
startxserver() {
    if [ -z "$(ps -a | grep XWin)" ]
    then
        if [ "$1" = '--verbose' ]
        then
            echo "Starting Cygwin XServer..."
            startxwin 2>/dev/null 2>/dev/null &
            XSERVER='XWin'
        fi
    fi
}

## init
if [ -z "$DISPLAY" ]
then
    export DISPLAY=:0.0
fi

XSERVER=''
if [ "$(uname -o)" = 'Cygwin' ]
then
    hasXming=$(ps -aW | grep Xming.exe)
    if [ -n "$hasXming" ]
    then
        echo "Using Xming XServer"
        XSERVER='Xming'
    else
        startxserver --verbose
    fi
else
    ## X server ping...
    xmodmap 1>/dev/null 2>/dev/null
    if (($?))
    then
        ## There is no xserver. Do not set any of this up.
        return 0 ## return, not exit because this script is meant to be 'dotted in'
    fi
fi

if [ -z "$XTERM" ]
then
    for i in /bin /usr/bin /usr/bin/X11
    do
        if [ -z "$XTERM" ] && [ -e "$i/xterm" ]
        then
            XTERM="$i/xterm -ls -sb -sl 40000"
        fi
    done
fi

if [ -z "$XTERM" ]
then
    echo "$(date) - $(hostname) - Cannot find an xterm to use. xterm setup stops." >> ~/xterminit.stop
    return 0
fi

if [ -z "${HOSTNAME}" ]
then
    HOSTNAME=`hostname`
fi
export XTERM HOSTNAME

XTERMGEOW=132
XTERMGEOH=40
XTERMGEOX=200
XTERMGEOY=200
XTERMGEO="-geometry ${XTERMGEOW}x${XTERMGEOH}+${XTERMGEOX}+${XTERMGEOY}"
case ${HOSTNAME} in
    *bldo* )
        export NEWXCOLOR=darkred
        XTERMFONTS="-fa 'Monospace' -fs 10"
        ;;

    *bcpc* )
        export NEWXCOLOR=grey
        XTERMFONTS="-fa 'Monospace' -fs 10"
        ;;

    nylxdev* )
        export NEWXCOLOR=darkblue
        XTERMFONTS=''
        ;;

    monolith* )
        export NEWXCOLOR=black
        if [ "$XSERVER" = 'XWin' ]
        then
            XTERMFONTS="-fa 'Monospace' -fs 10"
        else
            ## Xming
            XTERMFONTS='-fn lucidasanstypewriter-14'
        fi
        ;;

    * )
        export NEWXCOLOR=red
        XTERMFONTS=''
esac

## Set these up here because they use values set above
RXCmd ()
{
    local HOST="${1}"
	if [ -z ${HOST} ]
	then
		echo "Error: hostname not specified."
	else
		shift 1
		local XARGS="${*}"
		if [ -z "${XARGS}" ]
		then
			XARGS="$XTERMGEO"
		fi
		if [ "${HOST}" = "${HOSTNAME}" ]
		then
			${XTERM} -display ${DISPLAY} -name ${HOST} ${XARGS} &
		else
			local XCOOKIE=`/usr/bin/X11/xauth list ${DISPLAY}`
            #					${XARGS} >/dev/null 2>&1 &
            ssh ${HOST} "(
                                  PATH=$PATH:/usr/bin/X11
                                  DISPLAY=$DISPLAY
                                  export PATH DISPLAY
                                  xauth add ${XCOOKIE} >> ~/inlog 2>&1
                                  /usr/bin/nohup ${XTERM} -name ${HOST} \
                                                 ${XARGS} >> ~/inlog 2>&1 &
                                 )" &
		fi
	fi
}

newxguts ()
{
    local count=1
    local xtermgeow=$XTERMGEOW
    local checkargs=1
    while ((checkargs))
    do
        case $1 in
            w )
                ## wide
                ((xtermgeow*=2)) ; shift ;;
            n )
                ## narrow
                ((xtermgeow/=2)) ; shift ;;
            s )
                ## std
                ((xtermgeow+-0)) ; shift ;;
            [0-9]* )
                ## number of xterms to spawn
                count=$1 ; shift ;;
            * )
                ## We're done
                checkargs=0 ;;
        esac
    done
    local i=0
    while ((i<count))
    do
        local xtermgeo="-geometry ${xtermgeow}x${XTERMGEOH}+$((XTERMGEOX+(i*72)))+$((XTERMGEOY+(i*72)))"
        RXCmd ${HOSTNAME} $XTERMGEO $XTERMFONTS $@ $xtermgeo
        ((i+=1))
        sleep .05 ## Just enough to space out the &-ed invocations so that they
                  ## do not randomly appear, but rather appear in a nice
                  ## cascade.
    done
}

## If we want to change git colors, then define the color assignments
## with a series of -c name=value assignments in an ennvar GIT_COLORS
## and make git be a function such that it calls '/the/real/git
## $GIT_COLORS "$@"'.

newxgrey ()
{
    newxguts ${1:-1} ${2:-s} -fg black -bg darkgrey
}

newxdarkblue ()
{
    newxguts ${1:-1} ${2:-s} -fg wheat -bg darkblue
}

newxred ()
{
    newxguts ${1:-1} ${2:-s} -fg wheat -bg red
}

newxdarkred ()
{
    newxguts ${1:-1} ${2:-s} -fg wheat -bg darkred
}

newxwhite ()
{
    newxguts ${1:-1} ${2:-s} -fg black -bg white
}

newxblack ()
{
    newxguts ${1:-1} ${2:-s} -fg white -bg black
}

newxblue ()
{
    newxguts ${1:-1} ${2:-s} -fg black -bg steelblue
}

newxgreen ()
{
    newxguts ${1:-1} ${2:-s} -fg black -bg seagreen
}

newx ()
{
    local bg=$(xterm-background)
    newx${bg}
}

perlx ()
{
    ## For starting up windows for forked Perl programs in debugger to
    ## attach to.
    xterm -e sh -c 'echo This terminal was started to receive a forked perl debugger process.;
echo Set;
echo \$DB::fork_TTY=q\($(tty)\);
echo in the debugger before you reach the fork.;
echo Sleeping 99999999 starting at $(date);echo -e "\e]0;$(tty)\a
     ";sleep 99999999' &
}
alias perldbx='perlx '

declare -A xterm_background_map
xterm_background_map[rgba9a9a9a9a9a9]='grey'
xterm_background_map[rgb000000008b8b]='darkblue'
xterm_background_map[rgbffff00000000]='red'
xterm_background_map[rgb8b8b00000000]='darkred'
xterm_background_map[rgbffffffffffff]='white'
xterm_background_map[rgb000000000000]='black'
xterm_background_map[rgb46468282b4b4]='blue'
xterm_background_map[rgb2e2e8b8b5757]='green'

xterm-background ()
{
    if [ -n "$XTERM_SHELL" ]
    then
        exec < /dev/tty
        oldstty=$(stty -g)
        stty raw -echo min 0
        col=11      # background
        #          OSC   Ps  ;Pt ST
        echo -en "\033]${col};?\033\\" >/dev/tty  # echo opts differ w/ OSes
        result=
        if IFS=';' read -r -d '\' color ; then
            result=$(echo $color | sed 's/^.*\;//;s/[^rgb:0-9a-f/]//g')
            idxresult=$(echo $result | sed 's/[:/]//g')
        fi
        stty $oldstty
        if [ -n "${xterm_background_map[$idxresult]}" ]
        then
            echo ${xterm_background_map[$idxresult]}
            return
        else
            echo "## WARNING:xterm-background - no mapped color found for $result" >&2
        fi
    else
        echo "## WARNING:xterm-background - XTERM_SHELL not defined, probably not an xterm" >&2
    fi

    if [ -n "$NEWXCOLOR" ]
    then
        echo $NEWXCOLOR
        return
    else
        echo "## WARNING:xterm-background - NEWXCOLOR not defined" >&2
    fi

    echo "## WARNING:xterm-background - default color is grey" >&2
    echo grey
}

tickerfg ()
{
    local i=0;
    local M="::: $@ :::"
    local T="$M$M$M$M"
    echo "$M" > /tmp/ticker.$(hostname).$$
    while sleep .2s && [ -r /tmp/ticker.$(hostname).$$ ]
    do
        echo -e "\033]0;$S\007\c"
        (( ++i>${#M} )) && i=1
        S=${T:i:40}
    done
}

ticker ()
{
    if [ -r /tmp/ticker.$(hostname).$$ ]
    then
        echo Found /tmp/ticker.$(hostname).$$
        echo Looks like there is already a ticker running
        echo with the banner:
        echo
        cat /tmp/ticker.$(hostname).$$
    else
        tickerfg "$@" &
    fi
}

ticker-kill ()
{
    rm -f /tmp/ticker.$(hostname).$$
}
