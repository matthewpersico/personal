# -*- sh -*-

# xterminit

## WARNING: This script MUST be valid KORN SHELL.

## - No associative arrays.
## - No variables with - in them. Use _ instead.

## This script is run in the Bloomberg environment on dev machines under ksh
## before Chimera switches over to bash.

## Cygwin use only
startxserver() {
    if [ -z "$(ps -a | grep XWin)" ]
    then
        if [ "$1" = '--verbose' ]
        then
            echo "Starting Cygwin XServer..."
        fi
        startxwin 2>/dev/null 2>/dev/null &
        XSERVER='XWin'
    fi
}

## init
hasx=0
if [ -z "$DISPLAY" ]
then
    export DISPLAY=:0.0
else
    hasx=1
fi

XSERVER=''
if [ "$(uname -o)" = 'Cygwin' ]
then
    hasXming=$(ps -aW | grep Xming.exe)
    if [ -n "$hasXming" ]
    then
        echo "Using Xming XServer"
        XSERVER='Xming'
    else
        startxserver --verbose
    fi
elif [ "$hasx" = '0' ]
then
    ## X server ping...
    xmodmap 1>/dev/null 2>/dev/null
    if (($?))
    then
        ## There is no xserver. Do not set any of this up.
        return 0 ## return, not exit because this script is meant to be 'dotted in'
    fi
fi

if [ -z "$XTERM" ]
then
    for i in /bin /usr/bin /usr/bin/X11
    do
        if [ -z "$XTERM" ] && [ -e "$i/xterm" ]
        then
            XTERM="$i/xterm -ls -sb -sl 40000"
        fi
    done
fi

if [ -z "$XTERM" ]
then
    echo "$(date) - $(hostname) - Cannot find an xterm to use. xterm setup stops." >> ~/xterminit.stop
    return 0
fi

if [ -z "${HOSTNAME}" ]
then
    HOSTNAME=`hostname`
fi
export XTERM HOSTNAME

XTERMGEOW=132
XTERMGEOH=40
XTERMGEOX=200
XTERMGEOY=200
XTERMGEO="-geometry ${XTERMGEOW}x${XTERMGEOH}+${XTERMGEOX}+${XTERMGEOY}"
case ${HOSTNAME} in
    *bldo* )
        export NEWXCOLOR=red
        XTERMFONTS="-fa 'Monospace' -fs 10"
        ;;

    *bcpc* )
        export NEWXCOLOR=wheat
        XTERMFONTS="-fa 'Monospace' -fs 10"
        ;;

    nylxdev* )
        export NEWXCOLOR=darkblue
        XTERMFONTS=''
        ;;

    monolith* )
        export NEWXCOLOR=black
        if [ "$XSERVER" = 'XWin' ]
        then
            XTERMFONTS="-fa 'Monospace' -fs 10"
        else
            ## Xming
            XTERMFONTS='-fn lucidasanstypewriter-14'
        fi
        ;;

    * )
        export NEWXCOLOR=lightred
        XTERMFONTS=''
esac

## Set these up here because they use values set above
RXCmd ()
{
    local HOST="${1}"
	if [ -z ${HOST} ]
	then
		echo "Error: hostname not specified."
	else
		shift 1
		local XARGS="${*}"
		if [ -z "${XARGS}" ]
		then
			XARGS="$XTERMGEO"
		fi
		if [ "${HOST}" = "${HOSTNAME}" ]
		then
			${XTERM} -display ${DISPLAY} -name ${HOST} ${XARGS} &
		else
			local XCOOKIE=`/usr/bin/X11/xauth list ${DISPLAY}`
            #					${XARGS} >/dev/null 2>&1 &
            ssh ${HOST} "(
                                  PATH=$PATH:/usr/bin/X11
                                  DISPLAY=$DISPLAY
                                  export PATH DISPLAY
                                  xauth add ${XCOOKIE} >> ~/inlog 2>&1
                                  /usr/bin/nohup ${XTERM} -name ${HOST} \
                                                 ${XARGS} >> ~/inlog 2>&1 &
                                 )" &
		fi
	fi
}

newxguts ()
{
    local count=1
    local xtermgeow=$XTERMGEOW
    local checkargs=1
    while ((checkargs))
    do
        case $1 in
            -w )
                ## wide
                ((xtermgeow*=2)) ; shift ;;
            -n )
                ## narrow
                ((xtermgeow/=2)) ; shift ;;
            -s )
                ## std
                ((xtermgeow+-0)) ; shift ;;
            -[0-9]* )
                ## number of xterms to spawn
                ((count=$1*-1)) ; shift ;;
            * )
                ## We're done
                checkargs=0 ;;
        esac
    done
    local i=0
    while ((i<count))
    do
        local xtermgeo="-geometry ${xtermgeow}x${XTERMGEOH}+$((XTERMGEOX+(i*72)))+$((XTERMGEOY+(i*72)))"
        RXCmd ${HOSTNAME} $XTERMGEO $XTERMFONTS $@ $xtermgeo
        ((i+=1))
        sleep .05 ## Just enough to space out the &-ed invocations so that they
                  ## do not randomly appear, but rather appear in a nice
                  ## cascade.
    done
}

## If we want to change git colors, then define the color assignments
## with a series of -c name=value assignments in an ennvar GIT_COLORS
## and make git be a function such that it calls '/the/real/git
## $GIT_COLORS "$@"'.

newxgrey ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg darkgrey
}

newxdarkblue ()
{
    newxguts ${1:--1} ${2:--s} -fg wheat -bg darkblue
}

newxlightred ()
{
    newxguts ${1:--1} ${2:--s} -fg wheat -bg red
}

newxred ()
{
    newxguts ${1:--1} ${2:--s} -fg wheat -bg darkred
}

newxwhite ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg white
}

newxblack ()
{
    newxguts ${1:--1} ${2:--s} -fg white -bg black
}

newxblue ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg steelblue
}

newxgreen ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg seagreen
}

newxwheat ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg wheat
}

newxorange ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg orange
}

newxyellow ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg yellow
}

newxpink ()
{
    newxguts ${1:--1} ${2:--s} -fg black -bg pink
}

newx ()
{
    local bg=$(xterm_background)
    newx${bg} $@
}

perlx ()
{
    ## For starting up windows for forked Perl programs in debugger to
    ## attach to.
    local countem=$1; ## Specify as -x, like an option or x, like an arg
    ((countem)) || countem=1
    ((countem<0)) && ((countem=countem*-1)) ## if -x, make it positive
    while ((countem>0))
    do
        xterm -e sh -c 'echo This terminal was started to receive a forked perl debugger process.;
echo Set;
echo \$DB::fork_TTY=q\($(tty)\);
echo in the debugger before you reach the fork.;
echo Consider examining the value of the TERM variable;
echo to make sure it is something that perl5db.pl;
echo understands.;
echo Sleeping 99999999 starting at $(date);echo -e "\e]0;$(tty)\a
     ";sleep 99999999' &
        ((countem-=1))
    done
}
alias perldbx='perlx '

##
## Colors!
##

## Printable ANSI sequences

export ANSI_reset="\e[0m"
export ANSI_bold="\e[1m"
export ANSI_underscore="\e[4m"
export ANSI_blink="\e[5m"
export ANSI_reverse="\e[7m"
export ANSI_concealed="\e[8m"

export ANSI_FG_black="\e[30m"
export ANSI_FG_red="\e[31m"
export ANSI_FG_green="\e[32m"
export ANSI_FG_yellow="\e[33m"
export ANSI_FG_blue="\e[34m"
export ANSI_FG_magenta="\e[35m"
export ANSI_FG_cyan="\e[36m"
export ANSI_FG_white="\e[37m"

export ANSI_BG_black="\e[40m"
export ANSI_BG_red="\e[41m"
export ANSI_BG_green="\e[42m"
export ANSI_BG_yellow="\e[43m"
export ANSI_BG_blue="\e[44m"
export ANSI_BG_magenta="\e[45m"
export ANSI_BG_cyan="\e[46m"
export ANSI_BG_white="\e[47m"

## Query the colors
xterm_Xground_map_rgba9a9a9a9a9a9='grey'
xterm_Xground_map_rgb000000008b8b='darkblue'
xterm_Xground_map_rgbffff00000000='lightred'
xterm_Xground_map_rgb8b8b00000000='red'
xterm_Xground_map_rgbffffffffffff='white'
xterm_Xground_map_rgb000000000000='black'
xterm_Xground_map_rgb46468282b4b4='blue'
xterm_Xground_map_rgb2e2e8b8b5757='green'
xterm_Xground_map_rgbf5f5dedeb3b3='wheat'
xterm_Xground_map_rgbffffa5a50000='orange'

xterm_background ()
{
    xterm_Xground 11
}

xterm_foreground ()
{
    xterm_Xground 10
}

xterm_Xground ()
{
    [ -z "$1" ] && echo "Missing arg: 11 for foreground, 10 for background" && return 1
    local col=$1
    local iam=$(func-name-spoof)
    if [ -n "$XTERM_SHELL" ]
    then
        ## from http://superuser.com/questions/157563/programmatic-access-to-current-xterm-background-color
        exec < /dev/tty
        oldstty=$(stty -g)
        stty raw -echo min 0
        #          OSC   Ps  ;Pt ST
        echo -en "\033]${col};?\033\\" >/dev/tty  # echo opts differ w/ OSes
        result=
        if IFS=';' read -r -d '\' color ; then
            result=$(echo $color | sed 's/^.*\;//;s/[^rgb:0-9a-f/]//g')
            idxresult=$(echo $result | sed 's/[:/]//g')
        fi
        stty $oldstty
        local var=xterm_Xground_map_${idxresult}
        local color=$(eval echo "\$$var")
        if [ -n "${color}" ]
        then
            echo ${color}
            return
        else
            echo "## WARNING:$iam - no mapped color found for $result" >&2
        fi
    else
        echo "## WARNING:$iam - XTERM_SHELL not defined, probably not an xterm" >&2
    fi

    if [ -n "$NEWXCOLOR" ]
    then
        echo $NEWXCOLOR
        return
    else
        echo "## WARNING:$iam - NEWXCOLOR not defined" >&2
    fi

    echo "## WARNING:$iam - default color is grey" >&2
    echo grey
}

settitle ()
{
    echo -e "\033]0;$@\007\c"
}

tickerfg ()
{
    local i=0;
    local M="::: $@ :::"
    local T="$M$M$M$M"
    local S ## First time around clears the prompt
    echo "$M" > /tmp/ticker.$(hostname).$$
    while sleep .2s && [ -r /tmp/ticker.$(hostname).$$ ]
    do
        settitle "$S"
        (( ++i>${#M} )) && i=1
        S=${T:i:40}
    done
}

ticker ()
{
    if [ -r /tmp/ticker.$(hostname).$$ ]
    then
        echo Found /tmp/ticker.$(hostname).$$
        echo Looks like there is already a ticker running
        echo with the banner:
        echo
        cat /tmp/ticker.$(hostname).$$
    else
        tickerfg "$@" &
    fi
}

tickerkill ()
{
    rm -f /tmp/ticker.$(hostname).$$
}
