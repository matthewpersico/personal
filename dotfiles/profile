#!/usr/bin/env bash
# shellcheck disable=SC1090 #https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck disable=SC1091 #https://github.com/koalaman/shellcheck/wiki/SC1091

# profile
## Linked by ~/.profile.${USER}

## How to plug in (monkeypatch) set -x, VERBOSE_PROFILE, etc, if needed
[[ -x "${TILDAE}/profile.${USER}.monkeypatch" ]] && . "${TILDAE}/profile.${USER}.monkeypatch"

"$HOME/personal/bin/monkeytell" \
    "$VERBOSE_PROFILE" "${TILDAE}/profile.${USER}" 'start'

## OS_O(riginal) is the 'proclaimed' operating system name. Use this where a system may
## be lying, but fakes it pretty well. Do **NOT** use OS for this variable;
## that can be set by the operating system itself for its own purposes.
OS_O=$(uname -s)
export OS_O

## OS_ID is the 'true' operating system name. Use this primarily where
## we need to know if this is WSL or not.
OS_ID="$OS_O"
"${TILDAE}/personal/bin/iswsl" && OS_ID='WSL'
export OS_ID

## NFS cross-mount check
declare undershell
undershell="$(realpath "$SHELL")"
undershell="$(basename "$undershell")"
if [[ ! "$undershell" = 'bash' ]]; then
    echo "Skipping personal profile under '$SHELL'"
    return 0 ## return is ok even though this is not a function because this
             ## script is dotted in.
fi

shopt -s expand_aliases

##
## Start here
##
export PERSONALROOT=${TILDAE}/personal
export PERSONALBIN=$PERSONALROOT/bin
export PERSONALDATA=$PERSONALROOT/data
export LOCALROOT=${TILDAE}/local
export LOCALBIN=$LOCALROOT/bin
export LOCALDATA=$LOCALROOT/data

##
## autoload setup
##
export FPATH=$PERSONALROOT/functions ## First profile called so init is
                                     ## safe. Besides, we will not have
                                     ## 'addpath' until the autoload is done.
if [[ -z "$(declare -F autoload )" ]]; then
    ## Load autoloading. All of these functions get exported.
    # shellcheck disable=SC1090
    . "$PERSONALBIN/autoload"
fi

if [[ -z "$(declare -F autoloaded-personal)" ]]; then
    declare -a _profile_tmp

    ## autoload everything. Order does not matter here since it's all shims so
    ## nothing needs to know about anything else until it's actually called, in
    ## which case its shim, or its full function code, will be ready. Don't be
    ## verbose under cron.
    _profile_tmp=(-x -o -a "$PERSONALROOT/functions")
    ! $CRON && _profile_tmp+=(-y)
    autoload "${_profile_tmp[@]}"

    ## Over time you discover that many of your functions are only used in the
    ## context of backticks and other scripts that are executed but never
    ## sourced into your current process directly. That means that all of these
    ## subshells are going to re-evalute the shim over and over, even if you
    ## have exported the functions. This script will run 'autoload -l' on
    ## specified functions to do just that - unshim the most widely used
    ## functions. Again, don't be verbose under cron.
    _profile_tmp=()
    ! $CRON && _profile_tmp=(-y)
    _profile_tmp+=("$PERSONALDATA/autoload-unshim.dat")
    [ -f "$PERSONALDATA/autoload-unshim.dat" ] && \
        . "$PERSONALBIN/autoload-unshim"  "${_profile_tmp[@]}"
fi

## Now that functions are loaded, we can use them, starting with addpath.
addpath -fx PATH "$PERSONALBIN"
addpath -fx PATH "$LOCALBIN"

##
## env setup
##

## Variables that can be exported to subshells are loaded here. We also load
## the xterminit file here (via xtermfuncs) as it contains functions that we
## cannot break out into their own files for autoload since xterminit is run
## under ksh before bash is invoked on chimera machines at Bloomberg.
declare -a _profile_env_init_list
_profile_env_init_list+=('util.env' 'cd.env' 'perl.env' 'git.env')
_profile_env_init_list+=('ansi-colors.env' 'xtermfuncs' 'python.env')
_profile_env_init_list+=('nfssnapshot.env')
if [[ "$OS_ID" = 'WSL' ]]; then
    _profile_env_init_list+=('wsl.env')
fi

declare _profile_env _profile_envvar _profile_envvar_val
for _profile_env in "${_profile_env_init_list[@]}"; do
    _profile_envvar="$(echo "${_profile_env^^}" | tr -d '.' | tr '-' '_')_LOADED"
    _profile_envvar_val="$(eval echo "\$$_profile_envvar")"
    if [[ -z "$_profile_envvar_val" ]]; then
        "$HOME/personal/bin/monkeytell" \
            "$VERBOSE_PROFILE" "${TILDAE}/profile.${USER}" "Loading $_profile_env"
        # shellcheck disable=SC1090
        . "$PERSONALBIN/$_profile_env"
    else
        "$HOME/personal/bin/monkeytell" \
            "$VERBOSE_PROFILE" "${TILDAE}/profile.${USER}" \
            "Skipped loading $_profile_env, $_profile_envvar=$_profile_envvar_val"
    fi
done
if [[ "$CRON" = 'false' ]]; then
    ## Items we don't need in a cron job, some potentially fatal in that
    ## environment

    ## Check the personal repo.
    git-daily-repo-check "$PERSONALROOT"

    # MISC

    # Don't clear the screen. Don't cleanse colors. Exit at end.
    LESS="-XRE"
    export LESS

    # Needs setting
    declare _profile_pager
    for _profile_pager in less more; do
        [[ -z "$PAGER" ]] && PAGER=$(type -P $_profile_pager)
    done
    [[ -n "$PAGER" ]] && export PAGER

    # Editing
    declare iEDITOR
    for iEDITOR in xo emacs vi; do
        if [[ "$(type -P $iEDITOR 2>/dev/null)" ]]; then
            EDITOR="$iEDITOR"
            export EDITOR
            if [[ $EDITOR == 'xo' ]]; then
                LOGIT_EDITOR='xo -nf'
                export LOGIT_EDITOR
            fi
            break
        fi
    done

    # Browsing (decidedly non-standard)
    set-browser firefox

    # for silencing emacs dbus warning message
    export NO_AT_BRIDGE=1

    # History - set up a new history file per shell session. By the time we get
    # here, the function is defined in this session or an ancestor session, unless
    # we skipped it because we are running under cron.
    histinit

fi

"$HOME/personal/bin/monkeytell" \
    "$VERBOSE_PROFILE" "${TILDAE}/profile.${USER}" 'end'
