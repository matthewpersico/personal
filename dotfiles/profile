# -*- sh -*-
# ~/.profile.${USER}
# Isolates my stuff.

MASTER_SHLVL=$SHLVL
export MASTER_SHLVL

CRON=$(~/personal/bin/running_under_cron && echo true || echo false)

## OS_O is the 'proclaimed' operating system name. Use this where a system may
## be lying, but fakes it pretty well. Do **NOT** use OS for this variable;
## that can be set by the operating system itself for its own purposes.
OS_O=$(uname -o)
export OS_O

## OS_ID is the 'true' operating system name. use this primarily where
## we need to know if this is Winbash or not.
OS_ID=$OS_O
if [ "$OS_ID" = 'Gnu/Linux' ]
then
    _profile_iswinbash=$(uname -r | sed 's/.*\(Microsoft\).*/\1/')
    if [ "$_profile_iswinbash" = 'Microsoft' ]
    then
        OS_ID='Winbash'
    fi
fi
export OS_ID

## How to plug in (monkeypatch) set -x if needed
[ -e /tmp/profile.${USER} ] && . /tmp/profile.${USER}

! $CRON && [ -n "$ALLFUNCS_PROFILE" ] && \
    echo "$(date): ~/.profile.${USER} is running..."

## NFS cross-mount check
if [ ! "$(basename $SHELL)" = 'bash' ]
then
    echo "Skipping profile.mpersico5 under '$SHELL'"
    return 0 ## return is ok even though this is not a function because this
             ## script is dotted in.
fi

shopt -s expand_aliases

##
## Start here
##
export PERSONALROOT=~/personal
export PERSONALBIN=$PERSONALROOT/bin

## utilfuncs, pathfuncs, auditfuncs and histfuncs should be called in that
## order. Then the rest of the scripts have some minimal defs to use going
## forward.

_profile_funcsinitlist='utilfuncs pathfuncs auditfuncs histfuncs cdfuncs gitfuncs dotfilesfuncs Xfuncs xtermfuncs yumaptfuncs rsyncfuncs perlfuncs'

for _profile_func in ${_profile_funcsinitlist}
do
    ## We don't need to reload here if already loaded, which could happen
    ## in a subshell with our function exports.
    _profile_is_func_defined=$(declare -F | grep ${_profile_func}-reload )
    if [ -z "$_profile_is_func_defined" ]
    then
        if [ -f $PERSONALBIN/${_profile_func} ]
        then
            case ${_profile_func} in
                histfuncs )
                    ! $CRON && . $PERSONALBIN/${_profile_func} && histinit
                    ;;
                xtermfuncs )
                    ! $CRON && . $PERSONALBIN/${_profile_func}
                    ;;
                * )
                    . $PERSONALBIN/${_profile_func}
                    if [ "${_profile_func}" = 'pathfuncs' ]
                    then
                        ## This function is now defined and we can use
                        ## it. Because we are modifying PATH and PATH is
                        ## exported, we only need to run this when we load
                        ## pathfuncs; otherwise, this has already been done
                        addpath -f PATH $PERSONALBIN
                    fi
                    ;;
            esac
        fi
    fi
    _profile_alias=${_profile_func}.alias
    [ -f ${_profile_alias} ] && . ${_profile_alias} ## Aliases always have to be reloaded
done

## Check the personal repo.
! $CRON && (cd $PERSONALROOT
            if [ "$(cat .git-check-with-master.marker 2>/dev/null)" \
                     \< $(date +%Y%m%d) ]
            then
                echo "** Check $(pwd) against master ***"
                git-check-with-master --bail_on_dirty
                echo "** Check $(pwd) against itself ***"
                git status
                date +%Y%m%d > .git-check-with-master.marker
#            else
#                echo "** master/self check of $(pwd) already executed today **"
            fi
)

## GIT - Probably should put the .git-prompt.sh code, and the exports below,
## into gitfuncs as a function and just call that function here.
_profile_git_contrib_loaded=$(declare -F | grep __git_ps1)
if [ -z "$_profile_git_contrib_loaded" ]
then
    if [ -e ~/.git-prompt.sh ]
    then
        . ~/.git-prompt.sh
        safe_func_export --file ~/.git-prompt.sh
    fi
fi

# MISC

# STOP clearing the screen!!!
LESS="-X"
export LESS

# Needs setting
for _profile_pager in less more
do
    [ -z "$PAGER" ] && PAGER=$(which $_profile_pager)
done
[ -n "$PAGER" ] && export PAGER

_profile_since=$(date +'%a %b %d %H:%M:%S')
_profile_ps1_xterm_title_cmds=''
if [ ! "$EMACS" = 't' ]
then
    _profile_ps1_xterm_title_cmds='\[\e]0;\u@\h:\w\a\]'
fi
## Override prompt (assuming git stuff is loaded, either in chimera or locally)
##     status of
##     prior command
##     |           |
##     |        +--+
##     |        |
##     v--------v
PS1='\n[\$? = $?]\n\n'${_profile_ps1_xterm_title_cmds}'what    : \u@\h\nsince   : $since\nas-of   : \d \t$(__git_ps1 "\nbranch  : %s")$(git-get-stash-count -na -no0 "\nstashes : ")$(git-get-default-remote -na "\nremote  : ")\npwd     : \w\n[$$] \$ '
export PS1

# for silencing emacs 24.4 dbus warning message
export NO_AT_BRIDGE=1

# Editing
## Do NOT use an emacs command that hooks into the gnuserver or you'll have to
## exit the whole session to register completion with the user of EDITOR
EDITOR='vi'
! $CRON && [ $(which emacs 2>/dev/null) ] && EDITOR='emacsclient -c'
export EDITOR

# Aliases - no need for a separate alias file for profile. This will always get run
# Conveniences
alias cvs='echo cvs? Are you nuts? - Try again!'
alias dir='ls -la '
alias envg='env | grep '
alias setg='set | grep '
alias allg='(env && set) | grep '
alias rm='rm -i '
alias mydiff='diff -U3 '
alias sidediff='diff -w --side-by-side --suppress-common-lines '
alias mopquota='df -h '
alias showfunc='type '
alias grepnc='grep --color=never'

# Fat finger protection
alias vf='echo cd, you moron; cd '
alias fit='echo dir, you moron; dir '

# History - set up a new history file per shell session. By the time we get
# here, the function is defined in this session or an ancestor session.
histinit

! $CRON && [ -n "$ALLFUNCS_PROFILE" ] && \
    echo "$(date): ~/.profile.${USER} has run"
