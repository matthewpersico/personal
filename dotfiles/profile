# -*- sh -*-
# ~/.profile.${USER}
# Isolates my stuff.

MASTER_SHLVL=$SHLVL
export MASTER_SHLVL

CRON=$(~/personal/bin/running_under_cron && echo true || echo false)

##DEBUG:
$CRON || echo "$(date): ~/.profile.${USER} is running..."

## How to plug in (monkeypatch) set -x if needed
[ -e /tmp/profile.mpersico5 ] && . /tmp/profile.mpersico5

## NFS cross-mount check
if [ ! "$(basename $SHELL)" = 'bash' ]
then
    echo "Skipping profile.mpersico5 under '$SHELL'"
    return 0 ## return is ok even though this is not a function because this
             ## script is dotted in.
fi

shopt -s expand_aliases

PROFILE_FILE=${BASH_SOURCE[0]}
profile_edit ()
{
    xo $PROFILE_FILE
}
#nxport -f profile_edit
alias profile-edit=profile_edit

profile_reload ()
{
    . $PROFILE_FILE
}
#nxport -f profile_reload
alias profile-reload=profile_reload

##
## Start here
##
export PERSONALROOT=~/personal
export PERSONALBIN=$PERSONALROOT/bin

## Utils load first
. $PERSONALBIN/utilfuncs
utilfuncs-load

## Path manips next. Now we have some minimal defs to use going forward.
. $PERSONALBIN/pathfuncs
pathfuncs-reload
addpath -f PATH $PERSONALBIN

##
## Major initializations
##
on_nfs ()
{
    df -k $HOME | grep nfs > /dev/null
    return $?
}

funcsinitlist='auditfuncs histfuncs utilfuncs cdfuncs gitfuncs dotfilesfuncs \
  Xfuncs xtermfuncs yumaptfuncs rsyncfuncs perlfuncs'

for i in $funcsinitlist
do
    if [ -f $PERSONALBIN/$i ]
    then
        case $i in
            histfuncs | xtermfuncs )
                ! $CRON && . $PERSONALBIN/$i ;;
            * )
                . $PERSONALBIN/$i ;;
        esac
    fi
done

## Check the personal repo.
! $CRON && (cd $PERSONALROOT
            if [ "$(cat .git-check-with-master.marker 2>/dev/null)" \< \
                 $(date +%Y%m%d) ]
            then
                echo "** Check $(pwd) against master ***"
                git-check-with-master --bail_on_dirty
                echo "** Check $(pwd) against itself ***"
                git status
                date +%Y%m%d > .git-check-with-master.marker
            else
                echo "** master/self check of $(pwd) already executed today **"
            fi
)

# ALIASES

# Conveniences
alias cvs='echo cvs? Are you nuts? - Try again!'
alias dir='ls -la '
alias envg='env | grep '
alias setg='set | grep '
alias allg='(env && set) | grep '
alias rm='rm -i '
alias mydiff='diff -U3 '
alias sidediff='diff -w --side-by-side --suppress-common-lines '
alias mopquota='df -h '
alias showfunc='type '
alias grepnc='grep --color=never'

# Fat finger protection
alias vf='echo cd, you moron; cd '
alias fit='echo dir, you moron; dir '

## GIT - Probably should put the .git-prompt.sh code, and the exports below,
## into gitfuncs as a function and just call the function here.
git_contrib_loaded=$(declare -F | grep __git_ps1)
if [ -z "$git_contrib_loaded" ]
then
    if [ -e ~/.git-prompt.sh ]
    then
        . ~/.git-prompt.sh
    fi
fi
for i in $(declare -F | grep __git | grep -v -- --fx | sed 's/.* //')
do
    safe_func_export $i
done

# MISC

# STOP clearing the screen!!!
LESS="-X"
export LESS

since=$(date +'%a %b %d %H:%M:%S')
if [ ! "$EMACS" = 't' ]
then
    ## Override prompt (assuming git stuff is loaded, either in chimera or locally)
    ##     status of     these change
    ##     prior command xterm title
    ##     |           | |          |
    ##     |        +--+ |          +------+
    ##     |        |    |                 |
    ##     v--------v    v-----------------v
    PS1='\n[\$? = $?]\n\n\[\e]0;\u@\h:\w\a\]what    : \u@\h\nsince   : $since\nas-of   : \d \t$(__git_ps1 "\nbranch  : %s")$(git-get-stash-count -na -no0 "\nstashes : ")$(git-get-default-remote -na "\nremote  : ")\npwd     : \w\n[$$] \$ '
else
    PS1='\n[\$? = $?]\n\nwhat    : \u@\h\nsince   : $since\nas-of   : \d \t$(__git_ps1 "\nbranch  : %s")$(git-get-stash-count -na -no0 "\nstashes : ")$(git-get-default-remote -na "\nremote  : ")\npwd     : \w\n[$$] \$ '
fi
export PS1

# for silencing emacs 24.4 dbus warning message
export NO_AT_BRIDGE=1

# Editing
## Do NOT use an emacs command that hooks into the gnuserver or you'll have to
## exit the whole session to register completion with the user of EDITOR
EDITOR='vi'
! $CRON && [ $(which emacs 2>/dev/null) ] && EDITOR='emacsclient -c'
export EDITOR

##DEBUG:
$CRON || echo "$(date): ~/.profile.${USER} has run"
