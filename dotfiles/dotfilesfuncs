#-*- sh -*-

# dotfilesfuncs

auditfuncs-init
. $(which controlfuncs_build) $DOTFILESFUNCS_FILE

export DOTFILES_DIR=~/personal/dotfiles         # dotfiles directory
export DOTFILES_OLDDIR=~/personal/dotfiles_old  # old dotfiles backup directory
export DOTFILES_MANIFEST=$DOTFILES_DIR/dotfiles.manifest
                                         # declares dotfiles as an assoc array
                                         # and fills is with names and
                                         # locations of files/folders to
                                         # symlink
if [ ! $(basename "$SHELL") = 'bash' ]
then
    echo "We are using associative arrays. I can't tell if this is bash so caveat programmer."
fi

dotfilesfuncs-help ()
{
    local tmpfile=$(mktemp --suffix=.dotfilesfuncs_help)
    declare -F | grep dot | sed 's|.* ||' > ${tmpfile}.df1
    declare -F | grep syml | sed 's|.* ||' >> ${tmpfile}.df1
    alias | grep dot | sed 's|.* ||' >> ${tmpfile}.df1
    cat ${tmpfile}.df1 | sort -u | grep -v '^_'
    \rm -f ${tmpfile}.df1
}

_save-dotfile-entry ()
{
    local key=$1
    local link=$2
    local tmp=${DOTFILES_MANIFEST}.$$

    cp -f $DOTFILES_MANIFEST $tmp
    link=$(echo $link | sed "s|${HOME}|\${HOME}|")
    echo "dotfiles[$key]=$link" >> $tmp
    mv $tmp $DOTFILES_MANIFEST
    . $DOTFILES_MANIFEST
}

# Converts real files into dotfiles-based symlinks. Use this to add new files
# to be controlled.
adddotfile ()
{
    if [ "$1" = '' ]
    then
        echo "usage: adddotfile fileToSymlink"
        return 1
    fi

    local link="$(cd $(dirname $1);pwd)/$(basename $1)"
    local fullsrc=$(basename $1)
    ## Strip the dot from the stored version.
    fullsrc=$DOTFILES_DIR/${fullsrc##.}
    ## All - to _
    fullsrc=$(echo ${fullsrc} | tr '-' '_')
    . $DOTFILES_MANIFEST

    # change to the dotfiles directory
    echo -n "Changing to the $DOTFILES_DIR directory ..."
    builtin cd $DOTFILES_DIR
    echo "done"

    # Move the requested dotfile to the dotfiles directory, add it to the git
    # repo, link it and add it to the manifest.
    if [ -f $fullsrc ]
    then
        echo "File '$fullsrc' already exists. Skipping processing of '$link'."
    elif [ -d $fullsrc ]
    then
        echo "Directory '$fullsrc' already exists. Skipping processing of '$link'."
    elif [ ! -e $link ]
    then
        echo "'$link' does not exist to be copied and linked. Skipping processing of '$link'."
    elif [ ! -f $link ] && [ ! -d $link ]
    then
        echo "'$link' is not a file or directory that can be copied and linked. Skipping processing of '$link'."
    else
        srctype='directory'; if [ -f $link ]; then srctype='file'; fi

        echo "Moving real $srctype '$link' to '$fullsrc'"
        mv $link $fullsrc

        echo "Adding to local dotfiles repo. Don't forget to commit and push."
        git add ${fullsrc##$(pwd)/}

        local linkloc=$(dirname $link)
        local relsrc=${fullsrc#"${linkloc}/"}
        echo "Creating symlink '$link' to $srctype '$fullsrc'"
        (cd $linkloc
         ln -s $relsrc $link)
        _save_dotfile_entry $(basename $fullsrc) $link
    fi
    builtin cd -
}

dotfileadd ()
{
    adddotfile "$@"
}

# creates symlinks from any target file to the git-controlled source in
# ~/personal/dotfiles. Use this when initing a new vm.
makesymlinks ()
{
    # create DOTFILES_OLDDIR
    if [ ! -d $DOTFILES_OLDDIR ]
    then
        echo -n "Creating $DOTFILES_OLDDIR for backup of any existing dotfiles in ~..."
        mkdir -p $DOTFILES_OLDDIR
        echo "done"
    fi

    . $DOTFILES_MANIFEST

    # change to the dotfiles directory
    echo -n "Changing to the $DOTFILES_DIR directory ..."
    builtin cd $DOTFILES_DIR
    echo "done"

    # Move any existing dotfiles in to dotfiles_old directory, then create
    # symlinks from the original location to the corresponding files in the
    # ~/dotfiles directory.
    for src in ${!dotfiles[@]}; do
        local fullsrc=$DOTFILES_DIR/$src
        local link=${dotfiles[$src]}
        if [ ! -e $fullsrc ]
        then
            echo "'$fullsrc' not found. Skipping processing of '$link'."
        elif [ -h $link ]
        then
            echo "'$link' is already a link. Skipping processing of '$link'."
        elif [ -f $link ] || [ -d $link ]
        then
            srctype='directory'; if [ -f $link ]; then srctype='file'; fi
            echo "Moving existing $srctype '$link' to $DOTFILES_OLDDIR so we can link it to '$fullsrc'."
            mv $link $DOTFILES_OLDDIR/$(basename $link).$(date '+%Y%m%d%H%M%S')
        else
            echo "Creating symlink '$link' to '$fullsrc'."
            ln -s $fullsrc $link
        fi
    done
}
dotfilessync ()
{
    makesymlinks "$@"
}

syncdotfiles ()
{
    makesymlinks "$@"
}

makepstree ()
{
    local os=$(uname -o)
    case $os in
        Cygwin )
            echo Using /usr/bin/pstree
            ln -s /usr/bin/pstree ~/personal/bin/pstree
            ;;
        * )
            echo Creating local pstree
            builtin cd ~/personal/src/pstree
            make
            builtin cd -
            ;;
    esac
}

showdotfiles ()
{
    . $DOTFILES_MANIFEST

    echo foo
    echo ${!dotfiles[@]}
    for src in ${!dotfiles[@]}
    do
        fullsrc=$DOTFILES_DIR/$src
        link=${dotfiles[$src]}
        echo
        echo "******"
        echo "$link"
        echo "******"
        ls -la $link $fullsrc
    done
}

gitcheck_dotfiles ()
{
    builtin cd $DOTFILES_DIR
    git status
}

safe_func_export --file $DOTFILESFUNCS_FILE

auditfuncs-end
