# -*- sh -*-

# <Function Class: util>
# <Function Justification: maybe - frequency>

pick ()
{
    ##@@ none||none||pick||Prompt, list of valid choices separated by /'s, default.

    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare prompt=$(echo "$prompt_text ($choices)" | perl -p -e 's/\s+/ /g')
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
        ## We are doing a/b/c =~ a instead of a =~ a/b/c so that we don't have
        ## to worry about the choices list being a valid regexp. Of course, if
        ## we get pathological and try fi/fi/fo/fum =~ f, then you get what you
        ## deserve and deserve what you get.
	    if [[ $choices =~ $resp ]]
	    then
	        echo $resp
            return $OK
	    fi
    done
}
