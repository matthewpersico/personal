#!/us/bin/env bash

# <Function Class: util>
# <Function Justification: maybe - frequency>

pick ()
{
    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare prompt
    prompt=$(echo "$prompt_text ($choices)" | perl -p -e 's/\s+/ /g')
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo "$default"| tr '[:upper:]' '[:lower:]' | tr -d '[:blank:]' )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -r -p "$prompt" resp
	    resp=$(echo "${resp}" | tr '[:upper:]' '[:lower:]' )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
        ## We are doing a/b/c =~ a instead of a =~ a/b/c so that we don't have
        ## to worry about the choices list being a valid regexp. Of course, if
        ## we get pathological and try fi/fi/fo/fum =~ f, then you get what you
        ## deserve and deserve what you get.
	    if [[ /$choices/ =~ /$resp/ ]]
	    then
	        echo "$resp"
            return 0
	    fi
    done
}

return 0 ## usage guard when sourcing

:<<'__PODUSAGE__'
=head1 NAME

pick - prompt for a selection from a list

=head1 SYNOPSIS

  resp=$(pick "prompt text" "choice1/choice2[/...]" "default"
  if [ "$resp" = 'choice1' ]
  then
    ## ...
  elif [ "$resp" = 'choice2' ]
  then
    ##...
  else
    ##..
  fi

=head1 DESCRIPTION

Print the prompt text, a selection of options, print the user's choice.

=head1 ARGUMENTS

=over 4

=item "prompt text"

Prints this text, followed the list of choices and a '?', waiting for your response.

=item "choice1/choice2[/...]"

A set of strings, separated by '/'. It is required to use '/'.

=item "default"

The default response if you just hit return. If you do not want a default, specify a blank string, i.e: "".

=back

=cut

__PODUSAGE__
