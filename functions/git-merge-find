#!/usr/bin/env bash

# <Function Class: git>
# <Function Justification: none>

git-merge-find ()
{
    local opt_silent=0
    local opt_all=0
    local OPTSARGS
    OPTSARGS=$(getoptp -o sha --long silent,help,all -n "${FUNCNAME[@]}" -- "$@")
    local status=$?
    ((status != 0)) && func-usage && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--silent) opt_silent=1; shift ;;
            -h|--help) func-usage; return 0 ;;
            -a|--all) opt_all=1; shift ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; func-usage; return 1 ;;
        esac
    done

    local r
    local b
    local search
    local searchid
    if [ -n "$1" ]
    then
        search="${1}"
        searchid="${1}"
    else
        if ((opt_all==0))
        then
            if git-in-a-repo
            then
                r=$(git remote -v | grep origin | grep '(fetch)' | perl -an -e '$F[1] =~ s/[\/:]/--/g; print $F[1]')
                b=$(git-get-current-branch)
            else
                echo "Not in a repo"
                return 1
            fi
        fi
        search="${r}--${b}"
        rid=$(git remote -v | grep origin | grep '(fetch)' | perl -an -e 'print $F[1]')
        searchid="${rid}:${b}"
    fi
    merged=$(git config -f "${TILDAE:-$HOME}/.gitconfig.merge_audit" --list | grep -E -- "${search}" 2>/dev/null)
    if [ -z "$merged" ]
    then
        ((opt_silent)) || echo "No record of merging $searchid to anywhere."
        return 1
    else
        echo "$merged" | perl -n -e '
 BEGIN { $me = getlogin };
 chomp;
 my ($k, $v) = split(/=/);
 my ($sha,$date,$who) = split(/@/,$v);
 my ($tag,$tgt,$src) = split(/\./, $k);
 if ($tag eq q(merge-pr-by-tgt)) {
    $src =~ s/---/\//g;
    $tgt =~ s/---/\//g;
    my @srcparts = split(/--/, $src);
    my @tgtparts = split(/--/, $tgt);
    my @m = (qq(Merged $sha),
             qq(  from $srcparts[0]:$srcparts[1]/$srcparts[2]:$srcparts[3]),
             qq(    to $tgtparts[0]:$tgtparts[1]/$tgtparts[2]:$tgtparts[3]),
             qq(    on $date));
    push @m, qq(    by $who) if ($who ne $me);
    push @m, qq ();

    push @out, {
        d => $date,
        m => join(qq(\n),@m)
   };
 }
 END {
     print(map {$_->{m}} sort {$a->{d} cmp $b->{d}} @out)
 };
'
        return 0
    fi
}
