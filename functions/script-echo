# -*- sh -*-

# <Function Class: util>
# <Function Justification: uses $0>

script-echo ()
{
    # ANSI_reset is in the env, not all caps so chellcheck complains.
    # shellcheck disable=SC2154
    declare reset_normal="${ANSI_reset}"
    declare reset_title=''
    declare endofopts=0
    declare nonl
    declare cont=0
    declare title=0
    declare scriptname=$0
    while [[ "$1" =~ ^- ]] && ((endofopts==0))
    do
        ## Strip all leading dashes here so that -foo and --foo can both be
        ## processed as 'foo'.
        declare original="$1"
        declare option="$1"
        declare new=''
        while [ ! "$new" = "$option" ] && [ ! "$option" = '--' ]
        do
            new=$option
            option=${option##-}
        done
        shift

        case $option in
            head) echo ;;
            title)
                echo
                title=1
                reset_title="${reset_normal}"
                reset_normal=''
                ;;
            n) nonl='-n' ;;
            c) cont=1 ;;
            h|help) func-usage && return "$OK";;
            s) scriptname=$1 ; shift ;;
            --)
                endofopts=1 ;;
            -* )
                echo "script-echo: '$original' is an invalid option."; return "$NOT_OK";;
        esac
    done

    ## If SCRIPT_ECHO_NAME is set, we use it. This way, whether the script is
    ## the first in the chain or it's called from another script, we print the
    ## topmost script, which is probably what we want.
    [ -n "$SCRIPT_ECHO_NAME" ] && SCRIPT_ECHO_NAME="$(basename "$scriptname")"

    ## If scriptname is not set then no SCRIPT_ECHO_NAME, no -s and $0 is not
    ## available, which could happen if running the function outside a script
    ## (in a cut 'n paste test, for example.
    [ -z "$scriptname" ] && SCRIPT_ECHO_NAME='UNKNOWN SCRIPT'

    export SCRIPT_ECHO_NAME

    declare printit=${SCRIPT_ECHO_NAME}
    if ((cont))
    then
        ## Substitutes all the characters for spaces, giving us a properly
        ## spaced indent, sans script name, indicating a continuation of the
        ## prior line.
        # shellcheck disable=SC2001
        printit=$(echo "$printit" | sed 's/./ /g')
    fi
    declare p
    for p in "$@"
    do
        # ANSI_reverse is in the env, not all caps so chellcheck complains.
        # shellcheck disable=SC2154
        echo $nonl -e "${ANSI_reverse}>>> ${printit}${reset_normal}: $p${reset_title}"

        ## If there is a next line, it should be a continue line, but check
        ## before exec to not needlessly invoc.
        if [ "$printit" = "${SCRIPT_ECHO_NAME}" ]
        then
            # shellcheck disable=SC2001
            printit=$(echo "$printit" | sed 's/./ /g')
        fi

        ## Reset out of title
        if ((title))
        then
            title=0 ## no need to reset for ever
            reset_normal="${ANSI_reset}"
            reset_title=''
        fi
    done
}

return 0 ## USAGE guard during sourcing this file.

/dev/null<<EOSTRING
__USAGE__
script-echo - label info with script name

  script-echo [--head] [--title] [-n] [-c] [-s scriptname] "text" ["text"...]

Print the first "text" on a line with a reversed-color prefix containing the
script name. Print subsequent lines indented with reversed color spaces,
indicating continuation.

--head
  Print blank line before anything else

--title
  Print blank line before anything else and then print the first text line as
  reversed, not just the function name

-n
  Do not print a new line at the end of each line

-c
  Print the first "text" element as a continuation line.

-s
  Override '$0' with this option, unless SCRIPT_ECHO_NAME is set, which will
  take precedence. Sometimes, you may run a script that does not make any
  script-echo calls, yet that script may call other scripts which in turn will
  call script-echo. In that case, you will end up with script-echo printing the
  names of the scripts you are calling, not the name of the master script,
  confusing the output. In this case execute

    export SCRIPT_ECHO_NAME="$(basename "$0")"

  at the top of your master script to get the labeling correct all the way down
  the call tree.

__EOUSAGE__
EOSTRING

#  LocalWords:  scriptname
