#!/usr/bin/env bash

# <Function Class: util>
# <Function Justification: uses function env>

func-echo ()
{
    declare moreopts=1
    declare -a cmd_echo_opts
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        declare option
        option=$(dashstripper "$original")
        shift

        case $option in
            i )
                if [ -z "$1" ]
                then
                    echo "WARNING: func-echo: -i option has no argument"
                else
                    if [ -z "$CMD_ECHO_AS" ]
                    then
                        CMD_ECHO_AS=$1;
                    fi
                    shift
                    ## No export needed for function
                fi
                ;;
            o )
                override=$1; shift
                ;;
            h | help )
                func-usage func-echo
                exit 0
                ;;
            -- )
                moreopts=0
                ;&
            head | title | n | c )
                cmd_echo_opts+=("--$option");
                ;;
        esac
    done

    if [ -n "$*" ]
    then
        if [ -n "$override" ]
        then
            cmd-echo -o "$override" "${cmd_echo_opts[@]}" "$@"
        else
            [ -z "$CMD_ECHO_AS" ] && echo "CMD_ECHO_AS is unset (func-echo)" >&2
            cmd-echo -f "${CMD_ECHO_AS:-CMD_ECHO_AS is unset}" "${cmd_echo_opts[@]}" "$@"
        fi
    fi
}

return 0 ## USAGE guard during sourcing this file.

:<<'__PODUSAGE__'
=head1 NAME

func-echo - label echos in functions with the command name

=head1 SYNOPSIS

 func-echo -i [myFunctName] ## somewhere near the top of your function.

 func-echo [--head] [--title] [-n] [-c] -- "text" ["text"...]

 CMD_ECHO_NAME="$CMD_ECHO_NAME" SomeNonFunction arg arg...

=head1 DESCRIPTION

Call 'func-echo' to print the first "text" on a line with a reversed-color
prefix containing the command name. Print subsequent lines indented with
reversed color spaces, indicating continuation.

The name to print is determined as either the envar CMD_ECHO_AS or
${FUNCNAME[-1]} or the value passed to the -i option, if any.

You should call 'func-echo' only in functions. Calling 'func-echo' in a script
may result in either the wrong command or no command being printed.

Furthermore, if you call scripts inside your function that themselves use
'script-echo', you must pass the current value of the command name used for
printing down to the command. The command sequence is

  local cea="$CMD_ECHO_AS"

  CMD_ECHO_AS=$cea command args...
  ...
  CMD_ECHO_AS=$cea anotherCommand args...

And yes, you have to type that. CMD_ECHO_AS is set in the current environment
but not exported; scripts called by the function will run in a subprocess and
won't see the variable. And we don't want to export it because that will set
the value in the current process space and if that process space is your
command line, subsequent commands will all use the value set in first command
you typed that was a function.

=head1 OPTIONS

=item --

Indicates end of options to 'func-echo' so that all subsequent arguments are
taken as text to print. Technically not necessary UNLESS your first argument to
print happens to match one of the options to 'func-echo'.

=item -i

Initialize the name to be used as the command name to the optional argument, or
the current function name, but only if CMD_ECHO_AS is not already set.

=item
--head

Print a blank line for spacing before printing any text.

=item --title

Print a blank line for spacing before printing any text and then print the
entire first text line as reversed, not just the command name.

=item -n

Do not print a new line at the end of each line.

=item -c

Print the first "text" element as a continuation line.

=back

=head1 Environment Variable

__PODUSAGE__

#  LocalWords:  funcname shellcheck util func
