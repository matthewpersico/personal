#!/usr/bin/env bash

# <Function Class: git>
# <Function Justification: change cwd>

git-checkout ()
{
    echo "$(date +%Y-%m-%d.%H:%M:%S): git-checkout $*" >> ~/shellaudit
    declare opt_m=''
    declare message=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='m:'
    declare longopts='message:'

    # Process the command line.
    OPTSARGS=$(getopt -o -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@")
    declare status=$?
    ((status != 0)) && func_usage && return $status

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into#
    # variables.
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            m|message) opt_m=$option; message="$1"; shift ;;
            h|help) func_usage; return 0 ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -e -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    declare newbranch=$1
    declare createbranch=''
    if [ -z "$newbranch" ]
    then
        declare branchesa
        readarray -t branchesa < <(git branch --list --format='%(refname)' | sed 's|.*/||' )
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return 1
        fi
        declare current_branch
        current_branch=$(git branch get-current)
        declare PS3="Choose by number, q to quit: "
        declare newonemsg="Create a new one from $current_branch"
        declare selected
        COLUMNS=1 ## One character wide terminal, forces list to be one column
        select selected in "$newonemsg" "${branchesa[@]}"
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo "$selected is current. Cannot checkout current."
                elif [ "$selected" == "'$newonemsg'" ]
                then
                    while [ -z "$newbranch" ]
                    do
                        read -r -p "Enter a new branch name: " newbranch
                    done
                    if [ -d './wt' ]
                    then
                        declare resp
                        resp=$(cmd-yesno "As a worktree" y)
                        if [ "$resp" == 'y' ]
                        then
                            builtin cd ./wt || return $?
                            git-worktree-create "$opt_m" "$message" "$newbranch"
                            return $?
                        fi
                    fi
                    createbranch='-b'
                else
                    newbranch=${selected/\*/}
                fi
                break
            elif [ "$(echo "$REPLY" | tr '[:upper:]' '[:lower:]')" = 'q' ]
            then
                return 0
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi
    if [ -n "$newbranch" ]
    then
        if [ "$newbranch" = 'help' ]
        then
            echo "Use -help or --help"
            return
        fi
        if [ "$newbranch" = 'info' ]
        then
            git branch -vv
            return
        fi
        git checkout $createbranch "$newbranch"
        status=$?
        if [ "$status" = '0' ] && [ "$createbranch" = '-b' ]
        then
            echo "Setting upstream..."
            git push --set-upstream origin "$newbranch"
        fi

        if [ -n "$opt_m" ]
        then
            git-branch-ingo --timestamp local-status "$message"
        fi
        ## Update with changed branches
        git-go-set
        return $?
    fi
    return 0
}
