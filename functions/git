#!/usr/bin/env bash

##echo "****** GIT WRAPPER ENTERED!!!!!******" >&2
# git

# A wrapper around 'git' to extend it. See the docs at file's end.
git ()
{
    # shellcheck disable=SC2034
    local DEBUG__this_function=${FUNCNAME[0]}
    if [ -z "$REALGIT" ]; then
        echo "ERROR: git wrapper function 'git' can't find system git because envvar REALGIT is not defined. Bailing..."
        return 1
    fi

    if [[ $1 =~ --(real|bypass) ]]; then
        shift
        $REALGIT "$@"
        return $?
    fi

    if [[ $1 == '-x' ]]; then
        shift
        set -x
    fi

    if [[ $1 =~ -help ]]; then
        if [[ -n $2 ]]; then
            git "$2" "$1"
            return $?
        else
            git-usage git
            true; return $?
        fi
    fi

    # We made 'git' a function so that it would operate in the current process
    # space, which in turn means that any 'cd's that are executed, "stick" for
    # the user.  However, this function is still calling scripts in subprocess
    # space; any 'cd's in that subprocess are not going to stick even if
    # executed from a function.  So, what we do here is we keep a list of
    # commands whose 'cd' operations we want to have effect the current process
    # space.  When we call any of these functions, we pass them the flag
    # --doandcd with the name of a temp file.  Before those commands exit
    # successfully, they get their current working directory and write it into
    # the temp file.  When we return here after the command, we check the temp
    # file and if it contains a change directory command, we execute it so that
    # we end up where the command wanted us to be.
    local doandcdfile
    local -A doandcdlist
    doandcdlist[clone]=1
    doandcdlist[go]=1
    doandcdlist[worktree]=1
    doandcdlist[wt]=1
    doandcdlist[repo]=1

    # Set up the temp file to hold the target dir if we've been asked to
    # execute one of the 'cd'ing commands.
    local command=$1; shift
    local -a args
    if [ -n "${doandcdlist[$command]}" ]; then
        doandcdfile=$(mktemp -t "tmp.git.doandcd.$command.XXXXXXXXXX")
        args+=('--doandcd' "$doandcdfile")
    fi
    args+=("$@")

    # Execute either our command wrapper or the real git command, using the
    # type -P command to find any wrapper on PATH, just like git does. Except
    # that we will happily execute a script that matches a real git command.
    [ -n "$GIT_DISPATCHER_VERBOSE" ] && echo GIT WRAPPER sees command as "$command" and args as "${args[@]}" >&2
    local extend_script="git-${command}"
    if type -P "$extend_script" 1>/dev/null 2>/dev/null; then
        [ -n "$GIT_DISPATCHER_VERBOSE" ] && echo GIT WRAPPER calling "$extend_script" "${args[@]}" >&2
        "$extend_script" "${args[@]}"
    else
        [ -n "$GIT_DISPATCHER_VERBOSE" ] && echo GIT WRAPPER calling "${REALGIT}" "${command}" "${args[@]}" >&2
        "${REALGIT}" "${command}" "${args[@]}"
    fi
    local status=$?

    # If the command succeeds and we have a valid directory changing command in
    # the temp file, change directory.
    if ((status == 0)) \
           && [ -n "$doandcdfile" ] \
           && (( $(wc -l < "$doandcdfile") > 0 )); then
        local -a cdcmd
        read -r -a cdcmd < "$doandcdfile"
        if [ -n "${cdcmd[0]}" ] && \
               { [[ "${cdcmd[0]}" =~ ^(go|cd)$ ]] || \
                     { [[ "${cdcmd[0]}" == 'git' ]] && \
                           [[ "${cdcmd[1]}" == 'go' ]] ; \
                     } ; \
               }; then
            "${cdcmd[@]}"
            status=$?
        else
            cmd-echo -ec -- "Cannot '${cdcmd[*]}' - only 'cd', 'go', and 'git go' are supported"
            status=1
        fi
    fi

    # Whether or not the command succeeded, clean up after ourselves.
    [[ -n $doandcdfile ]] && \rm -f "$doandcdfile"

    return $status
}

:<<'__PODUSAGE__'
=head1 NAME

git - A wrapper around 'git' to extend it.

=head1 SYNOPSIS

 git ...

=head1 DESCRIPTION

If you want to add the command 'foo' to 'git', you can simply create the file
'git-foo', put it on your PATH, and invoke it as 'git foo'.

However, if you want to add to an EXISTING command, this doesn't work;
'git-worktree' on your PATH will not be called instead of 'git worktree'.

Soooooo, we have this wrapper that will see if a script exists on the path for
the given command, and if so, call that command. Otherwise, pass the command
off to git.

Note that your script 'git-bar' that extends an EXISTING command 'git bar' must
be able to determine when to handle the extended request itself and when to
hand off to the existing command. Handing off is done by executing

  "$REALGIT" bar ...

We do this because $REALGIT will not run YOUR git-bar (which is why we have
THIS script at all), meaning you won't end up in an endless loop.

The variables REALGIT and REALGIT_EXEC_PATH are defined in git.env

Note: If, as part of your new command or extended functionality, you want to
'cd' to someplace other than the current working directory, see the internal
comments of this function on how to do that.

=cut

__PODUSAGE__
