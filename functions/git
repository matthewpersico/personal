#!/usr/bin/env bash

# git

# A wrapper around 'git' to extend it. See the docs at file's end.
git ()
{
    local status
    local set_x_back_on=no
    if shopt -qo xtrace; then
        set_x_back_on=yes
        set +x
    fi

    # shellcheck disable=SC2034
    local DEBUG__this_function=${FUNCNAME[0]}
    if [[ -z "$REALGIT" ]]; then
        cmd-echo --id 'GIT WRAPPER' --ec -- "git wrapper function 'git' can't find system git because envvar REALGIT is not defined. Bailing..."
        [[ $set_x_back_on == 'yes' ]] && set -x
        ffalse; return $?
    fi

    if [[ $1 =~ --(real|bypass) ]]; then
        shift
        $REALGIT "$@"; status=$?
        [[ $set_x_back_on == 'yes' ]] && set -x
        return $status
    fi

    if [[ $1 == '-x' ]]; then
        shift
        set -x
    fi

    if [[ $1 =~ -help ]]; then
        if [[ -n $2 ]]; then
            git "$2" "$1"; status=$?
            [[ $set_x_back_on == 'yes' ]] && set -x
            return $status
        else
            git-usage git
            [[ $set_x_back_on == 'yes' ]] && set -x
            ftrue; return $?
        fi
    fi

    # We made 'git' a function so that it would operate in the current process
    # space. This, in turn, means that any 'cd's that are executed by this
    # function "stick" for the caller.  However, this function is still calling
    # scripts in subprocess space; any 'cd's in subprocesses are not going to
    # "stick" even if executed inside this function.  So, what we are doing
    # here is keeping a list of commands whose 'cd' operations we want to have
    # effect the current process space.  When we call any of these functions,
    # we pass them the flag --doandcd with the name of a temp file.  Before
    # those commands exit successfully, they get their current working
    # directory and write it into the temp file.  When we return here after the
    # command, we check the temp file and if it contains a change directory
    # command, we execute it so that we end up where the subprocess wanted us
    # to be.
    local doandcdfile
    local -A doandcdlist
    doandcdlist=([clone]=1 [go]=1 [worktree]=1 [wt]=1 [repo]=1)

    # Set up the temp file to hold the target dir if we've been asked to
    # execute one of the 'cd'ing commands. This command is so ubiquitous that
    # we are not going to pay the cumulative time penalty of sourcing
    # 'mktemp.binc' every time we run the function; we just use the same format
    # for the tempfile name that we find in that library.
    local command=$1; shift
    local -a args
    if [[ -n "${doandcdlist[$command]}" ]]; then
        doandcdfile=$(mktemp -t "tmp.$$.git-wrapper.doandcd.${command}.XXXXXXXXX")
        args+=('--doandcd' "$doandcdfile")
    fi
    args+=("$@")

    # Execute either our command wrapper or the real git command, looking for a
    # function or a script that matches git-$command, just like git does.

    # Except that we will execute a function if we find it.

    # And we will happily execute a function or script that matches a real git
    # command.
    local extend_command="git-${command}"
    local is_func
    local is_script
    is_func=$(declare -F "$extend_command" 2>/dev/null)
    [[ -z $is_func ]] && is_script=$(which "$extend_command" 2>/dev/null)
    if [[ -n $is_func ]] || [[ -n $is_script ]]; then
        if [[ ",${GIT_DISPATCHER_VERBOSE}," =~ ,${command},|all ]]; then
            local t
            [[ -n $is_func ]] && t='function'
            [[ -z $t ]] && t='script'
            cmd-echo --id 'GIT WRAPPER' --dc -- "Calling $t $extend_command ${args[*]}"
        fi
        [[ $set_x_back_on == 'yes' ]] && set -x
        "$extend_command" "${args[@]}"
        [[ $set_x_back_on == 'yes' ]] && set +x
    else
        if [[ ",${GIT_DISPATCHER_VERBOSE}," =~ ,${command},|all ]]; then
            cmd-echo --id 'GIT WRAPPER' --dc -- "Calling ${REALGIT} ${command} ${args[*]}"
        fi

        "${REALGIT}" "${command}" "${args[@]}"
    fi

    status=$?

    # If the command succeeds and we have a valid directory changing command in
    # the temp file, change directory.
    if ((status == $(ftrue; echo $?))) \
           && [[ -n "$doandcdfile" ]] \
           && (( $(wc -l < "$doandcdfile") > 0 )); then
        local -a cdcmd
        read -r -a cdcmd < "$doandcdfile"
        if [[ -n "${cdcmd[0]}" ]] && \
               { [[ "${cdcmd[0]}" =~ ^(go|cd)$ ]] || \
                     { [[ "${cdcmd[0]}" == 'git' ]] && \
                           [[ "${cdcmd[1]}" == 'go' ]] ; \
                     } ; \
               }; then
            "${cdcmd[@]}"
            status=$?
        else
            cmd-echo --id 'GIT WRAPPER' -ec -- "Cannot '${cdcmd[*]}' - only 'cd', 'go', and 'git go' are supported"
            ffalse; status=$?
        fi
    fi

    # Whether or not the command succeeded, clean up after ourselves. This
    # command is so ubiquitous that we are not going to pay cumulative time
    # penalty of sourcing 'on_exit.binc' every time we run the function; on the
    # extremely rare occasions that we don't get here, we'll let normal temp
    # cleanups take care of it.
    [[ -n $doandcdfile ]] && \rm -f "$doandcdfile"
    [[ $set_x_back_on == 'yes' ]] && set -x
    return $status
}

:<<'__PODUSAGE__'
=head1 NAME

git - A wrapper around 'git' to extend it.

=head1 SYNOPSIS

 git ...

=head1 DESCRIPTION

If you want to add the command 'foo' to 'git', you can simply create the file
'git-foo', put it on your PATH, and invoke it as 'git foo'.

However, if you want to add to an EXISTING command, this doesn't work;
'git-worktree' on your PATH will not be called instead of 'git worktree'.

Soooooo, we have this wrapper that will see if a script exists on the path for
the given command, and if so, call that command. Otherwise, pass the command
off to git.

Note that your script 'git-bar' that extends an EXISTING command 'git bar' must
be able to determine when to handle the extended request itself and when to
hand off to the existing command. Handing off is done by executing

  "$REALGIT" bar ...

We do this because $REALGIT will not run YOUR git-bar (which is why we have
THIS script at all), meaning you won't end up in an endless loop.

The variables REALGIT and REALGIT_EXEC_PATH are defined in 'git.env'.

Notes:

1) If, as part of your new command or extended functionality, you want to 'cd'
to someplace other than the current working directory, see the internal
comments of this function on how to do that.

2) Define the envvar GIT_DISPATCHER_VERBOSE to see what this wrapper chooses to
execute. Set it 'all' to catpure all commands or set it to

 'cmd1,cmd2,cmd3'

to capture only those three commands. You can use any number of comma-separated
commands.

=cut

__PODUSAGE__
