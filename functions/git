#!/usr/bin/env bash

# git

# A wrapper around 'git' to extend it. See the docs at file's end.
git ()
{
    # shellcheck disable=SC2034
    local DEBUG__this_function=${FUNCNAME[0]}
    if [[ -z "$REALGIT" ]]; then
        cmd-echo --id 'GIT WRAPPER' --ec -- "git wrapper function 'git' can't find system git because envvar REALGIT is not defined. Bailing..."
        false; return
    fi

    if [[ -z $1 ]]; then
        git-usage git
        true; return
    elif [[ $1 =~ --(real|bypass) ]]; then
        shift
        $REALGIT "$@"
        return $?
    elif [[ $1 == --help ]] || [[ $1 = -h ]]; then
        if [[ -n $2 ]]; then
            git "$2" --help
            return $?
        else
            git-usage git
            true; return
        fi
    fi

    if [[ $1 == '-x' ]]; then
        shift
        set -x
    fi

    # Apparently, you can't create a git alias for an extended or expanded git
    # script or function. So we alias them here and handle any arguments in the
    # alias expansion.
    local -A git_aliases
    git_aliases=([wt]=worktree [st]=status [stx]='status -ext' [ls]=ls-files)
    local alias="$1"; shift
    local -a commands=("$alias")
    if [[ -n ${git_aliases[$alias]} ]]; then
        asplit "${git_aliases[$alias]}" -a commands
    fi

    # We made 'git' a function so that it would operate in the current process
    # space. This, in turn, means that any 'cd's that are executed by this
    # function "stick" for the caller.  However, this function is still calling
    # scripts in subprocess space; any 'cd's in subprocesses are not going to
    # "stick" even if executed inside this function.  So, what we are doing
    # here is keeping a list of commands whose 'cd' operations we want to have
    # effect the current process space.  When we call any of these functions,
    # we pass them the flag --doandcd with the name of a temp file.  Before
    # those commands exit successfully, they get their current working
    # directory and write it into the temp file.  When we return here after the
    # command, we check the temp file and if it contains a change directory
    # command, we execute it so that we end up where the subprocess wanted us
    # to be.
    local doandcdfile
    local -A doandcdlist
    doandcdlist=([clone]=1 [go]=1 [worktree]=1 [repo]=1)

    # Set up the temp file to hold the target dir if we've been asked to
    # execute one of the 'cd'ing commands. These functions (git) are so
    # ubiquitous that we are not going to pay the cumulative time penalty of
    # sourcing 'mktemp.binc' every time we run the function; we just use the
    # same format for the tempfile name that we find in that library.
    local -a args
    if [[ -n "${doandcdlist[${commands[0]}]}" ]]; then
        doandcdfile=$(mktemp -t "tmp.$$.git-wrapper.doandcd.${commands[0]}.XXXXXXXXX")
        args+=('--doandcd' "$doandcdfile")
    fi
    args+=("$@")

    # Execute either our command wrapper or the real git command, looking for a
    # function or a script that matches git-$command, just like git does.

    # Except that *we* will execute a function if we find it. Real git won't.

    # And *we* will happily execute a function or script that matches a real
    # git command. Real git won't.

    local status
    local ex_ten_pan_d_command="git-${commands[0]}"
    local is_func
    local is_script
    is_func=$(declare -F "$ex_ten_pan_d_command" 2>/dev/null)
    [[ -z $is_func ]] && is_script=$(which "$ex_ten_pan_d_command" 2>/dev/null)
    if [[ -n $is_func ]] || [[ -n $is_script ]]; then
        if [[ ",${GIT_DISPATCHER_VERBOSE}," =~ ,${commands[0]},|,${alias},|all ]]; then
            local t
            [[ -n $is_func ]] && t='function'
            [[ -z $t ]] && t='script'
            cmd-echo --id 'GIT WRAPPER' --dc -- "Calling $t $ex_ten_pan_d_command ${args[*]}"
        fi
        commands[0]="${ex_ten_pan_d_command}"
        # shellcheck disable=SC2034 #https://github.com/koalaman/shellcheck/wiki/SC2034
        export GIT_DISPATCHER=inprogress
        "${commands[@]}" "${args[@]}"
        status=$?
        unset GIT_DISPATCHER
    else
        if [[ ",${GIT_DISPATCHER_VERBOSE}," =~ ,${commands[0]},|,${alias},|all ]]; then
            cmd-echo --id 'GIT WRAPPER' --dc -- "Calling ${REALGIT} ${commands[*]} ${args[*]}"
        fi

        "${REALGIT}" "${commands[0]}" "${args[@]}"
        status=$?
    fi

    # If the command succeeds and we have a valid directory changing command in
    # the temp file, change directory.
    if ((status == $(true; echo $?))) \
           && [[ -n "$doandcdfile" ]] \
           && (( $(wc -l < "$doandcdfile") > 0 )); then
        local -a cdcmd
        read -r -a cdcmd < "$doandcdfile"
        if [[ -n "${cdcmd[0]}" ]] && \
               { [[ "${cdcmd[0]}" =~ ^(go|cd|ecd)$ ]] || \
                     { [[ "${cdcmd[0]}" == 'git' ]] && \
                           [[ "${cdcmd[1]}" == 'go' ]] ; \
                     } ; \
               }; then
            "${cdcmd[@]}"
            status=$?
        else
            cmd-echo --id 'GIT WRAPPER' -ec -- "Cannot '${cdcmd[*]}' - only 'cd', 'ecd', 'go', 'git-go' and 'git go' are supported"
            false; status=$?
        fi
    fi

    # Whether or not the command succeeded, clean up after ourselves. This
    # command is so ubiquitous that we are not going to pay cumulative time
    # penalty of sourcing 'on_exit.binc' every time we run the function; on the
    # extremely rare occasions that we don't get here, we'll let normal temp
    # cleanups take care of it.
    [[ -n $doandcdfile ]] && \rm -f "$doandcdfile"

    return $status
}
autotrack git "$0"
:<<'__PODUSAGE__'
=head1 NAME

git - A wrapper around 'git' to expand it.

=head1 SYNOPSIS

 git ...

=head1 DESCRIPTION

If you want to add the command B<foo> to B<git>, you can simply create the file
B<git-foo>, put it a directory on your B<$PATH>, and invoke it as B<git
foo>. This is known as B<extending> git.

However, if you want to add to an B<existing> command, this does not work; for
example, the program B<git-commit> in your B<PATH> will not be called when the
command of B<git commit> is issued. In order to do that, you need a different
techinque, which I call B<expanding> git.

That is the purpose of B<this> wrapper: given a command, it will take the
following actions, in this order:

=over 4

=item * Check if a function B<git-command> exists in the environment and execute that if found.

=item * Check if a script B<git-command> exists on B<$PATH> and execute that if found.

=item * Execute B<git command> using the fullpath to the actual git executable.

=back

Note that your function or script B<git-commnd> that B<expands> an existing
command B<git command> must be able to determine when to handle the expanded
request itself and when to hand off to the existing command. Handing off is
done by executing

  "$REALGIT" command ...

We do this because B<$REALGIT> will not run YOUR B<git-command>, which is why we
have this script in the first place.

We also end up handling commands that B<extend> git commands. This fucntion d
doesn't know or care if the function or script that it runs is an extension or
an expansion. The function or script itself will take care of the details.

=head1 NOTES

=over 4

=item 1.

The variables B<REALGIT> and B<REALGIT_EXEC_PATH> are defined in B<git.env>.

=item 2.

If, as part of your new command or extended functionality, you want to B<cd> to
someplace other than the current working directory, see the internal comments
of this function on how to do write your extension command to allow that.

=item 3

Define the envvar B<GIT_DISPATCHER_VERBOSE> to see what this wrapper chooses
to execute. Set it B<all> to catpure all commands or set it to

  'cmd1,cmd2,cmd3'

to capture only those three commands. You can use any number of comma-separated
commands.

__PODUSAGE__
