###############################################################################
#
# Name:        delpath
#
# Author:      Stephen Collyer (scollyer@netspinner.co.uk)
#
# Copyright:   Netspinner Ltd 2000-2003
#
# <Function Class: path functions>
# <Function Justification: env mod>
###############################################################################

delpath ()
{
    echo "${FUNCNAME[0]} \"$@\" ## $(date +%Y%m%d%H%M%S)" >> ${TILDAE:-$HOME}/personal/data/funcsaudit ## This is audit
    ###########################################################################
    # local variables
    ###########################################################################

    typeset options_shift_val options_missing_arg options_unknown_opt
    typeset options_num_args_left
    typeset opt_h opt_p opt_s
    typeset opt_x opt_v
    typeset opt_e opt_c opt_r
    typeset sep=:

    typeset pathvar new_path MATCH pathspec

    pathfunc_usage_init
    typeset -a USAGE
    i=0; USAGE[i]="delpath [-h] [-s separator] [-e|-c] [-r] [-x] [-v] [[-p] pathvar] pathspec"
    ((i+=1)); USAGE[i]="Deletes all path elements from 'pathvar' that match 'pathspec'. "
    ((i+=1)); USAGE[i]="The match is partial by default."
    ((i+=1)); USAGE[i]="$USAGE_OPT_P1"
    ((i+=1)); USAGE[i]="$USAGE_OPT_P2"
    ((i+=1)); USAGE[i]="$USAGE_OPT_P3"
    ((i+=1)); USAGE[i]="$USAGE_OPT_P4F"
    ((i+=1)); USAGE[i]="$USAGE_OPT_P5"
    ((i+=1)); USAGE[i]="$USAGE_OPT_S"
    ((i+=1)); USAGE[i]="$USAGE_OPT_E"
    ((i+=1)); USAGE[i]="-c - 'pathspec' must be a complete match for a path element."
    ((i+=1)); USAGE[i]="-r - P(r)une currently non-existent path elements from 'pathvar'."
    ((i+=1)); USAGE[i]="$USAGE_OPT_X"
    ((i+=1)); USAGE[i]="$USAGE_OPT_V"
    ((i+=1)); USAGE[i]="$USAGE_OPT_H"

    ###########################################################################
    # handle options
    ###########################################################################

    options "hp:s:xvecr:" "$@"
    shift $options_shift_val

    if [ -n "$opt_h" ]
    then
        Usage "${USAGE[@]}"
        return
    fi
    if [ -n "$opt_e" ] && [ -n "$opt_c" ]
    then
        Usage "${USAGE[@]}" "Cannot use both options -e and -c simultaneously"
        return
    fi
    if [ -n "$options_missing_arg" ]
    then
        Usage "${USAGE[@]}" "Missing argument for -$options_missing_arg"
        return
    fi
    if [ -n "$options_unknown_option" ]
    then
        Usage "${USAGE[@]}" "Unknown option -$options_unknown_option"
        return
    fi
    if [ $options_num_args_left -eq 0 ] && [ -z "$opt_r" ]
    then
        Usage "${USAGE[@]}" "No directory specified"
        return
    elif [ $options_num_args_left -eq 1 ]
    then
        pathspec="$1"
    elif [ $options_num_args_left -eq 2 ]
    then
        pathvar=$1
        pathspec="$2"
    elif [ $options_num_args_left -ge 3 ]
    then
        Usage "${USAGE[@]}" "Too many arguments"
    fi

    [ -n "$opt_p" ] && pathvar=$opt_p # use specified pathvar
    [ -z "$pathvar" ] && pathvar=PATH   # default

    [ -n "$opt_s" ] && sep=$opt_s;

    [ -n "$opt_e" ] && MATCH="-E"     # make grep use regexps
    if [ -n "$opt_c" ]
    then
        MATCH="-E"
        # match complete line
        delit="^$pathspec\$"
    else
        delit="$pathspec"
    fi

    FILTER=                           # default
    [ -n "$opt_r" ] && FILTER="| realpath_filter"

    ###########################################################################
    # main
    ###########################################################################

    # pass the path to makepath on the command line - long paths
    # may overflow arg list limits on some Unices

#    new_path=$(eval echo \$$pathvar | sep2line "${sep}" $FILTER | grep -v $MATCH "$pathspec")
#    eval $pathvar=$(makepath -s "${sep}" "$new_path")

    # use a temporary file to store the path to reconstruct - this
    # approach keeps command lines short

    eval echo \$$pathvar | sep2line "${sep}" $FILTER | grep -v $MATCH "$delit" > /tmp/makepath_in.$$
    eval $pathvar=$(makepath -s "${sep}" < /tmp/makepath_in.$$)
    /bin/rm -f /tmp/makepath_in.$$
    [ -n "$opt_v" ] && listpath -s "${sep}" -p $pathvar
    [ -n "$opt_x" ] && export $pathvar
}

# emacs
# Local Variables:
# mode: sh
# End:
