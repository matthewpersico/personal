# -*- sh -*-

# <Function Class: util>
# <Function Justification: none>

kvstoreinit ()
{
    echo "${FUNCNAME[0]} \"$@\" ## $(date +%Y%m%d%H%M%S)" >> ${TILDAE:-$HOME}/personal/data/funcsaudit ## This is audit
    local exists_ok=0
    local unique=0
    local reset=0
    while [[ "$1" =~ ^- ]] && ((endofopts==0))
    do
        case "$1" in
            --exists-ok ) exists_ok=1; shift ;;
            --unique    ) unique=1; shift ;;
            --reset     ) reset=1; shift ;;
            --     ) endofopts=1; shift;;
            -*     ) echo "$1 is an invalid option."; return 1;;
        esac
    done

    if [ ! -d ${TILDAE:-$HOME}/.kvdbs ]
    then
        echo Initializing kv storage at ${TILDAE:-$HOME}/.kvdbs
        mkdir ${TILDAE:-$HOME}/.kvdbs
    fi

    local db=$1;

    if [ ! "$(basename $db)" = "$db" ]
    then
        echo "ERROR - kv store name '$db' cannot include directories; all are stored at '${TILDAE:-$HOME}/.kvdbs'"
        return 1
    fi

    local dbfile=${TILDAE:-$HOME}/.kvdbs/$db

    if [ -e $dbfile ]
    then
        if ((reset))
        then
            \rm $dbfile
        elif ((exists_ok))
        then
            return 0
        else
            echo "ERROR - kv store name $db exists"
            return 1
        fi
    fi

    if ((unique))
    then
        ## 'unique' has the use case where multiple processes would need their
        ## own copies of the database. Instead, we generate a UUID and give it
        ## back to the caller to pass back into subsequent calls. This is not
        ## yet implemented in subsequent calls.
        local u=$(uuid)
        echo $u
        sqlite3 $dbfile "create table keyval (uuid text, key text, value text,
                             primary key (uuid, key)"
        local status=$?
        return
    else
        sqlite3 $dbfile "create table keyval (key text primary key, value text)"
        return $?
    fi
}
