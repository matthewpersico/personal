#!/usr/bin/env bash

# <Function Class: git>
# <Function Justification: none>

git-merge-pull-request ()
{
    script-echo "MAYDAY - git-merge-pull-request must be checked before being used - bit rot wrt git clone and git-clone and use of tree"
    return 1

    local githost=$1;shift
    local githost_url
    githost_url=$(kvstore get gitfuncs_gitsvcs "$githost")
    if [ -z "$githost_url" ]
    then
        echo "$githost is unknown. Valid githosts are:$(kvstore vals gitfuncs_gitsvcs)"
        return 1
    fi

    local opt_verbose=0
    local opt_keep=0
    local OPTSARGS
    OPTSARGS=$(getoptp -o vhk --long verbose,help,keep -n "${FUNCNAME[@]}" -- "$@")
    local status=$?
    ((status != 0)) && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) func-usage ; return 0;;
            -k|--keep) opt_keep=1; shift ;;
            -v|--verbose) opt_verbose=1; shift ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; func-usage; return 1 ;;
        esac
    done

    local tgtarg=$1
    local srcarg=$2
    local inamespace=0
    local irepo=1
    local ibranch=2

    local confirm_args=0
    local current_branch_delete=''

    ## If there is no srcarg, take the current branch
    if [ -z "$srcarg" ]
    then
        srcarg=$(git branch get-current)
        confirm_args=1
        current_branch_delete=$(pwd)
    fi

    ## Public and enterprise github web interfaces show merge source as
    ## 'user:branch'. We fix this up as 'user/tgtrepo/branch' and all our
    ## parsing further along 'just works' (but see below).
    srcarg="${srcarg/:/\/-\/}"

    ## if there are no slashes in the src, we assume it's just a branch. We fix
    ## this up as '//branch' and all our parsing further along 'just works'.
    [[ $srcarg =~ / ]] || srcarg="-/-/$srcarg"

    ## Using the triangle workflow shortcut:
    if [ "$tgtarg" = '--upstream' ] || [ -z "$tgtarg" ]
    then
        tgtarg=$(git config --get remote.upstream.url | sed 's/.*://')
        confirm_args=1
    fi

    asplit tgt / "$tgtarg"
    asplit src / "$srcarg"

    ## Ok, we just split on '/' assuming some form of namespace/repo/branch, but
    ## branch could itself have slashed in it. Sooooo, we fix that up here:
    local tmpend=${#src[@]}
    local tmpcount=$((tmpend - ibranch))
    tmp=("${src[$inamespace]}" "${src[$irepo]}" "$(ajoin / "${src[@]:$ibranch:$tmpcount}")")
    src=("${tmp[@]}")
    tmpend=${#tgt[@]}
    tmp=("${tgt[$inamespace]}" "${tgt[$irepo]}" "$(ajoin / "${tgt[@]:$ibranch:((tmpend-2))}")")
    tgt=("${tmp[@]}")

    ## Here, we set defaults for missing data...
    ([ "${src[$inamespace]}" = '-' ] || [ -z "${src[$inamespace]}" ] ) && src[$inamespace]=${USER}
    ([ "${src[$irepo]}"      = '-' ] || [ -z "${src[$irepo]}"      ] ) && src[$irepo]=${tgt[$irepo]}
    ([ "${src[$ibranch]}"    = '-' ] || [ -z "${src[$ibranch]}"    ] ) && src[$ibranch]=master
    ([ "${tgt[$ibranch]}"    = '-' ] || [ -z "${tgt[$ibranch]}"    ] ) && tgt[$ibranch]=master

    local srcurl="$githost:${src[$inamespace]}/${src[$irepo]}"
    local remote_ref
    remote_ref=$(ajoin _ "$(asplit - / "$(ajoin '_' "${src[@]}")")")

    local merge_src='remote'
    [ "${src[$inamespace]}" = "${tgt[$inamespace]}" ] && \
        [ "${src[$irepo]}" = "${tgt[$irepo]}" ] && \
        merge_src='origin'

    if ((confirm_args))
    then
        local resp
        resp=$(func-yesno "Merging to $githost:${tgt[$inamespace]}/${tgt[$irepo]}/${tgt[$ibranch]} from $githost:${src[$inamespace]}/${src[$irepo]}/${src[$ibranch]}")
        if [ "$resp" = 'n' ]
        then
            return 1
        fi
    fi
    ((opt_verbose)) && func-echo --head "Clone $githost:${tgt[$inamespace]}/${tgt[$irepo]}..."
    git clone --tree "${githost}:${tgt[$inamespace]}/${tgt[$irepo]}"
    local status=$?
    ((status)) && _git-cd-unwind && return $status
    local tgt_repo_dir
    tgt_repo_dir=$(pwd)

    ((opt_verbose)) && func-echo --head "Switch to branch ${tgt[$ibranch]}..."
    git checkout ${tgt[$ibranch]}
    local status=$?
    ((status)) && _git-cd-unwind && return $status

    local origcommitsha
    origcommitsha=$(git rev-parse HEAD)
    local newcommitsha
    newcommitsha=$(git rev-parse HEAD)
    local currentlogmsg="Current last commit on target branch ${tgt[$ibranch]}"
    func-echo --head "****** $currentlogmsg"
    git-log-shas-range "${origcommitsha}" "${newcommitsha}"
    status=$?
    ((status)) && _git-cd-unwind && return $status
    func-echo "******"

    if [ "$merge_src" = 'remote' ]
    then
        ((opt_verbose)) && func-echo --head "Add $srcurl... as a remote"
        ((opt_verbose)) && func-echo -c     "git remote add $remote_ref $srcurl"
        git remote add "$remote_ref" "$srcurl"
        status=$?
        ((status)) && _git-cd-unwind && return $status

        ((opt_verbose)) && func-echo --head "Fetch only the pull request branch (${src[$ibranch]}) from $srcurl (as remote ref $remote_ref)"
        ((opt_verbose)) && func-echo -c     "git fetch $remote_ref ${src[$ibranch]}"
        git fetch "$remote_ref" "${src[$ibranch]}"
        status=$?
        ((status)) && _git-cd-unwind && return $status

        ((opt_verbose)) && func-echo --head "Do the merge"
        ((opt_verbose)) && func-echo -c     "git rebase ${tgt[$ibranch]} ${remote_ref}/${src[$ibranch]}"
        git rebase ${tgt[$ibranch]} "${remote_ref}/${src[$ibranch]}"
        status=$?
        ((status)) && _git-cd-unwind && return $status

        newcommitsha=$(git rev-parse HEAD)
        local lasttwologmsg="Last commits on target branch ${tgt[$ibranch]}"
        func-echo --head "****** $lasttwologmsg"
        git-log-shas-range "${origcommitsha}" "${newcommitsha}"
        status=$?
        ((status)) && _git-cd-unwind && return $status
        func-echo "****** **************************"

        func-echo -c "Success is defined as"
        func-echo -c "1) You are reading this message."
        func-echo -c "2) The log entries from '$lasttwologmsg'"
        func-echo -c "   are consistent with entry from '$currentlogmsg'."
        echo
    else
        func-echo --head "Fetch only the pull request branch (${src[$irbranch]}) from $srcurl"
        git fetch "$srcurl" "${src[$ibranch]}"
        status=$?
        ((status)) && _git-cd-unwind && return $status
        [ "$(func-yesno cont)" = 'n' ] && echo return

        func-echo --head "Do the merge"
        git rebase "${tgt[$ibranch]}" "origin/${src[$ibranch]}"
        status=$?
        ((status)) && _git-cd-unwind && return $status
        [ "$(func-yesno cont)" = 'n' ] && echo return
        git checkout "${tgt[$ibranch]}"

        newcommitsha=$(git rev-parse HEAD)

        pause 'Go to another terminal, do a git log and see what you got. Then quit this, come back and fix the code accordingly.'
        ## INSERT SOME git log comparison instructions here!!!!!!
        _git-cd-unwind && return 1
    fi

    local pushback="git push origin HEAD:${tgt[$ibranch]}"
    local resp
    resp=$(func-yesno "Push back to ${githost} via '$pushback'")
    local retval
    if [ "$resp" = 'y' ]
    then
        pwd
        ((opt_verbose)) && func-echo --head "Push back"
        $pushback
        retval=$?
        if [ "$retval" = '0' ]
        then
            ## These two lines record the sha of what we committed so that
            ## later we can find all the repos/worktrees we committed from that
            ## have not been cleaned up so we can clean them up. We store the
            ## source with sha as key and the target with the time of merge as
            ## the value.
            local sha
            sha=$(git-log-grab-sha -1)
            git-merge-write "$sha" "$githost" "${tgt[@]}" "${src[@]}"
            ## Read what we just wrote
            git-merge-find "$sha"

            ## Cleanup the tmp repo used for the merge.
            if ((opt_keep))
            then
                resp=n
            else
                resp=$(func-yesno "Remove local tgt repo ($tgt_repo_dir)")
            fi
            if [ "$resp" = 'y' ]
            then
                git-delete-current-repo
                retval=$?
                if [ "$retval" != '0' ]
                then
                    return $retval
                    ## No cd unwind here. If something went wrong, stay here
                    ## and clean it up.
                fi
            else
                ## Play it purrty for 'lanta...
                git checkout ${tgt[$ibranch]}
                git pull
                ## No cd unwind here. If we are keeping the local master, we
                ## probably need to do something in it, so we stay.
            fi

            ## If we started out in a repo corresponding to the merged branch,
            ## go back and whack it.
            if [ -n "$current_branch_delete" ]
            then
                _git-cd-to "$current_branch_delete"
                if git-in-a-worktree
                then
                    git-delete-current-worktree --schedule 24
                else
                echo "***************** current branch delete ***************"
                echo " $(pwd) "
                    pause Going to run git-delete-current-rep
                    git-delete-current-repo
                fi
            fi
        fi
    else
        local fmpr
        fmpr=$(pwd)/FINISH-merge-pull-request
        func-echo    "Ok. Remember to '$pushback' soon before the master head advances."
        func-echo -c "We will write the local file $fmpr with this command for your future convenience."
        echo "$pushback" > "$fmpr"
        echo "git-delete-current-repo" >> "$fmpr"
        git-log-shas-range "${origcommitsha}" "${newcommitsha}" | comment-stream "## " >> "$fmpr"
        chmod +x "$fmpr"
        retval=0
    fi
    _git-cd-unwind && return $retval
}
