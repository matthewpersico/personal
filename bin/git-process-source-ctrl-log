#!/usr/bin/env bash

# git-process-source-ctrl-log

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

declare action='read'
declare opt_v='' ## passed to commit
declare status=0
declare parsed_cl
parsed_cl=$(mktemp -t tmp.git-process-source-ctrl-log.XXXXXXXXXX)
rm_on_exit "$parsed_cl"
declare -a pscl_flags
declare git_editor
declare opt_confirm=0
declare moreopts
moreopts=1
while [[ "$1" =~ ^- ]] && ((moreopts))
do
    declare original="$1"
    declare option
    option=$(dashstripper "$original")
    shift ## That way you avoid endless loops on invalid options.

    case $option in
        ## standard options
        h | help )
            script-usage
            ## (return if a func, exit if a script) 0
            ;;
        debug | x ) set -x; trap 'set +x' EXIT;;
        verbose | v )
            opt_v='-v'
            ;;
        commit)
            action=commit;
            pscl_flags+=(--write --newscl "$parsed_cl")
            ;;
        withstatus)
            action=withstatus;
            pscl_flags+=(--withstatus)
            ;;
        diff)
            pscl_flags+=(--diff)
            ;;
        cached)
            pscl_flags+=(--cached)
            ;;
        nosclonly)
            pscl_flags+=(--nosclonly)
            ;;
        filesonly)
            pscl_flags+=(--filesonly)
            ;;
        skip-no-source-ctrl-log)
            pscl_flags+=(--skipmissing)
            ;;
        confirm)
            opt_confirm=1
            ;;
        editor)
            git_editor=$2
            shift;;
        nocolor)
            pscl_flags+=(--nocolor);;
        --)
            moreopts=0
            ;;
        * )
            cmd-echo -- "$original is an invalid option. See $0 --help";
            ## (return if a func, exit if a script) 1
            ;;
    esac
done

## Everything else is a file
if [ -z "$1" ]
then
    cmd-echo "No files specified."
    exit 1
fi

declare -a filelist
declare file
for file in "$@"
do
    declare absolute_file
    absolute_file="$(pwd)/$file"
    if [ -r "$absolute_file" ]
    then
        filelist+=("$absolute_file")
    else
        ## $file is either a git rm'ed file, a git renamed file or a typo.
        if [ "$(git what is deleted | grep -E "^$file$")" = "$file" ] ||
               [ "$(git what is modified | grep -E "^$file$")" = "$file" ]
        then
            ## Then the file is indeed git rm'ed.
            filelist+=("$absolute_file")
        else
            cmd-echo "File $file not found. Aborting"
            exit 1
        fi
    fi
done

## Find the source-ctrl-log
declare source_ctrl_logdir
source_ctrl_logdir=$(git root)
if ((status != 0))
then
    script-usage
    exit $status
fi

declare source_ctrl_log="${source_ctrl_logdir}/$GITFUNCS_SOURCE_CTRL_LOG_NAME"
if [ ! -r "$source_ctrl_log" ]
then
    cmd-echo -- "$source_ctrl_log not readable"
    exit 1
fi
if [ "$action" = 'commit' ] && [ ! -w "$source_ctrl_log" ]
then
    cmd-echo -- "$source_ctrl_log not writable"
    exit 1
fi

declare source_ctrl_logbkp="${source_ctrl_log}.bkp"

declare others
others=$(find "$source_ctrl_logdir" -name "$GITFUNCS_SOURCE_CTRL_LOG_NAME" | grep -v "$source_ctrl_log")
if [ -n "$others" ]
then
    cmd-echo "Found $others. No other $GITFUNCS_SOURCE_CTRL_LOG_NAME allowed under $source_ctrl_logdir."
    exit 1
fi

## Backup
cp -f "$source_ctrl_log" "$source_ctrl_logbkp"
$DEBUG_PARSE_SOURCE_CTRL_LOG parse-source-ctrl-log --scl "$source_ctrl_log" "${pscl_flags[@]}" "${filelist[@]}"
status=$?
if ((status!=0))
then
    ## Restore
    cmd-echo "Rolling back $source_ctrl_log"
    cp -f "$source_ctrl_logbkp" "$source_ctrl_log"
    exit $status
fi

if [ "$action" = 'commit' ]
then
    ## We rebuild the filelist from the commit message file so that we can
    ## account for having skipped files because they do not have a
    ## source_ctrl_log entry.
    declare -a filelist_refreshed
    mapfile -t filelist_refreshed < <(perl -ne 'next if $_ =~ m/^(SUMMARY LINE HERE|o | |[a-zA-Z0-9_-]+\(\):|\n)/;print $_' "$parsed_cl")
    cmd-echo "About to commit" "${filelist_refreshed[@]}"
    declare resp='y'
    if ((opt_confirm))
    then
        resp=''
        resp=$(cmd-yesno 'Ok' n)
    fi
    if [ "$resp" = 'y' ]
    then
         if [ -z "$git_editor" ]
         then
             git commit -F "$parsed_cl" --edit $opt_v "${filelist_refreshed[@]}"
         else
             GIT_EDITOR=$git_editor git commit -F "$parsed_cl" --edit $opt_v "${filelist_refreshed[@]}"
         fi
         status=$?
         if((status!=0))
         then
             ## Restore
             cmd-echo "Rolling back $source_ctrl_log"
             cp -f "$source_ctrl_logbkp" "$source_ctrl_log"
             exit $status
         fi
    else
        cmd-echo "Commit aborted"
    fi
fi
[ -f "$source_ctrl_logbkp" ] && \rm -f "$source_ctrl_logbkp"

exit 0

:<< __EOUSAGE__
__USAGE__
NAME
    git-process-source_ctrl_log

SYNOPSYS

DESCRIPTION
    TBD
__EOUSAGE__
