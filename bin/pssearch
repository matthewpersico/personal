#!/usr/bin/env perl

use strict;
use warnings;
use Text::Wrap;

our %opt = (trunc => 0, wrap => 0, raw => 0,
            level => 10000000,
            head => 1,
            this => 1,
            exclude => 0,
            user => '-e',
            me => 0,
            short => 0);
my %print;
my %noprint;
my $wrap_min=0;

use Getopt::Long;
GetOptions(\%opt,
           qw( pid=i

               raw
               wrap
               trunc

               level=i
               head!
               this!
               exclude=i

               user|U=s
               e
               short
               me
         ) )
  or die ("Error in command line options\n");

my $uic = $opt{trunc} + $opt{wrap} + $opt{raw};
my $ui = '';
if ( $uic == 0 ) {
    $ui = 'trunc';
} elsif ( $uic == 1 ) {
    $ui = (grep { exists($opt{$_}) && $opt{$_} != 0}
      qw (raw wrap trunc))[0];
} else {
    die "--trunc, --wrap, --raw are mutex\n";
}
$opt{$ui} = `tput cols` + 0;
if ($opt{me} ){
    $opt{user} = $ENV{USER};
}
if ($opt{user} ne '-e' ) {
    $opt{user} = "-U $opt{user}";
}

if (@ARGV) {
    my $nohead = ($opt{head} ? '' : '--nohead');
    my $status;
    for my $pid (@ARGV) {
        system(
            join(' ',
                 ##'perl', '-d:ptkdb',
                 $0,
                 '--pid', $pid,
                 "--$ui",
                 '--level', $opt{level},
                 ($opt{head} ? '--head' : '--nohead'),
                 ($opt{this} ? '--this' : '--nothis'),
                 $opt{user},
                 '--exclude', ($opt{this} ? 0 : $$),
                 ($opt{short} ? '--short' : ())
             )
        );
        $status += ($? >> 8);
        print qq(\n);
        $nohead = '--nohead';
    }
    exit $status;
}

my $ih;
my %map =
  (
      TIME => {
          idx => 0, justify => q(right)
      },
      UID => {
          idx => 2, justify => q(right)
      },
      PID => {
          idx => 4, justify => q(right)
      },
      PPID => {
          idx => 6, justify => q(right)
      },
      TTY => {
          idx => 8, justify => q(left)
      },
      COMMAND => {
          idx => 10, justify => q(left)
      },
  );

my @headcols =
  map { $_->[1] }
  sort { $a->[0] <=> $b->[0] }
  map { [ $map{$_}{idx}, $_ ] }
  keys %map;

my $fmtcols = join( ',' , map { lc } @headcols );

for ($ENV{OS_O} || '') {
    /Cygwin/ && do {
        open(IH, '-|', "ps $opt{user}");
        last;
    };
    /Darwin/ && do {
        open(IH, '-|', "ps -o $fmtcols $opt{user}");
        last;
    };
    open(IH, '-|', "ps -o $fmtcols $opt{user}");
    last;
}

my $striplead=-1;
my $header;
my $printed;
my $pidcol=$map{PID}{idx};
my $ppidcol=$map{PPID}{idx};
my $packfmt;

LINE:
while(<IH>) {
    my $l = $_;
    if (not defined $header) {
        my $start = 0;
        my $end = 0;
        my $headfield;
        for my $colname (@headcols) {
            if ( $map{$colname}{justify} eq 'right' ) {
                $l =~ m/(\s*$colname)/;
                $headfield = $1;
            } else {
                $l =~ m/($colname\s*)/;
                $headfield = $1;
            }
            if ($colname eq $headcols[0] ) {
                $map{$colname}{fmt} = 'A' . length($headfield) . 'A1';
            } elsif ($colname eq $headcols[-1] ) {
                $map{$colname}{fmt} = 'A*';
            } else {
                $map{$colname}{fmt} = 'A' . (length($headfield)-1) . 'A1';
            }
            $packfmt .= $map{$colname}{fmt};
        }
        $header = $l;
        $wrap_min = index($l, q(COMMAND));
        $striplead = 0;
        next LINE;
    }

    my @f = unpack($packfmt, $l);
    my $pid = $f[$pidcol] + 0;
    my $ppid = $f[$ppidcol] + 0;
    if ( !$opt{pid} && $opt{this} ) {
        ## No matching. Print every line.
        $print{$pid} = 1;
    } elsif ( ( !$opt{this} && $$ == $pid )
                or
                ( $opt{exclude} && $opt{exclude} == $pid )
                or
                exists $noprint{$ppid}) {
        $noprint{$pid} = 1;
    } else {
        ## We are looking for a pid
        if (defined $opt{pid} && $pid eq $opt{pid}) {
            ## We matched it. Figure out how far in we want to indent.
            my $cmd = substr($l, $wrap_min);
            $cmd =~ m/^([|\s]+(?:\\_ )?)/;
            my $stripped = $1;
            $stripped ||= q();
            $striplead = length($stripped);
            $print{$pid} = 1;
        } else {
            ## We didn't match it. See if we printed its parent. If so then print this one.
            if (defined $print{$ppid}) {
                $print{$pid} = 1;
            }
        }
    }

    if(defined $print{$pid}) {
        if($header && not $opt{nohead}) {
            print $header;
            $printed++;
            $header = '';
        }
        if ($opt{trunc} ) {
            chomp $l;
            print substr($l,0,$wrap_min),
              substr($l,$wrap_min + $striplead,
                     $opt{trunc} - $wrap_min),"\n";
            $printed++;
        } elsif ($opt{wrap} ) {
            my $ll = substr($l,0,$wrap_min) . substr($l,$wrap_min + $striplead);
            my $indent_idx = index($ll, q(\\_));
            if ($indent_idx>-1) {
                $indent_idx+=3
            } else {
                $indent_idx=$wrap_min;
            }
            if($indent_idx) {
                $Text::Wrap::columns=$opt{wrap};
                print wrap(q(),( q( ) x ($indent_idx + 4 )), $ll);
                $printed++;
            } else {
                print $l;
                $printed++;
            }
        } else {
            print $l;
            $printed++;
        }
    }
}

if(! $printed && $opt{pid}) {
    print "No process found for pid $opt{pid}\n";
    exit 1;
}
exit 0;
