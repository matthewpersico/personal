#!/usr/bin/env perl

use strict;
use warnings;
use Text::Wrap;

our %opt = (trunc => 0, wrap => 0, raw => 0,
            head => 1,
            help => 0,
            this => 0,
            exclude => 0,
            user => '-e',
            me => 0,
            short => 0,
            verbose => 0,
            pid => [],
            cmd => [],
            color => 1
        );
my %print;
my %noprint;
my $wrap_min=0;

use Getopt::Long;
GetOptions(\%opt,
           qw( pid=i@
               cmd=s@

               raw
               wrap
               trunc
               color!

               head!
               this!
               exclude=i

               user|U=s
               short
               me

               verbose
               help
         ) )
  or die ("Error in command line options\n");

if ( $opt{help} ) {
    use Pod::Usage;
    pod2usage( -verbose => 99,
               -exitval => 0);
}
my $uic = $opt{trunc} + $opt{wrap} + $opt{raw};
my $ui = '';
if ( $uic == 0 ) {
    $ui = 'trunc';
} elsif ( $uic == 1 ) {
    $ui = (grep { exists($opt{$_}) && $opt{$_} != 0}
             qw (raw wrap trunc))[0];
} else {
    die "--trunc, --wrap, --raw are mutex\n";
}
$opt{$ui} = `tput cols` + 0;
if ($opt{me} ){
    $opt{user} = $ENV{USER};
}
if ($opt{user} ne '-e' ) {
    $opt{user} = "-U $opt{user}";
}

for my $search_arg (@ARGV) {
    my $which = (
        $search_arg =~ m/^\d+$/
          ? 'pid'
          : 'cmd');
    push @{$opt{$which}}, $search_arg
}

my $ih;

## 'idx' are all even because the "separator" columns are between them.
my %map =
  (
      START => {
          idx => 0, justify => q(right),
          alt => 'STARTED'
      },
      #      TIME => {
      #          idx => 0, justify => q(right),
      #          alt => 'TIME'
      #      },
      UID => {
          idx => 2, justify => q(right),
          alt => 'UID'
      },
      PID => {
          idx => 4, justify => q(right),
          alt => 'PID'
      },
      PPID => {
          idx => 6, justify => q(right),
          alt => 'PPID'
      },
      TTY => {
          idx => 8, justify => q(left),
          alt => 'TT'
      },
      COMMAND => {
          idx => 10, justify => q(left),
          alt => 'COMMAND'
      },
  );

my @headcols =
  map { $_->[1] }
  sort { $a->[0] <=> $b->[0] }
  map { [ $map{$_}{idx}, $_ ] }
  keys %map;

my $fmtcols = join( ',' , map { lc } @headcols );

my $ps="ps --forest -o $fmtcols $opt{user}";
for ($ENV{OS_O} || '') {

    /Cygwin/ && do {
        $ps="ps $opt{user}";
        last;
    };
    /Darwin/ && do {
        $ps="ps -o $fmtcols $opt{user}";
        last;
    };
}

$opt{verbose} and print STDERR "$ps\n";
open(IH, '-|', "$ps");

my $striplead=-1;
my $header;
my $printed;
my $pidcol=$map{PID}{idx};
my $ppidcol=$map{PPID}{idx};
my $cmdcol=$map{COMMAND}{idx};
my $packfmt;
my $ascii_bold_red = '[1;31m';
my $ascii_normal = '[m';

LINE:
while(<IH>) {
    my $l = $_;
    if (not defined $header) {
        my $start = 0;
        my $end = 0;
      COL:
        for my $colname (@headcols) {
            my $headfield;
            if ( $map{$colname}{justify} eq 'right' ) {
                $l =~ m/(\s*(?:$colname|$map{$colname}{alt}))\s/;
                $headfield = $1;
            } else {
                $l =~ m/((?:$colname|$map{$colname}{alt})\s*)/;
                $headfield = $1;
            }
            next if not defined $headfield;
            if ($colname eq $headcols[0] ) {
                $map{$colname}{fmt} = 'A' . length($headfield) . 'A1';
            } elsif ($colname eq $headcols[-1] ) {
                $map{$colname}{fmt} = 'A*';
            } else {
                $map{$colname}{fmt} = 'A' . (length($headfield)-1) . 'A1';
            }
            $packfmt .= $map{$colname}{fmt};
        }
        $header = $l;
        $wrap_min = index($l, q(COMMAND));
        $striplead = 0;
        next LINE;
    }

    my $uncoloredl = $l;
    my @f = unpack($packfmt, $l);
    my $pid = $f[$pidcol] + 0;
    my $ppid = $f[$ppidcol] + 0;
    my $cmd = $f[$cmdcol];
    if ( !@{$opt{pid}} && !$opt{exclude} && !@{$opt{cmd}} && $opt{this} ) {
        ## No matching. Print every line.
        $print{$pid} = 1;
    } elsif ( ( !$opt{this} && $$ == $pid )
                or
                ( $opt{exclude} && $opt{exclude} == $pid )
                or
                exists $noprint{$ppid}) {
        $noprint{$pid} = 1;
    } else {
        ## We are looking for a pid or a command
        my $match;
        if ( match_either($pid,$cmd) ) {
            ## We matched it. Figure out how far in we want to indent.
            my $cmd = substr($l, $wrap_min);
            $cmd =~ m/^([|\s]+(?:\\_ )?)/;
            my $stripped = $1;
            $stripped ||= q();
            $striplead = length($stripped);

            ## Color the matches.
            if($opt{color}) {
                for my $filt (@{$opt{pid}}, @{$opt{cmd}}) {
                    $l =~ s/$filt/${ascii_bold_red}${filt}${ascii_normal}/g;
                }
                $stripped = substr($stripped, 0, (length($stripped) - 1) - (length($l) - length($uncoloredl)));
                $striplead = length($stripped);
            }

            $print{$pid} = 1;
        } else {
            ## We didn't match it. See if we printed its parent or we didn't
            ## not print its parent. If so then print this one.
            if (defined $print{$ppid}
                  or (keys %noprint and not defined $noprint{$ppid})) {
                $print{$pid} = 1;
            }
        }
    }

    if(defined $print{$pid}) {
        if($header && not $opt{nohead}) {
            print $header;
            $printed++;
            $header = '';
        }
        if ($opt{trunc} ) {
            chomp $l;
            print substr($l,0,$wrap_min),
              substr($l,$wrap_min + $striplead,
                     $opt{trunc} - ($wrap_min - (length($l) - length($uncoloredl)))),"\n";
            $printed++;
        } elsif ($opt{wrap} ) {
            my $ll = substr($l,0,$wrap_min) . substr($l,$wrap_min + $striplead);
            my $indent_idx = index($ll, q(\\_));
            if ($indent_idx>-1) {
                $indent_idx+=3
            } else {
                $indent_idx=$wrap_min;
            }
            if($indent_idx) {
                $Text::Wrap::columns=$opt{wrap};
                print wrap(q(),( q( ) x ($indent_idx + 4 )), $ll);
                $printed++;
            } else {
                print $l;
                $printed++;
            }
        } else {
            print $l;
            $printed++;
        }
    }
}

if(!$printed) {
    if ($opt{pid}) {
        print "No process found for pid $opt{pid}\n";
        exit 1;
    }
} else {
    printf("%02d:%02d:%02d %s current time\n",
           (localtime)[2,1,0], q(-) x ($wrap_min -10));
}
exit 0;

sub match_either {
    my ($pid, $cmd) = @_;
    for (@{$opt{pid}}) {
        return 1 if $pid == $_;
    }
    for (@{$opt{cmd}}) {
        return 1 if $cmd =~ m/$_/;
    }
    return 0;
}

=head1 NAME

pssearch - ps with filtering

=head1 SYNOPSIS

 pssearch [--pid=i...]
          [--exclude=i]
          [--cmd="s"...]
          --[raw|wrap|trunc]
          [--[no]head]
          [--[no]this]
          [--[no]color]
          [ [--[user|U]=s] | --me ]
          [--verbose]
          [[pid|cmd]... ]

=head1 DESCRIPTION

Run a 'ps' command and filter the output.

=head1 ARGUMENTS

=over 4

=item pid or "cmd"

Numeric arguments are treated as if '--pid' was used. All other arguments are
treated as if '--cmd' was used. The output will be filtered to include
processes whose pids and commands that match the arguments, plus their child
processes. Multiple arguments are 'or'ed.

=back

=head1 OPTIONS

=over 4

=item --pid

Include the process that has this pid in the output. Also include its child
processes. More than one instance can be specified.

=item --exclude

Do not include the process that has this pid in the output. Not sure if child
processes would be included. More than one instance can be specified.

=item --cmd

Include the process whose command matches this regular expression in the
output. Also include its child processes. More than one instance can be
specified.

=item --raw|--wrap|--trunc

--raw - Do not do any formatting to the output.
--trunc - Truncate the output at terminal edge. This is the default.
--wrap - Wrap the output at the command column.

These three options are mutex.

=item --[no]head

Do or do not print the header. Default is to print it.

=item --[no]this

Do or do not include the 'pssearch' process itself or it's children in the
output. Default is to not include it.

=item --[no]color

Do or do not highlight any text that matches any pid or cmd argument used as a
filter. Default is to color the matches.

=item --user

Only print processes for this user name.

=item --me

Same as "--user $USER".

=item --verbose

Print the 'ps' command used before the ps output.

=back

=cut
