# -*- sh -*-

# gitfuncs

# Wrappers and extenders. Perhaps these should all be git-* commands in
# personal/bin.

auditfuncs-init
. $(which controlfuncs_build)

## This should match the '(change-log-default-name ...) in your emacs config.
GITFUNCS_CHANGELOG_NAME=SourceCtrlLog
export GITFUNCS_CHANGELOG_NAME

##
## gitfuncs environment stuff
##
gitfuncs_gitroot=${HOME}/gits; export gitfuncs_gitroot
gitfuncs_githook_root=${HOME}/.git_template; export gitfuncs_githook_root
gitfuncs_githook_dir=${HOME}/.git_template/hooks; export gitfuncs_githook_dir

kvstoreinit --exists-ok gitfuncs_gitsvcs

## 'loc'ations's' outside of ~/gits to look for repos.
kvstoreinit --exists-ok gitfuncs_gitlocs_extra
kvputinit gitfuncs_gitlocs_extra personal   ${HOME}/personal:depth=3
kvputinit gitfuncs_gitlocs_extra emacsd     ${HOME}/.emacs.d:depth=3
kvputinit gitfuncs_gitlocs_extra emacsdtaps ${HOME}/.emacs.d/taps/mpersico5:depth=3
kvputinit gitfuncs_gitlocs_extra examples   ${HOME}/examples:depth=3
kvputinit gitfuncs_gitlocs_extra nfs        ${HOME}/nfs/gits:depth=4

## These will be checked on each login and any time gitfuncs-reload is
## run. However, they are only ever executed when logging into a system where
## the home directory has never been used.
[ ! -e $gitfuncs_gitroot ] &&  mkdir -vp $gitfuncs_gitroot

[ ! -e ~/.gitconfig.merge_audit ] && touch ~/.gitconfig.merge_audit

## NOTE: At this file's end, we dot in any server-specific items that can be
## found in ./gitfuncs.I<server>. As of now, the list of supported servers is:

## github (www.github.com)

##
## Random aliases
##
alias gitpush='git push '
! $CRON && alias gitk="$(which gitk | tail -1 | sed 's/ +//') &"
alias gitnp='git --no-pager '
alias git-clean='git clean -e wt/ '

##
## To capture the git-* implemented stuff
##
## While we are working on it
## GITFUNCSBIN=$PERSONALBIN/git
## export GITFUNCSBIN=$PERSONALBIN/git
## addpath -f -p PATH $GITFUNCSBIN

#    [ "$GITFUNCS_SET_X" = ${FUNCNAME} ] && set -x
#    [ "$GITFUNCS_SET_X" = ${FUNCNAME} ] && set +x

##
## Goodies
##
git-st-por-usage ()
{
    echo "Usage: git-st-por [--strip [--]| -s [--]]  [arg ...]"
    echo "       git-st-por [--help|-h]"
    echo
    echo "       'git status' in porcelain mode."
    echo
    echo "       '--strip' will get remove the leading"
    echo "       status indicators. You need the '--'"
    echo "       that follows if you are passing other"
    echo "       'git status' options down."
    echo
    echo "       'arg' is any argument (or option, see"
    echo "       above) that you would normally"
    echo "       pass to 'git status'"
}
safe_func_export git-st-por-usage

git-st-por ()
{
    ##@@ none||none||git-st-por||git status in porcelain mode
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    local opt_strip=0
    OPTSARGS=$(getoptp -o sh --long strip,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--strip) opt_strip=1; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    if ((opt_strip))
    then
        git st --porcelain "$@" | sed 's/.* //'
    else
        git st --porcelain "$@"
    fi
    return $?
}
safe_func_export git-st-por

git-find-usage () {
    echo 'Usage: git-find [[--all | -a] | [--untracked | -u]] fileExprssion'
    echo '  A convenience function around'
    echo '    git ls-files $(git rev-parse --show-toplevel) | grep -E fileExpression'
    echo '  By default, only finds files that are in the repo'.
    echo '  --untracked - finds only files that are NOT in the repo.'
    echo '  --all       - finds repo and non repo files.'
}
safe_func_export git-find-usage

git-find ()
{
    ##@@ none||none||git-find||A convenience function around: git ls-files $(git rev-parse --show-toplevel) | grep -E fileExpression'
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    local opt_untracked_only=0
    local opt_all=0
    OPTSARGS=$(getoptp -o auh --long all,untracked-only,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --untracked_only|-u) opt_untracked_only=1; shift ;;
            --all|-a) opt_all=1; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    if [ "$opt_untracked_only" = 1 ] && [ "$opt_all" = 1 ]
    then
        echo "--untracked_only and --all are mutually exclusive"
        $usage_func
        exit 1
    fi

    local ls_files_opts="-c"
    if [ "$opt_untracked_only" = 1 ]
    then
        ls_files_opts="-o"
    elif [ "$opt_all" = 1 ]
    then
        ls_files_opts="-c -o"
    fi

    local to_find='*'
    [ -n "$@" ] && to_find="$@"
    for f in "$@"
    do
        git ls-files $ls_files_opts $(git rev-parse --show-toplevel) | grep -E "$f" | sort
    done
}
safe_func_export git-find

gitfind ()
{
    git-find "$@"
}
safe_func_export gitfind

git-find-conflicts ()
{
    ##@@ none||none||git-find-conflicts||search git repo files for the opening conflict marker (<<<<<<)
    gitfuncs_audit "$@"

    local opts='-l'
    if [ "$1" != '' ]
    then
        opts="$@"
    fi
    git grep $opts -E '^<<<<<<<' | sort -u
}
safe_func_export git-find-conflicts

git-status-with-changelog ()
{
    ##@@ none||none||git-status-with-changelog||Mix in $GITFUNCS_CHANGELOG_NAME text with corresponding file entries in git status.
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    local diff
    local noless
    local cdok=0
    OPTSARGS=$(getoptp -o sh --long diff,noless,cdok,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --cdok) cdok=1; shift ;;
            --diff) diff='--diff'; shift ;;
            --noless) noless='--noless'; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    ## All of the *-changelog functions work best in the git-root, which is
    ## where the $GITFUNCS_CHANGELOG_NAME is anyway
    local pwd=$(pwd)
    local gr=$(git-root)
    if [ ! "$pwd" = "$gr" ]
    then
        if ((!cdok))
        then
            echo "Current directory ($pwd) is not the git root ($gr)"
            local resp=$(func-yesno "Go there")
            if [ "$resp" = 'n' ]
            then
                return $NOT_OK
            fi
        fi
        _git_cd_to $gr  || return $?
    else
        gr=''
    fi

    local args="$@"
    if [ -z "$args" ]
    then
        args=$($DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --all) ## matches default git status setting
    fi
    local out=$(mktemp --suffix=.git-status-with-changelog)
    git-process-changelog --withstatus $diff $noless $args 1>$out 2>&1
    if [ -n "$noless" ]
    then
        cat $out
    else
        less -RE $out
    fi
    \rm -f $out
    status=$?
    [ -n "$gr" ] && _git_cd_return
    return $?
}
safe_func_export git-status-with-changelog

git-st-cl ()
{
    git-status-with-changelog "$@"
}
safe_func_export git-st-cl

git-st-ch ()
{
    git-status-with-changelog "$@"
}
safe_func_export git-st-ch

git-commit-with-changelog ()
{
    ##@@ none||none||git-commit-with-changelog||Use $GITFUNCS_CHANGELOG_NAME entries to create commit messages
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    ## All of the *-changelog functions work best in the git-root, which is
    ## where the $GITFUNCS_CHANGELOG_NAME is anyway
    local pwd=$(pwd)
    local gr=$(git-root)
    if [ ! "$pwd" = "$gr" ]
    then
        echo "Current directory ($pwd) is not the git root ($gr)"
        local resp=$(func-yesno "Go there")
        if [ "$resp" = 'n' ]
        then
            return $NOT_OK
        fi
        _git_cd_to $gr || return $?
    else
        gr=''
    fi

    local opt_a
    local opt_v
    ## Options first
    OPTSARGS=$(getoptp -o av -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -a) opt_a=$1; shift ;;
            -v) opt_v=$1; shift ;;
            -h) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local files="$@"
    ## This causes the same behavior as git commit with no args (default to
    ## only staged files), but we need to pass files into git-process.
    [ -z "$files" ] && files=$(git-what-is-staged)
    [ -n "$opt_a" ] && files=$(git-what-is-modified)
    git-process-changelog --commit $opt_v $files
    status=$?
    [ -n "$gr" ] && _git_cd_return
    return $status
}
safe_func_export git-commit-with-changelog

git-process-changelog-usage ()
{
    echo "git-process-changelog [-v] [ --write | [ --withstatus ] [ --diff ]"
    echo "    Only one $GITFUNCS_CHANGELOG_NAME in git root is supported."
}
safe_func_export git-process-changelog-usage

git-process-changelog ()
{
    ##@@ none||none||git-process-changelog||'Guts' function for *-with-changelog functions
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    ## All of the *-changelog functions work best in the git-root, which is
    ## where the $GITFUNCS_CHANGELOG_NAME is anyway
    local pwd=$(pwd)
    local gr=$(git-root)
    if [ ! "$pwd" = "$gr" ]
    then
        _git_cd_to $gr  || return $?
    else
        gr=''
    fi

    local action='read'
    local parse_flag=''
    local diff=''
    local opt_v='' ## passed to commit
    local status=0
    local parsed_cl=$(mktemp --suffix=.git-process-changelog)
    local pcl=$(which parse-changelog)
    local pcl_flags=''
    local noless=''

    ## Options first
    OPTSARGS=$(getoptp -o hv --long commit,withstatus,diff,noless,help -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -v) opt_v=$1
                shift;;
            --commit)
                action=commit;
                pcl_flags="$pcl_flags --write --ncl $parsed_cl"
                shift ;;
            --withstatus)
                action=withstatus;
                pcl_flags="$pcl_flags --withstatus";
                shift ;;
            --diff)
                pcl_flags="$pcl_flags --diff"
                shift ;;
            --noless)
                noless=1
                shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    ## Everything else is a file
    if [ -z $1 ]
    then
        echo "No files specified."
        [ -n "$gr" ] && _git_cd_return
        return $NOT_OK
    fi
    local filelist
    for i in "$@"
    do
        filelist="$filelist $(realpath $i)"
    done

    ## Find the changelog
    local changelogdir=$(git-root)
    if ((status != 0))
    then
        $usage_func
        [ -n "$gr" ] && _git_cd_return
        return $status
    fi

    local changelog="${changelogdir}/$GITFUNCS_CHANGELOG_NAME"
    if [ ! -r $changelog ]
    then
        echo "$changelog not readable"
        [ -n "$gr" ] && _git_cd_return
        return $NOT_OK
    fi
    if [ "$action" = 'commit' ] && [ ! -w $changelog ]
    then
        echo "$changelog not writable"
        [ -n "$gr" ] && _git_cd_return
        return $NOT_OK
    fi

    local changelogbkp="${changelog}.bkp"

    local others=$(find $changelogdir -name $GITFUNCS_CHANGELOG_NAME | grep -v "$changelog")
    if [ -n "$others" ]
    then
        echo "Found $others. No other $GITFUNCS_CHANGELOG_NAME allowed under $changelogdir."
        [ -n "$gr" ] && _git_cd_return
        return $NOT_OK
    fi

    ## Backup
    cp -f $changelog $changelogbkp
    $DEBUG_PROCESS_CHANGELOG $pcl --cl $changelog $pcl_flags $filelist
    status=$?
    if ((status!=0))
    then
        [ -n "$gr" ] && _git_cd_return
        return $status
    fi

    if [ "$action" = 'commit' ]
    then
        ##<TODO> In preparation of $pcl skipping files that do not have an entry, as
        ##<TODO> opposed to aborting the run, we need to re-read the filelist from the -F
        ##<TODO> file here.
        git commit -F $parsed_cl --edit $opt_v $filelist
        status=$?
        if((status!=0))
        then
            ## Restore
            echo "Rolling back $changelog"
            cp -f $changelogbkp $changelog
            [ -n "$gr" ] && _git_cd_return
            return $status
        fi
    fi
    [ -f $changelogbkp ] && \rm -f $changelogbkp
    [ -n "$gr" ] && _git_cd_return

}
safe_func_export git-process-changelog

git-cat-cl ()
{
    ##@@ none||none||git-cat-cl||'cat' the ChangeLog in the git root
    gitfuncs_audit "$@"

    local cl=$(git-root)/$GITFUNCS_CHANGELOG_NAME
    [ -r $cl ] && cat $cl && return $OK
    echo "$cl not found."
    return $NOT_OK
}
safe_func_export git-cat-cl

git-strip-repo ()
{
    ##@@ none||none||git-strip-repo||Remove the text '(repo)' from the argument.
    gitfuncs_audit "$@"

    echo $1 | sed 's/(repo)//'
}
safe_func_export git-strip-repo

git-add-repo-tag ()
{
    ##@@ none||none||git-add-repo-tag||Add the text '(repo)' to the argument.
    gitfuncs_audit "$@"

    echo "$1(repo)"
}
safe_func_export git-add-repo-tag

git-go-set ()
{
    ##@@ none||none||git-go-set||
    gitfuncs_audit "$@"

    local set_x=0
    if [ "$GIT_GO_SET_DEBUG" = '1' ]
    then
        set_x=1
        set -x ## set by envvar
    fi
    git-go-set-filename

    local current_git_go_file=$(git-go-get-filename)
    local repo_find_roots
    local search_roots="$gitfuncs_gitroot"
    local addmbig="$1"
    if [ "$addmbig" = '' ]
    then
        grep MBIG $current_git_go_file
        status=$?
        if ((status==0))
        then
            addmbig=1
        fi
    fi
    if [ "$addmbig" = '1' ]
    then
        search_roots="$search_roots $gitfuncs_gitroot_MBIG"
    fi
    for i in $search_roots
    do
        if [ -e $i ]
        then
            repo_find_roots="$repo_find_roots $i"
        fi
    done
    local repo_tops=$(find $repo_find_roots -maxdepth 1 -mindepth 1 -type d -follow)
    ## We can use -maxdepth to speed things up drastically because of the
    ## host/namespace/repo setup similarly for other git hosts.
    declare -A finds
    for d in $(kvgetvalues gitfuncs_gitlocs_extra) \
                 $repo_tops
    do
        local dir=${d%%:*}
        local depth=${d##*=}
        [ "$depth" = "$dir" ] && depth=3
        [ -d $dir ] && finds[$depth]="${finds[$depth]} $dir"
    done
    local depth
    local repos
    for depth in ${!finds[@]}
    do
        repos="$repos $(find ${finds[$depth]} -maxdepth $depth -name .git -type d | sed 's|/.git$||g' | sort -u)"
    done

    ## And then we do worktree (wt) search
    local repo
    local wts
    for repo in $repos
    do
        wts="$wts $(find $repo/wt -name .git -type f 2>/dev/null | sed 's|/.git$||g')"
    done

    ## We add $HOME here and set repo_tops_re after we find the repos so that
    ## the two repos in the home dir don't mess everything up.
    local repo_tops_re=":$(echo $repo_tops ${HOME}| sed 's/ /:/g'):"

    local repo_roots=$(local i j
                         for i in $repos $wts
                         do
                             git-add-repo-tag $i
                             j=$i
                             while [ -n "$j" ] && [ "$j" != 'done' ]
                             do
                                 if [ "$j" != "$i" ]
                                 then
                                     echo $j
                                 fi
                                 if [[ $repo_tops_re =~ ":$j:" ]]
                                 then
                                     j='done'
                                 else
                                     j=$(dirname $j)
                                 fi
                                 #for debugging:
                                 if [ $set_x = '1' ]
                                 then
                                     pause 'DEBUG MODE: Hit return to continue: '
                                 fi
                             done
                         done)
    echo $repo_roots $repo_tops | tr ' ' '\n' | sort -u | sed "s|${HOME}/||" > $gitfuncs_git_go_file
    ls ${HOME}/gits/.git-go* | grep -v $gitfuncs_git_go_file | xargs \rm -f
    if [ "$set_x" = '1' ]
    then
        set +x ## set by envvar
    fi
}
safe_func_export git-go-set

git-go-set-filename ()
{
    ##@@ none||none||git-go-set-filename||
    gitfuncs_audit "$@"

    gitfuncs_git_go_file=${HOME}/gits/.git-go.$(date +%Y%m%d)
}
safe_func_export git-go-set-filename

git-go-get-filename ()
{
    ##@@ none||none||git-go-get-filename||
    gitfuncs_audit "$@"

    ls -rt ${HOME}/gits/.git-go.* | head -1
}
safe_func_export git-go-get-filename

_git-go-get ()
{
    gitfuncs_audit "$@"

    ## no, we don't need getopt processing here. This is an internal func so we
    ## just have to GET IT RIGHT when we call it.
    local update=$1
    shift
    local roots=$1
    shift
    local mbig=$1
    shift
    local wt=$1
    shift
    local only_wt=$1
    shift
    local filter=$1
    shift

    git-go-set-filename
    if [ ! -e $gitfuncs_git_go_file ] || ((update))
    then
        git-go-set $mbig
    fi

    local tmpfile=$(mktemp --suffix=._git-go-get)
    cp $gitfuncs_git_go_file $tmpfile

    if ((roots==0))
    then
        cat $tmpfile | grep '(repo)' | sed 's/(repo)//' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((mbig==0))
    then
        cat $tmpfile | grep -v 'MBIG' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((wt==0))
    then
        cat $tmpfile | grep -v '/wt/' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((only_wt==1))
    then
        cat $tmpfile | grep '/wt/' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if [ -n "$filter" ]
    then
        cat $tmpfile | grep -i $filter > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    cat $tmpfile
    \rm -f $tmpfile
}
safe_func_export _git-go-get

git-go-usage ()
{
    gitfuncs_audit "$@"

    echo "Usage: git-go [--list[full] [--stat]] [--update|-u] [--roots|-r] [--mbig|-m] [--wt|--nowt|--wto[nly] ] [--mod] [dirmatch] [item]"
    echo "       git-go [-h|--help]"
    echo
    echo "       Presents a list of all git repos"
    echo "       in ${HOME}/gits"
    echo "       for you to choose and then cd to."
    echo
    echo "       --list will skip the choosing part and just exit, printing"
    echo "           each repo dir with ~"
    echo
    echo "       --listfull will skip the choosing part and just exit, printing"
    echo "           each repo dir with ~ expanded"
    echo
    echo "       --stat will invoke as if --list was specified but only for repos"
    echo "           with extended status information"
    echo
    echo "       --update will rescan to pick up new and deleted"
    echo "           repos and worktrees"
    echo
    echo "       --roots will add the non-git directories"
    echo "           where gits live so you can add new repos"
    echo
    echo "       --mbig will add the directories in MBIG"
    echo
    echo "       --wt will add the worktree subdirectories"
    echo "           in repos. This is the default."
    echo "       --nowt will not add them."
    echo "       --wto[nly] will show only worktrees."
    echo
    echo "       --mod will show status of repos that have mods outstanding"
    echo
    echo "       'dirmatch' will filter the list using grep"
    echo
    echo "       'item' is an integer N which will pick the Nth item in the"
    echo "           list of repos that would be presented if you didn't specify"
    echo "           an 'item'. Useful if you are cycling between a small number of repos."
    echo

}
safe_func_export git-go-usage

git-go ()
{
    ##@@ none||none||git-go||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    local PS3="Choose by number, q to quit: "
    local opt_list=0
    local opt_update=0
    local opt_roots=0
    local opt_mbig=0
    local opt_wt=1
    local opt_subwt_only=0
    local opt_gse=0
    local opt_mod=0
    local OPTSARGS=$(getoptp -o slurmhp: --long mod,stat,list,update,roots,mbig,help,wt,nowt,subwt,wtonly,listfull -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && $usage_func && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -l|--list) opt_list=1; shift ;;
            --listfull) opt_list=2; shift ;;
            -m|--mbig) opt_mbig=1; shift ;;
            -r|--roots) opt_roots=1; shift ;;
            -u|--update) opt_update=1; shift ;;
            --wt) opt_wt=1; shift ;;
            --nowt) opt_wt=0; shift ;;
            --subwt) opt_subwt_only=1; shift ;;
            --wtonly) opt_subwt_only=1; shift ;;
            --stat) opt_gse=1; opt_list=1; shift ;;
            --mod) opt_mod=1; shift;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local tgt
    tgt=$1
    shift;

    local opt_repo_no=0
    if [ -n "$1" ]
    then
        opt_repo_no=$1;
        shift
    fi

    if [[ "$tgt" =~ /$ ]]
    then
        tgt="$(dirname $tgt)/$(basename $tgt)"
    fi
    local REPOS
    REPOS=$(_git-go-get $opt_update $opt_roots $opt_mbig $opt_wt $opt_subwt_only "$tgt")
    if [ -z "$REPOS" ]
    then
        echo $tgt does not match any repo
        return $NOT_OK
    fi
    if [ "$(echo $REPOS | wc -w)" = '1' ]
    then
        echo "Matches only $REPOS. Going there."
        REPO=$REPOS
    else
        if (($opt_mod))
        then
            for r in $REPOS
            do
                (cd ~/$r
                 if (( $(git st --porcelain | wc  -l) ))
                 then
                     echo
                     func-echo $r
                     git st
                 fi)
            done
        elif (($opt_list))
        then
            local r
            local gse
            local sched
            local rr
            local lastwasmarker=0
            for r in $REPOS
            do
                (($opt_list==1)) && rr=$(echo '~'/${r})
                (($opt_list==2)) && rr=$(echo $nonl ~/${r})
                if ((!opt_gse))
                then
                    echo $rr
                else
                    gse=$(cd ~/$r; git-branch-info local-status)
                    sched=$(cd ~/$r; git-branch-info delete-worktree)
                    [ -n "$sched" ] && sched=$(date --date @$sched)
                    if [ -n "$gse" ] || [ -n "$sched" ]
                    then
                        echo "$rr:"
                        [ -n "$gse" ]   && echo "    $gse"
                        [ -n "$sched" ] && echo "    Scheduled for removal on or after $sched"
                        echo
                    fi
                fi
            done
        else
            local REPO

            if ((opt_repo_no))
            then
                local r
                for r in $REPOS
                do
                    ((opt_repo_no-=1))
                    if((opt_repo_no == 0))
                    then
                        REPO=$r
                    fi
                done
            else
                REPOS=$(tail_number_add $REPOS)
                COLUMNS=1 ## One character wide terminal, forces list to be one column.

                select REPO in $REPOS
                do
                    if (($opt_list))
                    then
                        return
                    fi
                    if [ -n "$REPO" ]
                    then
                        REPO=$(tail_number_strip "$REPO")
                        break
                    elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
                    then
                        return
                    else
                        echo "'$REPLY' is an invalid choice"
                    fi
                done
            fi
        fi
    fi
    if [ -n "$REPO" ]
    then
        ## dirlist, not builtin cd to take advantage this cd enhancement
        dirlist ${HOME}/$(git-strip-repo $REPO)
        git-check-this-hook
    fi
    return
}
safe_func_export git-go

gitgo ()
{
    git-go "$@"
}
safe_func_export gitgo

gitog ()
{
    git-go "$@"
}
safe_func_export gitog

git-list ()
{
    git-go -l "$@"
}
safe_func_export git-list

gitlist ()
{
    git-go -l "$@"
}
safe_func_export gitlist

git-get-current-branch ()
{
    ##@@ none||none||git-get-current-branch||
    gitfuncs_audit "$@"

    ( if [ -n "$1" ]
      then
          ## dirlist, not builtin cd, to take advantage this cd enhancement
          dirlist $1
      fi
      git symbolic-ref HEAD | sed 's!refs\/heads\/!!'
    )
}
safe_func_export git-get-current-branch

git-branch-get-current ()
{
    git-get-current-branch "$@"
}
safe_func_export git-branch-get-current

git-help ()
{
    ##@@ none||none||git-help||
    gitfuncs_audit "$@"

    local tmpfile=$(mktemp --suffix=.git-help)
    ls -c1 $PERSONALBIN/*git* 2>/dev/null| sed 's|.*/|script |' > ${tmpfile}.gh2
    declare -F | grep git | grep -v _git > ${tmpfile}.gh3

    sort -u ${tmpfile}.gh*
    \rm -f ${tmpfile}.gh*
}
safe_func_export git-help

git-rename-branch-usage ()
{
    echo "Usage: git-rename-branch old_branch new_branch"
}
safe_func_export git-rename-branch-usage

git-rename-branch ()
{
    ##@@ none||none||git-rename-branch||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    if (($#!=2))
    then
        $usage_func
        return $NOT_OK
    fi

    local old_branch=$1; shift
    local new_branch=$1; shift
    if (($#))
    then
        $usage_func
        echo "       argument(s) '$*' are illegal"
        return $NOT_OK
    fi

    echo "git branch -m $old_branch $new_branch ..."
    git branch -m $old_branch $new_branch        || return $? # Rename branch locally.

    echo "git push origin --delete $old_branch ..."
    git push origin --delete $old_branch         || return $? # Delete the old
                                                              # branch. DON'T
                                                              # DO THIS IF YOU
                                                              # HAVE AN OPEN
                                                              # PULL REQUEST!!!

    echo "git push --set-upstream origin $new_branch"
    git push --set-upstream origin $new_branch                # Push the new
                                                              # branch, set
                                                              # local branch to
                                                              # track the new
                                                              # remote.
    return $?
}
safe_func_export git-rename-branch

git-branch-rename ()
{
    git-rename-branch "$@"
}
safe_func_export git-branch-rename

git-delete-branch ()
{
    ##@@ none||none||git-delete-branch||
    gitfuncs_audit "$@"

    local no_remote=0
    local opt_yes=0
    OPTSARGS=$(getoptp -o y --long yes,no-remote,local-only -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -y|--yes) opt_yes=1; shift ;;
            --no-remote|--local-only) no_remote=1; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local branch=$1;
    local current_branch=$(git-get-current-branch)
    if [ -z "$branch" ]
    then
        local branchesa=($(git-branch-list --strip))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return $NOT_OK
        fi
        local PS3="Choose by number, q to quit: "
        local selected
        COLUMNS=1 ## One character wide terminal, forces list to be one column
        select selected in ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo $selected is current. Cannot delete current.
                else
                    branch=$selected
                    break
                fi
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return $OK
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi

    if [ -n "$branch" ]
    then
        ## $branch was either $1 or we did not ctrl-c out of the select.
        if [ "$branch" = "$current_branch" ]
        then
            echo "Nope, you can't delete the current branch."
            return $NOT_OK
        fi
        git branch -d $branch || return $?; ## This could fail. If so, go clean
                                            ## manually. Sometimes you get
                                            ## instructions on how to do that.
        if [ "$no_remote" = '1' ]
        then
            return $OK
        fi

        remotes=$(git remote)
        for remote in $remotes
        do
            local inremote=$(git-branch-list --strip -r | grep "$remote/$branch")
            if [ -n "$inremote" ]
            then
                local resp
                if ((opt_yes))
                then
                    resp='y'
                else
                    resp=$(func-yesno "Try deleting in remote $remote" n)
                fi
                if [ "$resp" == 'y' ]
                then
                    git push --delete $remote $branch ## This should not fail
                                                      ## since we have checked
                                                      ## that the branch exists
                                                      ## in the remote.
                fi
            fi
        done
    fi

    ## Update with changed branches
    git-go-set
    return $?
}
safe_func_export git-delete-branch

git-branch-delete ()
{
    git-delete-branch "$@"
}
safe_func_export git-branch-delete

git-update-this-hook ()
{
    ##@@ none||none||git-update-hook||
    gitfuncs_audit "$@"

    local hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${gitfuncs_githook_dir}/* | grep -v README.md | grep -v $GITFUNCS_CHANGELOG_NAME)
    else
        local h
        local newh
        for h in $hooks
        do
            newh="$newh ${gitfuncs_githook_dir}/$h"
        done
        hooks="$newh"
    fi
    local REPOS REPO
    REPOS=$(_git-go-get 0 0 1 0 0)
    for REPO in $REPOS
    do
        for h in $hooks
        do
           local hookdir="${HOME}/$(git-strip-repo $REPO)/.git/hooks"
           if [ -e "$hookdir/$(basename $h)" ]
           then
               cp -v $h $hookdir
           fi
        done
    done
}
safe_func_export git-update-this-hook

git-push-hook ()
{
    ##@@ none||none||git-push-hook||
    gitfuncs_audit "$@"

    local current_template=$(git config --get init.templatedir)
    if [ "$current_template" != "${gitfuncs_githook_root}" ]
    then
        echo "Error: Config says init.templatedir = '$current_template'"
        echo "       It should be '${gitfuncs_githook_root}'"
        echo "       Please correct."
        return $NOT_OK
    fi

    if [ ! -d "$current_template" ]
    then
        echo "Error: Can't find '$current_template'"
        echo "       Please correct."
        return $NOT_OK
    fi

    local hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${gitfuncs_githook_dir}/*)
    else
        local h
        local newh
        for h in $hooks
        do
            newh="$newh ${gitfuncs_githook_dir}/$h"
        done
        hooks="$newh"
    fi

    local REPOS REPO
    REPOS=$(_git-go-get 0 0 1 0 0 | grep -v ".git_template" )
    for REPO in $REPOS
    do

        echo "== $REPO"
        for h in $hooks
        do
            local hooktgtdir="${HOME}/$(git-strip-repo $REPO)/.git/hooks"
            if [ -f $hooktgtdir ]
            then
                echo $hooktgtdir is a file. whoops....
                ## Fix up accidental directory overwrite
                \rm $hooktgtdir
                mkdir $hooktgtdir
            fi

            local hooktgtpath="$hooktgtdir/$(basename $h)"
            if [ ! -e $hooktgtpath ] || [ $h -nt $hooktgtpath ]
            then
                if [ ! -e $hooktgtpath ]
                then
                    echo "$hooktgtpath not found. Copying from $h..."
                elif [ $h -nt $hooktgtpath ]
                then
                    echo "$hooktgtpath out of date. Updating from $h..."
                fi
                cp -pv $h $hooktgtpath
                chmod +x $hooktgtpath
            elif [ $h -ot $hooktgtpath ]
            then
                local tmpout=$(mktempv --suffix=.git-push-hook)
                diff  $h  $hooktgtpath 1>$tmpout 2>&1
                if [ -s $tmpout ]
                then
                    echo "$hooktgtpath newer than $h. Here's the diff, older to newer:"
                    cat $tmpout
                fi
                rm -f $tmpout
            fi
        done
    done
}
safe_func_export git-push-hook

git-check-this-hook ()
{
    ##@@ none||none||git-check-hook||
    gitfuncs_audit "$@"

    local gitloc="./.git"
    if [ -f $gitloc ]
    then
        ## We are probably in a worktree...
        gitloc=$(cat .git | sed 's/.* //')
        gitloc=${gitloc%%/worktrees*}
    fi
    if [ ! -d $gitloc ]
    then
        echo "Cannot run git-check-hook outside base repo dir - can't find .git"
        return $NOT_OK
    fi
    ret=0
    local hookloc="${gitloc}/hooks"
    for i in $(ls ${hookloc}/* | grep -v '.sample' | grep -v $GITFUNCS_CHANGELOG_NAME)
    do
        if [ ! -x $i ]
        then
            echo "INFO: git hook $i is not executable. Making it so."
            chmod a+x $i
        fi
    done
    return $OK
}
safe_func_export git-check-this-hook

git-checkout-usage ()
{
    echo "Usage: git-checkout ..."
    echo "       TBD"
}
safe_func_export git-checkout-usage

git-checkout ()
{
    ##@@ none||none||git-checkout||
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"

    local opt_m=''
    local message=''
    OPTSARGS=$(getoptp -o m: --long message: -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -m|--message) opt_m=$1; message="$2"; shift ; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local newbranch=$1
    local createbranch=''
    if [ -z "$newbranch" ]
    then
        local branchesa=($(git-branch-list --strip))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return $NOT_OK
        fi
        local current_branch=$(git-get-current-branch)
        local PS3="Choose by number, q to quit: "
        local newonemsg="Create a new one from $current_branch"
        local selected
        COLUMNS=1 ## One character wide terminal, forces list to be one column
        select selected in "'$newonemsg'" ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo "$selected is current. Cannot checkout current."
                elif [ "$selected" == "'$newonemsg'" ]
                then
                    while [ -z "$newbranch" ]
                    do
                        read -p "Enter a new branch name: " newbranch
                    done
                    if [ -d './wt' ]
                    then
                        local resp=$(func-yesno "As a worktree" y)
                        if [ "$resp" == 'y' ]
                        then
                            builtin cd ./wt || return $?
                            git-worktree-create $opt_m "$message" $newbranch
                            return $?
                        fi
                    fi
                    createbranch='-b'
                else
                    newbranch=$(echo $selected | sed 's|\*||')
                fi
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return $OK
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi
    if [ -n "$newbranch" ]
    then
        if [ "$newbranch" = 'help' ]
        then
            echo "Use -help or --help"
            return
        fi
        if [ "$newbranch" = 'info' ]
        then
            git branch -vv
            return
        fi
        git checkout $createbranch $newbranch
        status=$?
        if [ "$status" = '0' ] && [ "$createbranch" = '-b' ]
        then
            echo "Setting upstream..."
            git push --set-upstream origin $newbranch
        fi

        if [ -n "$opt_m" ]
        then
            git-st-ext "$message"
        fi
        ## Update with changed branches
        git-go-set
        return $?
    fi
    return $OK
}
safe_func_export git-checkout

git-branches ()
{
    git-checkout "$@"
}
safe_func_export git-branches

git-br ()
{
    git-checkout "$@"
}
safe_func_export git-br

gitbr ()
{
    git-checkout "$@"
}
safe_func_export gitbr

declare -A gitfuncs_remotes

git-parse-remote-v ()
{
    ##@@ none||none||git-parse-remote-v||
    gitfuncs_audit "$@"

    gitfuncs_remotes=()
    for i in $( git remote -v 2>/dev/null | sed -r -e 's/\(.*//' -e 's/ +$//' -e 's/\t/=/' | sort -ru)
    do
        key=${i%=*}
        value=${i#*=}
        gitfuncs_remotes[$key]=$value
    done
}
safe_func_export git-parse-remote-v

git-check-with-remote-usage ()
{
    echo "Usage: $1 --branch otherBranch [--remote remote] [gitRoot]"
}
safe_func_export git-check-with-remote-usage

git-check-with-remote ()
{
    ##@@ none||none||git-check-with-remote||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local iam=$(func-name-spoof)

    local opt_branch=''
    local opt_remote='origin'
    local opt_bail_on_dirty='0'
    local OPTSARGS=$(getoptp -o hb:r:c --long help,branch:,remote:,bail_on_dirty -n $iam -- "$@")
    status=$?
    ((status != 0)) && $usage_func $iam && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --bail_on_dirty) opt_bail_on_dirty=1; shift;;
            -r|--remote) opt_remote="$2"; shift; shift ;;
            -b|--branch) opt_branch="$2"; shift; shift ;;
            -h|--help) $usage-func $iam; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func $iam; return $NOT_OK ;;
        esac
    done

    if [ -z "$opt_branch" ]
    then
        echo "--branch required"
        $usage_func $iam
        return $NOT_OK
    fi

    local cb=$(git rev-parse --abbrev-ref HEAD)
    status=$?
    ((status != 0 )) && return $NOT_OK

    if [ "$cb" == '' ]
    then
        cat <<EOF

$iam is used to check your current git repo DEVELOPMENT branch in your local
clone against changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you do not appear to even be in a repo. I'm exiting. Try again in a
proper repo.

EOF
        return $NOT_OK
    fi

    if [ "$cb" == "$opt_branch" ]
    then
        cat <<EOF

$iam is used to check your current git repo DEVELOPMENT branch in your local
clone against changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you appear to be on branch "${opt_branch}", the branch you want to
sync with. I'm exiting. Get off the branch "${opt_branch}" and onto another
branch Then rerun the command. Or just do a 'git pull' if you really need to
refresh this branch.

EOF
        return $NOT_OK
    fi

    ## Check the local branch against its origin
    stcheck=$(mktemp --suffix=.git-check-with-remote.1)
    git status 1>$stcheck 2>&1
    grep "Your branch is up-to-date with 'origin/$cb'." $stcheck 1>/dev/null
    status=$?
    if [ "$status" != '0' ]
    then
        cat $stcheck
        cat <<EOF
Your branch should be up to date with its origin in order to simplify the
check.
EOF
        if ((opt_bail_on_dirty))
        then
            echo Exiting.
            return $NOT_OK
        else
            local resp=$(func-yesno "Do you want to continue anyway" n)
            if [ "$resp" == 'n' ]
            then
                return $NOT_OK
            fi
        fi
    fi

    local ok_to_pull=1
    ((opt_confirm)) && ok_to_pull=0

    ## Now grab the remote branch
    local gflog=$(mktemp --suffix=.git-check-with-remote.2)
    git fetch ${opt_remote} ${opt_branch} 2>$gflog
    local rc=$?
    if ((rc))
    then
        cat $gflog
        rm $gflog
        return $NOT_OK
    fi
    rm $gflog

    ## Log the local branch
    local locallog=$(mktemp --suffix=.git-check-with-remote.locallog)
    git log > $locallog

    ## Log the local copy of the remote branch
    local remotelog=$(mktemp --suffix=.git-check-with-remote.remotelog)
    git log ${opt_remote}/${opt_branch} > $remotelog

    ## Diff 'em
    local difflog=$(mktemp --suffix=.git-check-with-remote.difflog)
    diff $locallog $remotelog 1> $difflog 2>&1

    if [ -s $difflog ]
    then
        if [ "$(cat $difflog | wc -l)" = '10' ] \
               && [ ! "$(grep -E "Merge pull request.*$(git-get-current-branch)" $difflog)" = '' ]
        then
            echo "Only diff to ${opt_remote} is merge pull request."
        else
            echo
            echo "*** git repo: $(pwd)"
            echo "*** Current branch $(git-get-current-branch) and ${opt_remote}/${opt_branch} are not synced:"
            echo
            cat $difflog
        fi
    fi

    rm -f $locallog $remotelog $difflog
    return $OK
}
safe_func_export git-check-with-remote

git-check-with-master ()
{
    ##@@ none||none||git-check-with-master||

    git-parse-remote-v
    ## clone-and-fork repos need to check with the master in the canonical
    ## upstream branch.  If there is no 'upstream', then it's probably a clone
    ## only, so check against the master in origin.
    if [ -n "${gitfuncs_remotes[upstream]}" ]
    then
        git-check-with-remote --remote upstream --branch master "$@"
    elif [ -n "${gitfuncs_remotes[origin]}" ]
    then
        git-check-with-remote --remote origin --branch master "$@"
    fi
    return $?
}
safe_func_export git-check-with-master

git-sync-with-remote-usage ()
{
    echo "Usage: $1 --branch otherBranch [--remote remote] [--confirm]"
    echo "       remoteRepoTag defaults to 'origin'"
}
safe_func_export git-sync-with-remote-usage

git-sync-with-remote ()
{
    ##@@ none||none||git-sync-with-remote||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local iam=$(func-name-spoof)

    local opt_branch=''
    local opt_remote='origin'
    local opt_confirm='0'
    local opt_stash='0'
    local do_stash='0'

    local OPTSARGS=$(getoptp -o hb:r:c --long help,branch:,remote:,confirm -n $iam -- "$@")
    status=$?
    ((status != 0)) && $usage_func && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--stash) opt_stash=1; shift;;
            -c|--confirm) opt_confirm=1; shift;;
            -r|--remote) opt_remote="$2"; shift; shift ;;
            -b|--branch) opt_branch="$2"; shift; shift ;;
            -h|--help) $usage_func $iam; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) func-echo "Internal error!"; $usage-func $iam; return $NOT_OK ;;
        esac
    done

    if [ -z "$opt_branch" ]
    then
        func-echo "--branch required"
        $usage-func $iam
        return $NOT_OK
    fi

    local cb=$(git rev-parse --abbrev-ref HEAD)
    status=$?
    ((status != 0 )) && return $NOT_OK

    if [ "$cb" == '' ]
    then
        func-echo
        cat <<EOF

$iam is used to keep your current git repo DEVELOPMENT branch in your local
clone in sync with changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you do not appear to even be in a repo. I'm exiting. Try again in a
proper repo.

EOF
        return $NOT_OK
    fi

    if [ "$cb" == "$opt_branch" ]
    then
        func-echo
        cat <<EOF

$iam is used to keep your current git repo DEVELOPMENT branch in your local
clone in sync with changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you appear to be on branch "${opt_branch}",
the branch you want to sync with. I'm exiting. Get off this branch and onto
another branch. Then rerun the command. Or just do a 'git status' to check this
branch or a 'git pull' if you really need to refresh this branch.

EOF
        return $NOT_OK
    fi

    ## Stash any modified items before checking and proceeding.
    local needs_stash=$(echo $(git-is-staged && git-is-unstaged) | wc -w)
    if ((needs_stash))
    then
        if ((opt_stash))
        then
            do_stash=1
        else
            git status
            local resp=$(func-yesno "Stash" n)
            if [ "$resp" = 'n' ]
            then
                func-echo "Will not proceed without a stash"
                return $NOT_OK
            else
                do_stash=1
            fi
        fi
    else
        if ((opt_stash))
        then
            func-echo "stash not needed"
        fi
    fi
    if ((do_stash))
    then
        git stash
        status=$?
        if [ "$status" = '0' ]
        then
            ok_to_pop=1
        else
            return $status
        fi
    fi

    ## Grab head of log
    local oldsha=$(git-log-grab-sha -1)
    func-echo --head 'Log before pull:'
    git-log-shas-range $oldsha $oldsha

    ## Check the local branch against its origin
    stcheck=$(mktemp --suffix=.git-sync-with-remote)
    git status 1>$stcheck 2>&1
    grep "Your branch is up-to-date with 'origin/$cb'." $stcheck 1>/dev/null
    status=$?
    if [ "$status" != '0' ]
    then
        func-echo
        cat $stcheck
        cat <<EOF
Your branch should be up to date with its origin in order to simplify the
rebase.
EOF
        local resp=$(func-yesno "Do you want to continue anyway" n)
        if [ "$resp" == 'n' ]
        then
            if ((do_stash))
            then
                func-echo 'Stash pop...'
                git stash pop
            fi
            return $OK
        fi
    fi

    local ok_to_pull=1
    ((opt_confirm)) && ok_to_pull=0

    func-echo 'Fetching to check...'
    git fetch ${opt_remote} ${opt_branch}

    local diffoutput=$(mktemp --suffix=.gf-syr)
    git diff ...${opt_remote} > $diffoutput 2>&1
    local diffc=$(cat $diffoutput | wc -l)
    if ((diffc)) && ((opt_confirm))
    then
        func-echo --head "===== diffs ====="
        cat $diffoutput
        \rm $diffoutput
    fi

    local logoutput=$(mktemp --suffix=.gf-syr)
    git log ...${opt_remote} > $logoutput 2>&1
    local logc=$(cat $logoutput | wc -l)
    if ((logc)) && ((opt_confirm))
    then
        ((diffc)) && echo
        func-echo "=====  log  ====="
        cat $logoutput
        \rm $logoutput
    fi

    if ((diffc)) || ((logc))
    then
        if ((opt_confirm))
        then
            local resp=$(func-yesno "Ok to pull" n)
            if [ "$resp" == 'n' ]
            then
                if ((do_stash))
                then
                    func-echo 'Stash pop...'
                    git stash pop
                    return $OK
                fi
            fi
        fi
    else
        func-echo "No difference with remote."
        if ((do_stash))
        then
            func-echo 'Stash pop...'
            git stash pop
        fi
        return $OK
    fi

    func-echo 'Pulling to sync...'
    git pull --rebase ${opt_remote} ${opt_branch}
    status=$?
    if [ ! "$status" = '0' ]
    then
        func-echo
        cat <<EOF

It appears the pull --rebase was not successful. Assuming the issue was not a
system issue, but rather related to conflicts:

1) Edit each file in conflict, looking for the (partial) conflict marker
   "<<<<<". Once you see the issue, fix the code and save the file.

2) "git add" any files you've changed.

Once any conflicts are resolved, do a "git status". You will see files under
the section "Changes to be committed" if:

1) You fixed any conflicts.

2) There are changes in the branch "${opt_branch}" that need to be added in
   that have no conflicts.

If you see any such files, run "git commit". That will complete the merge into
your branch.

Then push the branch up to your fork so you can submit a pull request.

EOF
        if ((do_stash))
        then
            func-echo "Leaving stash stashed so a not to further complicate the issue"
        fi
        return $NOT_OK
    fi

    ## Grab head of log
    local newsha=$(git-log-grab-sha -1)

    ## Show log
    func-echo --head 'Log after pull:'
    git-log-shas-range $oldsha $newsha

    func-echo --head "pull --rebase successful. Pushing..."
    git push
    status=$?
    if [ "$status" != '0' ]
    then
        resp=$(func-yesno "'git push' complained. Shall I re-push with --force" n)
        if [ "$resp" = 'y' ]
        then
            git push --force
            status=$?
        fi
    fi

    local ask_pop=0
    if [ ! "$status" = '0' ]
    then
        func-echo
        cat <<EOF
It appears that the git push was not successful and you declined to use --force,
or the --force was also unsuccessful.
EOF
        if ((do_stash))
        then
            func-echo
            cat <<EOF
It may be that you decided not to force the push since you still have work to do,
in which case you will want to pop the latest stash.
EOF
            ask_pop=1
        fi
    fi

    if ((do_stash))
    then
        resp='y'
        if ((ask_pop))
        then
            resp=$(func-yesno "Shall I pop the last git stash" n)
        fi
        if [ "$resp" = 'y' ]
        then
            func-echo 'Stash pop...'
            git stash pop
            status=$?
            if ((status != 0))
            then
                func-echo
                cat <<EOF
It appears that the stash pop failed. There may be conflicts. Once you fix the
conflictsmay be that you decided not to force the push since you still have
work to do,in which case you will want to pop the latest stash.
EOF
                return $?
            fi
        fi
    fi

}
safe_func_export git-sync-with-remote

git-sync-with-master ()
{
    ##@@ none||none||git-sync-with-master||
    gitfuncs_audit "$@"

    local status

    git-parse-remote-v
    ## clone-and-fork repos need to sync with the master in the canonical
    ## upstream branch.  If there is no 'upstream', then it's probably a clone
    ## only, so sync against the master in origin.
    if [ -n "${gitfuncs_remotes[upstream]}" ]
    then
        git-sync-with-remote --remote upstream --branch master "$@"
    elif [ -n "${gitfuncs_remotes[origin]}" ]
    then
        git-sync-with-remote --remote origin --branch master "$@"
    fi
    status=$?

    return $status
}
safe_func_export git-sync-with-master

git-update ()
{
    git-sync-with-master "$@"
}
safe_func_export git-update

git-rebase-on-master ()
{
    git-sync-with-master "$@"
}
safe_func_export git-rebase-on-master

git-diff-faq ()
{
    ##@@ none||none||git-diff-faq||
    gitfuncs_audit "$@"

    cat <<EOF

--- Branch diffing

The trick to diffing two branches is that is must be done locally. Make sure
both branches have been pulled down from their remotes before tyring to use
them in a diff.

diff two branches:
    git diff branch1 branch2

diff current branch vs other branch:
    git diff other

    *Note - the sense of the diff is from the other back to the current, as if
            you typed 'git diff other current' . If you want the diff from
            current to other then use 'git diff current other'

diff specific files between two branches:
    git diff branch1 branch2 -- file [file...]

EOF
}
safe_func_export git-diff-faq

git-clone-usage ()
{
    local cmd=$1;shift
    local protocol=$1
    local protocolarg
    local protocolurl
    if [ -z "$protocol" ]
    then
        protocolarg='<PROTOCOLe>'
        protocolurl='<PROTOCOL_URLe>'
    else
        protocolarg=''
        protocolurl=$(kvget gitfuncs_gitsvcs $1)
    fi

    cat <<EOUSAGE
Usage: $cmd $protocolarg [-y] [-t] [--triangle=upstream-namespace] namespace repo
       $cmd $protocolarg [-y] [-t] [--triangle=upstream-namespace] namespace/repo

       o Clones ${protocolurl}namespace/repo to a directory path
               $gitfuncs_gitroot/$protocol/namespace/repo.
         Directory $gitfuncs_gitroot/$protocol must already exist.

       o Sets up a wt subdir for worksapces.

       -y
          Answer yes to any prompts. Useful for automation.

       -t
          Resets the timestamps on the files to their commit times.

       --triangle=upstream-namespace
          Use this if namespace/repo fork of upstream-namespace/repo
          and you want to setup the triangle workflow
          so that master pulls on this clone are from upstream-namespace/repo.
          *Note* - Only specify the upstream namespace. We require that
                   the two repo names match. This keeps things organized.
EOUSAGE
    return $OK
}
safe_func_export git-clone-usage

git-clone ()
{
    ##@@ none||none||git-clone||Clone a repo locally. Args: protocol namespace repo
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    local opt_y=0
    local opt_t=0
    local opt_triangle_namespace=''
    OPTSARGS=$(getoptp -o tyh --long timestamp,yes,help,triangle: -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func ${FUNCNAME} && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -y|--yes) opt_y=1; shift ;;
            -t|--timestamp) opt_t=1; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --triangle) local tmp_otn;
                        tmp_otn=$2;
                        shift; shift;
                        opt_triangle_namespace=${tmp_otn%/*}
                        if [ ! "$tmp_otn" = "$opt_triangle_namespace" ]
                        then
                            func-echo    "WARNING: --triangle takes an upstream namespace specification,"
                            func-echo -c"         not a full upstream repo specification."
                            func-echo -c "         We will use"
                            func-echo -c "             $opt_triangle_namespace"
                            func-echo -c "         not"
                            func-echo -c "             $tmp_otn"
                        fi
                        ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) func-echo "Internal error!"; $usage_func ${FUNCNAME}; return $NOT_OK ;;
        esac
    done

    [ -z "$1" ] && $usage_func ${FUNCNAME} && return $NOT_OK

    local protocol=$1;shift
    local namespace=$1;shift
    local repo2
    if [[ "$namespace" == */* ]]
    then
        asplit tmpa / $namespace
        namespace=${tmpa[0]}
        repo=${tmpa[1]}
    else
        repo=$1;shift
    fi

    local cwpath=$(realpath $(pwd))
    local local_protocol=$(basename $cwpath)
    if [ "$local_protocol" != "$protocol" ]
    then
        func-echo    "You must be in a local directory path ending in"
        func-echo -c "   $protocol"
        func-echo -c "You are in $cwpath"
        local shouldbein="$gitfuncs_gitroot/$protocol"
        if [ ! -d $shouldbein ]
        then
            func-echo    "Cannot find '$shouldbein'."
            func-echo -c "Correct and re-execute."
            return $NOT_OK
        else
            local resp
            if ((opt_y))
            then
                func-echo "Going to $shouldbein"
                resp='y'
            else
                resp=$(func-yesno "cd to $shouldbein")
            fi
            if [ "$resp" = 'n' ]
            then
                func-echo "Correct and re-execute."
                return $NOT_OK
            else
                _git_cd_to $shouldbein
            fi
        fi
    fi

    local protocol_url=$(kvget gitfuncs_gitsvcs $protocol)
    if [ -z "$protocol_url" ]
    then
        func-echo "$protocol is unknown. Valid protocols are:$(kvgetvalues gitfuncs_gitsvcs)"
        return $NOT_OK
    fi

    local tgt="$namespace/$repo"
    if [ -e $tgt ]
    then
        local resp
        if ((opt_y))
        then
            resp='y'
        else
            resp=$(func-yesno "'$tgt' exists. Will not clone over it. Remove it" n)
        fi
        [ "$resp" = 'n' ] && return $NOT_OK
        rm -rf $tgt
    fi

    local cmd="git clone ${protocol_url}$namespace/$repo $namespace/$repo"
    func-echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status
    if ((opt_t))
    then
        func-echo 'Setting timestamps...'
        (builtin cd $namespace/$repo; git-retimestamp)
        func-echo 'Done'
    fi

    ## dirlist, not builtin cd, to take advantage this cd enhancement
    dirlist $namespace/$repo
    if [ -n "$opt_triangle_namespace" ]
    then
        echo "Setting up triangle workflow with ${protocol_url}$opt_triangle_namespace/${repo}..."
        git-set-triangle ${protocol} $opt_triangle_namespace $namespace $repo
        git pull # To refresh from the upstream
    fi
    git remote -v

    echo "Setting up for worktrees..."
    mkdir wt
    ls -ld $(pwd)/wt

    ## Add this repo to the list
    git-go-set
}
safe_func_export git-clone

git-delete-repo-usage ()
{
    local cmd=$1;shift
    local protocol=$1
    local protocolarg=$1
    if [ -z "$protocol" ]
    then
        protocol='protocol'
        protocolarg='protocol'
    else
        protocolarg=''
    fi

    cat <<EOUSAGE
Usage: $cmd $protocolarg namespace repo
       Whacks local repo $gitfuncs_gitroot/$protocol/namespace/repo.
       Asks about corresponding remote.
EOUSAGE
    return $OK
}
safe_func_export git-delete-repo-usage

git-delete-repo ()
{
    ##@@ none||none||git-delete-repo||protocol namespace repo
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"

    [ -z "$1" ] && $usage_func ${FUNCNAME} && return $NOT_OK
    local protocol=$1;shift
    local namespace=$1;shift
    local repo=$1;shift
    local returnpath=$(realpath $(pwd))

    local protocol_url=$(kvget gitfuncs_gitsvcs $protocol)
    if [ -z "$protocol_url" ]
    then
        echo "$protocol is unknown. Valid protocols are:$(kvgetvalues gitfuncs_gitsvcs)"
        return $NOT_OK
    fi

    ## Go to what we want to whack, to make sure it's there.
    gitgo $protocol/$namespace/$repo
    status=$?
    ((status != 0)) && return $NOT_OK; ## If the gitgo fails, we should see
                                       ## error messages, no need to add more.

    local repopath=$(realpath $(pwd))

    (
        ## Subshell to allow cding around to be handled gracefully at the end

        ## Make sure it's clean
        if [ -d wt ] && [ "$(ls wt | wc -l)" != '0' ]
        then
            echo "worktrees found:"
            ls -la wt
            echo
            echo "Will not delete repo"
            return $NOT_OK
        fi

        dirty=$(git status --porcelain)
        if [ -n "$dirty" ]
        then
            git status
            echo
            echo "Will not delete current repo"
            return $NOT_OK
        fi

        builtin cd ..
        \rm -rf $repo
        status=$?
        ((status != 0)) && return $NOT_OK; ## If the rm fails, we should see
                                           ## error messages, no need to add
                                           ## more.

        echo "Done. Not touching remote repo."

        ## Remove the just-deleted repo from the list of local git repos.
        git-go-set

        return $OK
    )

    status=$?
    if [ -d $returnpath ]
    then
        builtin cd $returnpath
    else
        builtin cd
    fi

    return $status
}
safe_func_export git-delete-repo

git-what-is-staged ()
{
    ##@@ none||none||git-what-is-staged||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered, staged for commit'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --staged
    fi
}
safe_func_export git-what-is-staged

git-is-staged ()
{
    git-what-is-staged "$@"
}
safe_func_export git-is-staged

git-what-is-committable ()
{
    git-what-is-staged "$@"
}
safe_func_export git-what-is-committable

git-is-committable ()
{
    git-what-is-staged "$@"
}
safe_func_export git-is-committable

git-what-is-unstaged ()
{
    ##@@ none||none||git-what-is-unstaged||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered, not staged for commit'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --unstaged
    fi
}
safe_func_export git-what-is-unstaged

git-is-unstaged ()
{
    git-what-is-unstaged "$@"
}
safe_func_export git-is-unstaged

git-what-is-untracked ()
{
    ##@@ none||none||git-what-is-untracked||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files not tracked in the repo'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --untracked
    fi
}
safe_func_export git-what-is-untracked

git-is-untracked ()
{
    git-what-is-untracked "$@"
}
safe_func_export git-is-untracked

git-what-is-modified ()
{
    ##@@ none||none||git-what-is-modified||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered: staged and unstaged'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --staged --unstaged
    fi
}
safe_func_export git-what-is-modified

git-is-modified ()
{
    git-what-is-modified "$@"
}
safe_func_export git-is-modified

git-is-mod ()
{
    git-what-is-modified "$@"
}
safe_func_export git-is-mod

git-what-is-modified-only ()
{
    ##@@ none||none||git-what-is-modified-only||git-what-is-modified sans what is deleted
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered: staged, unstaged, without deleted files'
    else
        local deleted=$(ajoin '|' $(git-what-is-deleted))
        local modified
        for mod in $(git-what-is-modified)
        do
            echo $mod | grep -v -E "$deleted";
        done
    fi
}
safe_func_export git-what-is-modified-only

git-what-is-edited ()
{
    ##@@ none||none||git-what-is-edited||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered: staged, unstaged and untracked'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --all-mod
    fi
}
safe_func_export git-what-is-edited

git-is-edited ()
{
    git-what-is-edited "$@"
}
safe_func_export git-is-edited

git-what-is-unmodified ()
{
    ##@@ none||none||git-what-is-unmodified||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files unaltered, but tracked'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --unmodified
    fi
}
safe_func_export git-what-is-unmodified

git-is-unmodified ()
{
    git-what-is-unmodified "$@"
}
safe_func_export git-is-unmodified

git-what-is-deleted ()
{
    ##@@ none||none||git-what-is-deleted||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files deleted, both staged and not staged for commit'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --deleted
    fi
}
safe_func_export git-what-is-deleted

git-is-deleted ()
{
    git-what-is-deleted "$@"
}
safe_func_export git-is-deleted

git-what-is-ignored ()
{
    ##@@ none||none||git-what-is-ignored||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files ignored'
    else
        $DEBUG_GIT_STATUS_PARSE $(which git-status-parse) --ignored
    fi
}
safe_func_export git-what-is-ignored

git-is-ignored ()
{
    git-what-is-ignored "$@"
}
safe_func_export git-is-ignored

git-track-remote-branch ()
{
    ##@@ none||none||git-track-remote-branch||
    gitfuncs_audit "$@"

    local remote=$1
    local branch=$2
    if [ -z "$remote" ] || [ -z "$branch" ]
    then
        echo "Usage: git-track-remote-branch remote branch"
        echo "       Missing one or both arguments"
        return $NOT_OK
    fi
    git fetch $remote || return $?
    git checkout -b $branch --track $remote/$branch
    return $?
}
safe_func_export git-track-remote-branch

git-fetch-remote-branch ()
{
    git-track-remote-branch "$@"
}
safe_func_export git-fetch-remote-branch

## Useful in prompts (PS1).
git-inside-worktree ()
{
    ##@@ none||none||git-inside-worktree||Return $TRUE or $FALSE, prints 'true' or 'false' if -p specified
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift

    local print=$1;shift
    local v=$(git rev-parse --is-inside-worktree 2>/dev/null)
    local r=$FALSE
    [ "$v" = "true" ] && r=$TRUE
    [ "$print" = '-p' ] && echo $v
    return $r
}
safe_func_export git-inside-worktree

git-get-stash-count ()
{
    ##@@ none||none||git-get-stash-count||
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift
    local no0=0; [ "$1" = '-no0' ] && no0=1 && shift;
    local pre=$1;shift
    local post=$1;shift
    git-inside-worktree $na
    if [ "$?" = $TRUE ]
    then
        local c=$(git stash list 2>/dev/null | wc -l)
        ((c==0)) && ((no0)) && return
        echo "${pre}${c}${post}"
    fi
}
safe_func_export git-get-stash-count

git-stash-get-count ()
{
    git-get-stash-count "$@"
}
safe_func_export git-stash-get-count

git-worktree-create-usage ()
{
    echo "Usage: git-worktree-create [-m 'message'] [-f] [-d] [--asmaster somebranch] branch [remote]"
    echo "       default remote is 'origin'"
    echo "       -m|--message - Record a short description readable with git-st-ext."
    echo "       -f|--fetch   - Do not create the branch, but fetch existing."
    echo "       -d|--dated   - Append '_YYYY-MM-DD' to the branch name."
    echo "       --asmaster   - use 'somebranch' as the worktree basis."
    echo "                      The default is 'master'."
}
safe_func_export git-worktree-create-usage

git-worktree-fetch ()
{
    gitfuncs_audit "$@"

    git-worktree-create --fetch "$@"
    return $?
}
safe_func_export git-worktree-fetch

git-worktree-create ()
{
    ##@@ none||none||git-worktree-create||
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"

    ## Make sure pwd ends in wt
    if [[ ! "$(pwd)" =~ /wt$ ]]
    then
        if [ -d ./wt ]
        then
            builtin cd ./wt
        else
            func-echo    "Current directory is $(pwd)."
            func-echo -c 'No wt subdir.'
            func-echo -c 'Will not manipulate worktrees outside of wt dir. Aborting.'
            return $NOT_OK
        fi
    fi

    local verbose=1
    local fetch_existing=0
    local fetch_opt=''
    local status=0
    local opt_m=''
    local message=''
    local dated=''
    local asmaster='master'
    OPTSARGS=$(getoptp -o m:fd --long message:,fetch,dated,asmaster: -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -d|--dated) dated="_$(date +%Y-%m-%d)"; shift;;
            -f|--fetch) fetch_existing=1; fetch_opt="-r"; shift ;;
            -m|--message) opt_m=$1; message="$2"; shift ; shift ;;
            --asmaster) asmaster=$2; shift ; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Error getting options!"; $usage_func; return $NOT_OK ;;
        esac
    done

    if [ -z "$1" ]
    then
        func-echo 'Need a branch name to use for the worktree spec.'
        $usage_func
        return $NOT_OK
    fi
    local wt="$1${dated}"
    shift

    local remote
    if [ -n "$1" ]
    then
        [ -n "$remote" ] && shift
    fi
    [ -z "$remote" ] && remote=origin
    func-echo "Using '$remote' as remote."

    ((verbose)) && func-echo 'Check for existing worktrees with same name.'
    wtdir="$(pwd)/$wt"
    if [ -e $wtdir ]
    then
        func-echo "$wtdir already exists. Aborting."
        return $NOT_OK
    fi

    local wtsubdir=$wt
    local wtbranch=$wt

    ## TODO: Allow for suffix to append to worktree name so you can dup them if
    ## you need to.
    ((verbose)) && func-echo 'Check for existing branch.'
    local create_branch="-b"
    local exists=$(git-branch-list --strip $fetch_opt | grep $wt)
    if [ -n "$exists" ]
    then
        func-echo "Branch $wt already exists. Using it."
        create_branch=''
        wtbranch="$exists"
    elif [ "$fetch_existing" = '1' ]
    then
        func-echo "Branch $wt does not exist to be fetched."
        return $NOT_OK
    else
        ## Since this worktree is going to create a branch of the local
        ## $asmaster, make sure the local $asmaster (where we should be right
        ## now) it is up to date.
        if [ "$(git-get-current-branch)" != $asmaster ]
        then
            func-echo "Cannot create branch and worktree because the current branch '$(git-get-current-branch)' is not the master branch '$asmaster'."
            return $NOT_OK
        fi
        func-echo "Checking local '$asmaster', starting point for branch."
        git pull
        status=$?
        ((status)) && return $NOT_OK ## assuming the error message will be
                                     ## printed to stderr...
    fi

    ## Now create the work tree and create/fetch the branch.
    ((verbose)) && func-echo "git worktree add $create_branch $wtsubdir $wtbranch"
    git worktree add $create_branch "$wtsubdir" "$wtbranch"
    status=$?
    if ((status))
    then
        func-echo "Aborting."
        return $NOT_OK
    fi

    ((verbose)) && func-echo "cd $wtsubdir"
    ## dirlist, not builtin cd, to take advantage this cd enhancement
    dirlist $wtsubdir

    if [ -n "$create_branch" ]
    then
        ((verbose)) && func-echo "git push --set-upstream $remote $wtbranch"
        git push --set-upstream $remote $wtbranch
        git-branch-info created "$(date +%Y%m%d.%H%M%S%z)"
    else
        ## Not convinced this is the optimal set of actions. Probably better to
        ## modify or replace the add command.
        git branch --track $wtsubdir $wtbranch
        git checkout $wtsubdir
     fi

    ## Convert the worktree's .git file to use a relative path to the master
    ## .git location. In that way, we can use the repo on machines where it may
    ## be mounted in a different place, so that the absolute path is different
    ## in those places.
    sed -i 's|\(gitdir: \).*/\(.git/worktrees\)|\1../../\2|' .git

    git-post-new

    if [ -n "$opt_m" ]
    then
        git-st-ext "$message"
    fi

    ## Add this repo to the list
    git-go-set

    return $OK
}
safe_func_export git-worktree-create

git-create-worktree ()
{
    git-worktree-create "$@"
}
safe_func_export git-create-worktree

git-worktree ()
{
    git-worktree-create "$@"
}
safe_func_export git-worktree

git-wt ()
{
    git-worktree-create "$@"
}
safe_func_export git-wt

gitwt ()
{
    git-worktree-create "$@"
}
safe_func_export gitwt

git-delete-current-worktree ()
{
    gitfuncs_audit "$@"

    git-delete-worktree "$@" $(pwd)
    status=$?
    return $status
}
safe_func_export git-delete-current-worktree

git-delete-worktree-usage ()
{
    echo "Usage: $1 [--force] [--yes] [--schedule hours] worktree"
}
safe_func_export git-delete-worktree-usage

git-delete-worktree ()
{
    ##@@ none||none||git-delete-worktree||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local iam=$(func-name-spoof)

    local opt_yes=0
    local opt_yes_string
    local opt_force=0
    local opt_schedule=0
    OPTSARGS=$(getoptp -o yfs:h --long yes,force,schedule:,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func $iam && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -y|--yes) opt_yes=1; opt_yes_string='--yes'; shift ;;
            -f|--force) opt_force=1; shift ;;
            -s|--schedule) ((opt_schedule = $(date +%s) + $2*60*60))
                           shift; shift ;;
            -h|--help) $usage_func $iam; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func $iam; return $NOT_OK ;;
        esac
    done

    func-echo --head 'Working...'
    local opwd=$(pwd)
    local worktree=$1;
    local worktreefull=$(realpath $1);

    builtin cd $worktreefull

    ##@@ none||none||git-delete-current-worktree||
    ## Make sure we are in a proper worktree.
    if [ ! -f .git ] || [[ ! "$(pwd)" =~ /wt/ ]]
    then
        func-echo "$worktree is not a proper worktree for deletion"
        return $NOT_OK
    fi

    if ((opt_schedule))
    then
        git-branch-info delete-worktree $opt_schedule
        func-echo "$worktree scheduled for removal on or after $( date --date=@$opt_schedule)"
        return 0
    fi

    ## Check for cleanliness.
    if [ "$(git status --porcelain | wc -l)" != '0' ] || \
           [ "$(git status | grep 'Your branch is' | grep -v 'up-to-date' | wc -l)" != '0' ]
    then
        if((!opt_force))
        then
            git status
            echo
            func-echo "Will not delete current worktree. Clean worktree or re-run command with --force."
            return $NOT_OK
        fi
    fi

    ## Current branch
    local current_branch=$(git-get-current-branch)

    ## Checking cleanliness and consistency
    local current_dir=$(basename $(pwd))
    if [ "$current_branch" != "$current_dir" ]
    then
        func-echo    "Branch name '$current_branch' does not match current subdir name '$current_dir'."
        func-echo -c "I'm bailing; you fix this mess."
        return $NOT_OK
    fi
    git status
    local rc=$?
    if ((rc))
    then
        func-echo    "git status returned non-success value $rc."
        func-echo -c "I'm bailing; you fix this mess."
        return $NOT_OK
    fi

    ## Check for being merged
    local gmfout=$(git-merge-find)
    local status=$?
    if ((status)) && ((!opt_force)) && ((!opt_yes))
    then
        echo $gmfout
        local resp=$(func-yesno 'Continue anyway')
        if [ "$resp" = 'n' ]
        then
            return $NOT_OK
        fi
    fi

    ## Whack it. Start with the current dir.
    local delit=$(basename $(pwd))
    builtin cd ..
    \rm -rf $delit; (( $? != 0 )) && func-echo "Bad rm of ./$delit (from $(pwd)). Aborting." && return $NOT_OK;

    ## Work our way up to the first non empty dir or the 'wt' dir, whichever we
    ## get to first, and stop deleting.
    while [ "$(basename $(pwd))" != 'wt' ]
    do
        if [ -z "$(ls -A $(pwd))" ]
        then
            #it's empty
            delit=$(basename $(pwd))
            builtin cd ..
            \rm -rf $delit; (( $? != 0 )) && func-echo "Bad rm of ./$delit (from $(pwd)). Aborting." && return $NOT_OK;
        fi
    done

    func-echo 'Local repo deleted.'
    ## Now fix the administrative files.
    git worktree prune
    func-echo 'Local admin files updated.'

    ## Now the take care of the branch.
    if ((opt_yes))
    then
        resp='d'
    else
        resp=$(func-pick "Keep, delete associated branch $current_branch" 'k/d' '' )
    fi
    if [ "$resp" = 'k' ]
    then
        func-echo "If you change your mind: git-delete-branch $current_branch"
    else
        ## Have to be in a git repo to do this.
        while [ "$(basename $(pwd))" != 'wt' ]
        do
            builtin cd ..
        done
        builtin cd ..
        if [ "$resp" = 'd' ]
        then
            git-delete-branch $opt_yes_string $current_branch
        fi
    fi

    [ -d $opwd ] && builtin cd ## If $opwd was the worktree directory, it won't
                               ## be there anymore. Stay where we are.

    git-go-set

    return $OK
}
safe_func_export git-delete-worktree

git-worktree-delete-current ()
{
    git-delete-current-worktree "$@"
}
safe_func_export git-worktree-delete-current

git-worktree-root ()
{
    ##@@ none||none||git-worktree-root||print the master root where the wt dir is
    gitfuncs_audit "$@"

    local wtr=$(git worktree list)
    local status=$?; ((status)) && return $status
    echo $wtr | sed 's/ .*//'
    return $OK
}
safe_func_export git-worktree-root

git-run-precommit-hook ()
{
    ##@@ none||none||git-run-precommit-hook||
    gitfuncs_audit "$@"

    local wtr=$(git-worktree-root)
    status=$?; ((status)) && return $status
    local hook="$wtr/.git/hooks/pre-commit"
    if [ -x $hook ]
    then
        $hook "$@"
        return $?
    elif [ -r $hook ]
    then
        echo "Cannot execute $hook"
        return $NOT_OK
    else
        echo "Cannot find $hook"
        return $NOT_OK
    fi
}
safe_func_export git-run-precommit-hook

git-worktree-diff-to-root ()
{
    ##@@ none||none||git-worktree-diff-to-root||diff worktree file against root file
    gitfuncs_audit "$@"

    local in_a_wt=$(git-inside-worktree)
    if (( in_a_wt == 1 ))
    then
        func-echo "Must be in a wt"
        return $NOT_OK;
    fi

    local files="$@"
    if [ -z "$files" ]
    then
        files=$(git ls-files)
        if [ -z "$files" ]
        then
            func-echo "No git files found. Is current dir '$(pwd)' a git repo?"
            return $NOT_OK;
        fi
    fi

    local root=$(pwd);
    root=${root%%/wt*}
    local coloropt='always'
    is-redirected $STDOUT && coloropt=never
    for i in $files
    do
        if [ "$1" = '--reverse' ]
        then
            git --no-pager diff --no-index --color=$coloropt ${root}/$i $i 2>&1
        else
            git --no-pager diff --no-index --color=$coloropt $i ${root}/$i 2>&1
        fi
    done | less -RE
}
safe_func_export git-worktree-diff-to-root

git-worktree-diff-from-root ()
{
    ##@@ none||none||git-worktree-diff-rom-root||diff root file against worktree file
    gitfuncs_audit "$@"

    git-worktree-diff-to-root --reverse "$@"
    return $?
}
safe_func_export git-worktree-diff-from-root

git-add-remote-usage ()
{
    local cmd=$1;shift
    local protocol=$1
    local protocolarg=$1
    if [ -z "$protocol" ]
    then
        protocol='{protocolurl}'
        protocolarg='protocol'
    else
        protocolarg=''
    fi

    cat <<EOUSAGE
Usage: $cmd $protocolarg namespace
       Adds ${protocol}:namespace/current_repo as a remote named 'namespace'
       to the current repo. Use this to get at people's branches on
       their repo fork.
EOUSAGE
}
safe_func_export git-add-remote-usage

git-add-remote ()
{
    ##@@ none||none||git-add-remote||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    if [ "$#" != '2' ]
    then
        $usage_func ${FUNCNAME}; return $NOT_OK
    fi
    local protocol=$1; shift
    local remote=$1; shift
    current_repo=$(git-get-current-repo-name)
    git remote add $remote $protocol:$remote/$current_repo
    local $status=$?
    if (( $status == 0 ))
    then
        git remote -v | grep $remote
    fi
    return $status
}
safe_func_export git-add-remote

git-remote-add ()
{
    git_add_remote "$@"
}
safe_func_export git-remote-add

git-remotes ()
{
    git remote -v "$@"
}
safe_func_export git-remotes

git-get-default-remote ()
{
    ##@@ none||none||git-get-default-remote||
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift

    local pre=$1;shift
    local post=$1;shift
    git-inside-worktree $na
    if [ "$?" = $TRUE ]
    then
        local push_def=$(git config --global push.default 2>/dev/null)
        if [ "$push_def" = 'simple' ]
        then
            local out=$(git config --get remote.$(git config --get branch.$(git-get-current-branch).remote 2>/dev/null).url 2>/dev/null)
            echo "${pre}${out}${post}"
        fi
    fi
}
safe_func_export git-get-default-remote

git-status ()
{
    ##@@ none||none||git-status||
    gitfuncs_audit "$@"

    git-root || return $NOT_OK
    (
        echo
        func-echo "=== Latest log entry:"
        git log -1
        echo
        func-echo "=== Status:"
        local tmpf=$(mktemp --suffix=.git-status)

        git-st-ext
        git-st-cl --noless --cdok "$@" | grep -v "No files specified"
    ) | less -RE
}
safe_func_export git-status

git-st ()
{
    git-status "$@"
}
safe_func_export git-st

git-get-current-repo-name ()
{
    ##@@ none||none||git-get-current-repo-name||
    gitfuncs_audit "$@"

    git remote -v | grep origin | sed 's|.*/||' | sed 's/ .*//' | sort -u
}
safe_func_export git-get-current-repo-name

git-branch-list ()
{
    ##@@ none||none||git-branch-list||
    gitfuncs_audit "$@"

    local strip=0
    local remote=''
    local OPTSARGS=$(getoptp -o ra --long strip,nostrip,remote,all -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && func-echo "Exiting." && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -a | --all) remote='-a'; shift;;
            -r | --remote) remote='-r'; shift;;
            --strip) strip=1; shift;;
            --nostrip) strip=0; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; return $NOT_OK ;;
        esac
    done

    ## Update the local branches with remote
    git remote update

    local opts="--list $remote"
    if ((strip))
    then
        git branch --no-color $opts | sed 's/^[ *] //' | sed 's/ .*//'
    else
        git branch $opts
    fi

}
safe_func_export git-branch-list

git-logg ()
{
    ##@@ none||none||git-logg||
    gitfuncs_audit "$@"

    git log --all --graph --pretty=format:'%Cred%h%Creset -%d %s (%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
}
safe_func_export git-logg

git-log-grab-sha ()
{
    ##@@ none||none||git-log-grab-sha||Grab a commit from log output. Takes either 1) a sha to start at or 2) a limiting number option that is optionally followed by the sha to start at.
    gitfuncs_audit "$@"
    local args="$@"
    [ -z "$args" ] && args='-1'
    git log $args | grep '^commit' | tail -1 | perl -pe 's/commit\s+//'
}
safe_func_export git-log-grab-sha

git-log-shas-range ()
{
    ##@@ none||none||git-log-shas||Given two shas (older newer), call git log on the range, inclusively
    gitfuncs_audit "$@"

    local opt_hf=''
    local opt_inclusive=1
    local opt_add_names=''
    OPTSARGS=$(getoptp -o f:ienh --long highlightfirst:,inclusive,exclusive,name-only,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -f|--higlightfirst)  opt_inclusive=1; opt_hf="$2"; shift; shift ;;
            -i|--inclusive) opt_inclusive=1; shift ;;
            -e|--exclusive) opt_inclusive=0; shift ;;
            -n|--name-only) opt_add_names='--name-only'; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    [ -z "$2" ] && echo "Usage: git-log-sha-range oldersha newersha" && return $NOT_OK;
    git --no-pager log $opt_add_names ${1}..${2} ## Does not print the first one
    if((opt_inclusive))
    then
        [ ! "$1" = "$2" ] && echo "$hf_based"
        git --no-pager log $opt_add_names -1 ${1}    ## Always prints the first one
    fi
}
safe_func_export git-log-shas-range

git-restore ()
{
    ##@@ none||none||git-restore||
    gitfuncs_audit "$@"

    echo "Use 'git log' to find the id (sha) of the revision that contains"
    echo "the prior version of the file you want to revert to."
    echo "Then execute 'git checkout sha the/file/to/revert'."
}
safe_func_export git-restore

git-revert ()
{
    ##@@ none||none||git-revert||revert to the latest unmodified version on the current branch, losing any modifications.
    git checkout -- "$@"
}
safe_func_export git-revert

git-find-deleted ()
{
    ##@@ none||none||git-find-deleted||The revision in which the given file was deleted.
    gitfuncs_audit "$@"

    git rev-list -n 1 HEAD -- "$1"
}
safe_func_export git-find-deleted

git-find-last-existed ()
{
    ##@@ none||none||git-find-last-existed||The revision before which the given file was deleted.
    gitfuncs_audit "$@"

    git rev-list -n 1 $(git-find-deleted "$1")^ -- "$1"
}
safe_func_export git-find-last-existed

git-checkout-last-existed ()
{
    ##@@ none||none||git-checkout-last-existed||Find the revision in which the given file last existed and check it out
    gitfuncs_audit "$@"

    git checkout $(git-find-last-existed "$1") "$1"
}
safe_func_export git-checkout-last-existed

git-to-stdout-last-existed ()
{
    ##@@ none||none||git-checkout-last-existed||Find the revision in which the given file last existed and print to stdout (or file.uuid if --file specified).
    gitfuncs_audit "$@"

    local file=''
    if [ "$1" = '-file' ]
    then
        file='-file'
        shift;
    fi
    for f in "$@"
    do
        git-to-stdout $file $(git-find-last-existed "$f") "$f"
    done
}
safe_func_export git-to-stdout-last-existed

git-root ()
{
    ##@@ none||none||git-root||Print the root of the current repo
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift

    git rev-parse --show-toplevel

    return $?
}
safe_func_export git-root

git-gui ()
{
    ##@@ none||none||git-gui||
    gitfuncs_audit "$@"

    git gui "$@" &
}
safe_func_export git-gui

gitgui ()
{
    git-gui "$@"
}
safe_func_export gitgui

git-pull-with-checkpoint ()
{
    ##@@ none||none||git-pull-with-checkpoint||Write a file with the current UUID before pulling updates.
    gitfuncs_audit "$@"

    git log -1 > $(git-root).git-pull-checkpoint
    git pull "$@"
}
safe_func_export git-pull-with-checkpoint

git-diff-to-checkpoint ()
{
    ##@@ none||none||git-diff-to-checkpoint||Diff the current state of the local repo against the state as it was stored in git-pull-with-checkpoint
    gitfuncs_audit "$@"

    local oldid=$(grep $(git-root).git-pull-checkpoint| head -1 | sed 's/commit//')
    local newid=$(git log -1 | head -1 | sed 's/commit//')
    git diff $oldid $newid
}
safe_func_export git-diff-to-checkpoint


git-to-stdout-usage ()
{
    echo 'Usage: git-to-stdout [--file] uuid objectname [objectname...]'
    echo '       From the version specified by "uuid" print the objects'
    echo '       requested to stdout. "objectname" must be fully quailifed'
    echo '       from the repo root, not current directory. If --file'
    echo '       is specified, then write to file to objectname.uuid instead'
}
safe_func_export git-to-stdout-usage

git-to-stdout ()
{
    ##@@ none||none||git-to-stdout||Equivalent of cvs -p. Provide a uuid and one or more path/to/file arguments.
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    OPTSARGS=$(getoptp -o hf --long help,file -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    local file=0
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) $usage_func; return $OK ;;
            -f|--file) file=1; shift ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    if (($# < 2 ))
    then
        $usage_func
        return $NOT_OK
    fi

    local uuid=$1;shift
    for i in $@
    do
        if ((file))
        then
            echo ${i}.${uuid}
            git show ${uuid}:${i} > $(git-root)/${i}.${uuid}
        else
            git show ${uuid}:${i};
        fi
    done
}
safe_func_export git-to-stdout

git-merge-pull-request-usage ()
{
    local cmd=$1;shift
    local protocol=$1
    local protocolarg=$1
    if [ -z "$protocol" ]
    then
        protocol='protocol'
        protocolarg='protocol'
    else
        protocolarg=''
    fi

    cat <<EOUSAGE

Usage: $cmd $protocolarg tgtnamespace/tgtrepo/tgtbranch srcnamespace/srcrepo/srcbranch
       $cmd $protocolarg tgtnamespace/tgtrepo/tgtbranch srcnamespace:srcbranch
       $cmd $protocolarg tgtnamespace/tgtrepo/tgtbranch srcbranch
       $cmd $protocolarg --upstream srcbranch
       $cmd $protocolarg --upstream
       $cmd $protocolarg

       Other options:
           --verbose - prints blow-by-blow action descriptions
           --keep    - unconditionally keep (do not ask about)
                       the target clone

       Merge the branch from the 'src' into the 'tgt'.

       The typical usage looks like

           $cmd $protocolarg dkpg/bulddeb mybranch

       In this case:

           - the source namespace defaults to your username
           - the source repo defaults to the target repo name
           - the target branch is 'master'

       Merging someone else's branch looks like

           $cmd $protocolarg dpkg/builddeb/ user//theirbranch

       As a cut 'n paste convenience, we also accept

           $cmd $protocolarg dpkg/builddeb/ user:theirbranch

       Furthermore, if your local repo that has the objects to merge is clone
       of a fork of the canonical repo, i.e. you are using the 'triangle'
       workflow, you can replace the target spec with --upstream. In this case,
       the target namespace and repo is the result of the command

           git config --get remote.upstream.url

       If the source is not specified, we assume the current branch.

       If the target is not specified, we assume --upstream.

       The use of --upstream and the current branch assumes you are in the
       branch that you have just pushed up to be merged.

EOUSAGE

}
safe_func_export git-merge-pull-request-usage

git-merge-pull-request ()
{
    ##@@ none||none||git-merge-pull-request||Merge a remote pull request from command line.
    gitfuncs_audit "$@"
    local usage_func=git-merge-pull-request-usage
    local iam=$(func-name-spoof)
    local spoofing=$?

    local protocol=$1;shift
    local protocol_url=$(kvget gitfuncs_gitsvcs $protocol)
    if [ -z "$protocol_url" ]
    then
        echo "$protocol is unknown. Valid protocols are:$(kvgetvalues gitfuncs_gitsvcs)"
        return $NOT_OK
    fi

    local usage_arg
    [ "$spoofing" = "$(true)" ] && usage_arg=$protocol

    local opt_help=0
    local opt_verbose=0
    local opt_keep=0
    OPTSARGS=$(getoptp -o vhk --long verbose,help,keep -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) $usage_func $iam $usage_arg ; return $OK;;
            -k|--keep) opt_keep=1; shift ;;
            -v|--verbose) opt_verbose=1; shift ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local tgtarg=$1
    local srcarg=$2
    local inamespace=0
    local irepo=1
    local ibranch=2

    local confirm_args=0
    local current_branch_delete=''

    ## If there is no srcarg, take the current branch
    if [ -z "$srcarg" ]
    then
        srcarg=$(git-get-current-branch)
        confirm_args=1
        current_branch_delete=$(pwd)
    fi

    ## Public and enterprise github web interfaces show merge source as
    ## 'user:branch'. We fix this up as 'user/tgtrepo/branch' and all our
    ## parsing further along 'just works' (but see below).
    srcarg="${srcarg/:/\/-\/}"

    ## if there are no slashes in the src, we assume it's just a branch. We fix
    ## this up as '//branch' and all our parsing further along 'just works'.
    [[ $srcarg =~ / ]] || srcarg="-/-/$srcarg"

    ## Using the triangle workflow shortcut:
    if [ "$tgtarg" = '--upstream' ] || [ -z "$tgtarg" ]
    then
        tgtarg=$(git config --get remote.upstream.url | sed 's/.*://')
        confirm_args=1
    fi

    asplit tgt / $tgtarg
    asplit src / $srcarg

    ## Ok, we just split on '/' assuming some form of namespace/repo/branch, but
    ## branch could itself have slashed in it. Sooooo, we fix that up here:
    local tmpend=${#src[@]}
    local tmpcount=$((tmpend - ibranch))
    tmp=(${src[$inamespace]} ${src[$irepo]} $(ajoin / ${src[@]:$ibranch:$tmpcount}))
    src=("${tmp[@]}")
    tmpend=${#tgt[@]}
    tmp=(${tgt[$inamespace]} ${tgt[$irepo]} $(ajoin / ${tgt[@]:$ibranch:((tmpend-2))}))
    tgt=("${tmp[@]}")

    ## Here, we set defaults for missing data...
    ([ "${src[$inamespace]}" = '-' ] || [ -z "${src[$inamespace]}" ] ) && src[$inamespace]=${USER}
    ([ "${src[$irepo]}"      = '-' ] || [ -z "${src[$irepo]}"      ] ) && src[$irepo]=${tgt[$irepo]}
    ([ "${src[$ibranch]}"    = '-' ] || [ -z "${src[$ibranch]}"    ] ) && src[$ibranch]=master
    ([ "${tgt[$ibranch]}"    = '-' ] || [ -z "${tgt[$ibranch]}"    ] ) && tgt[$ibranch]=master

    local srcurl="$protocol:${src[$inamespace]}/${src[$irepo]}"
    local remote_ref=$(ajoin _ $(asplit - / $(ajoin '_' ${src[@]})))

    local merge_src='remote'
    [ "${src[$inamespace]}" = "${tgt[$inamespace]}" ] && \
        [ "${src[$irepo]}" = "${tgt[$irepo]}" ] && \
        merge_src='origin'

    if ((confirm_args))
    then
        local resp=$(func-yesno "Merging to $protocol:${tgt[$inamespace]}/${tgt[$irepo]}/${tgt[$ibranch]} from $protocol:${src[$inamespace]}/${src[$irepo]}/${src[$ibranch]}")
        if [ "$resp" = 'n' ]
        then
            return $NOT_OK
        fi
    fi
    ((opt_verbose)) && func-echo --head "Clone $protocol:${tgt[$inamespace]}/${tgt[$irepo]}..."
    ${protocol}-clone ${tgt[$inamespace]} ${tgt[$irepo]}
    local status=$?
    ((status)) && _git_cd_unwind && return $status
    local tgt_repo_dir=$(pwd)

    ((opt_verbose)) && func-echo --head "Switch to branch ${tgt[$ibranch]}..."
    git checkout ${tgt[$ibranch]}
    local status=$?
    ((status)) && _git_cd_unwind && return $status

    local origcommitsha=$(git rev-parse HEAD)
    local newcommitsha=$(git rev-parse HEAD)
    local currentlogmsg="Current last commit on target branch ${tgt[$ibranch]}"
    func-echo --head "****** $currentlogmsg"
    git-log-shas-range ${origcommitsha} ${newcommitsha}
    status=$?
    ((status)) && _git_cd_unwind && return $status
    func-echo "******"

    if [ "$merge_src" = 'remote' ]
    then
        ((opt_verbose)) && func-echo --head "Add $srcurl... as a remote"
        ((opt_verbose)) && func-echo -c     "git remote add $remote_ref $srcurl"
        git remote add $remote_ref $srcurl
        status=$?
        ((status)) && _git_cd_unwind && return $status

        ((opt_verbose)) && func-echo --head "Fetch only the pull request branch (${src[$ibranch]}) from $srcurl (as remote ref $remote_ref)"
        ((opt_verbose)) && func-echo -c     "git fetch $remote_ref ${src[$ibranch]}"
        git fetch $remote_ref ${src[$ibranch]}
        status=$?
        ((status)) && _git_cd_unwind && return $status

        ((opt_verbose)) && func-echo --head "Do the merge"
        ((opt_verbose)) && func-echo -c     "git rebase ${tgt[$ibranch]} ${remote_ref}/${src[$ibranch]}"
        git rebase ${tgt[$ibranch]} ${remote_ref}/${src[$ibranch]}
        status=$?
        ((status)) && _git_cd_unwind && return $status

        newcommitsha=$(git rev-parse HEAD)
        local lasttwologmsg="Last commits on target branch ${tgt[$ibranch]}"
        func-echo --head "****** $lasttwologmsg"
        git-log-shas-range ${origcommitsha} ${newcommitsha}
        status=$?
        ((status)) && _git_cd_unwind && return $status
        func-echo "****** **************************"

        func-echo -c "Success is defined as"
        func-echo -c "1) You are reading this message."
        func-echo -c "2) The log entries from '$lasttwologmsg'"
        func-echo -c "   are consistent with entry from '$currentlogmsg'."
        echo
    else
        func-echo --head "Fetch only the pull request branch (${src[$irbranch]}) from $srcurl"
        git fetch $srcurl ${src[$ibranch]}
        status=$?
        ((status)) && _git_cd_unwind && return $status
        [ "$(func-yesno cont)" = 'n' ] && echo return

        func-echo --head "Do the merge"
        git rebase $tgt{$ibranch} origin/${src[$ibranch]}
        status=$?
        ((status)) && _git_cd_unwind && return $status
        [ "$(func-yesno cont)" = 'n' ] && echo return
        git checkout $tgt{$ibranch}

        newcommitsha=$(git rev-parse HEAD)

        pause 'Go to another terminal, do a git log and see what you got. Then quit this, come back and fix the code accordingly.'
        ## INSERT SOME git log comparison instructions here!!!!!!
        _git_cd_unwind && return $NOT_OK
    fi

    local pushback="git push origin HEAD:${tgt[$ibranch]}"
    local resp=$(func-yesno "Push back to ${protocol} via '$pushback'")
    local retval
    if [ "$resp" = 'y' ]
    then
        pwd
        ((opt_verbose)) && func-echo --head "Push back"
        $pushback
        retval=$?
        if [ "$retval" = '0' ]
        then
            ## These two lines record the sha of what we committed so that
            ## later we can find all the repos/worktrees we committed from that
            ## have not been cleaned up so we can clean them up. We store the
            ## source with sha as key and the target with the time of merge as
            ## the value.
            local sha=$(git-log-grab-sha -1)
            git-merge-write $sha $protocol ${tgt[@]} ${src[@]}
            ## Read what we just wrote
            git-merge-find $sha

            ## Cleanup the tmp repo used for the merge.
            if ((opt_keep))
            then
                resp=n
            else
                resp=$(func-yesno "Remove local tgt repo ($tgt_repo_dir)")
            fi
            if [ "$resp" = 'y' ]
            then
                git-delete-current-repo
                retval=$?
                if [ "$retval" != '0' ]
                then
                    return $retval
                    ## No cd unwind here. If something went wrong, stay here
                    ## and clean it up.
                fi
            else
                ## Play it purrty for 'lanta...
                git checkout ${tgt[$ibranch]}
                git pull
                ## No cd unwind here. If we are keeping the local master, we
                ## probably need to do something in it, so we stay.
            fi

            ## If we started out in a repo corresponding to the merged branch,
            ## go back and whack it.
            if [ -n "$current_branch_delete" ]
            then
                _git_cd_to $current_branch_delete
                git-inside-worktree
                local status=$?
                if [ "$status" = "$TRUE" ]
                then
                    git-delete-current-worktree --schedule 24
                else
                echo "***************** current branch delete ***************"
                echo " $(pwd) "
                    pause Going to run git-delete-current-rep
                    git-delete-current-repo
                fi
            fi
        fi
    else
        local fmpr=$(pwd)/FINISH-merge-pull-request
        func-echo    "Ok. Remember to '$pushback' soon before the master head advances."
        func-echo -c "We will write the local file $fmpr with this command for your future convenience."
        echo "$pushback" > $fmpr
        echo "git-delete-current-repo" >> $fmpr
        git-log-shas-range ${origcommitsha} ${newcommitsha} | comment-stream "## " >> $fmpr
        chmod +x $fmpr
        retval=0
    fi
    _git_cd_unwind && return $retval
}
safe_func_export git-merge-pull-request

git-merge-pr ()
{
    git-merge-pull-request "$@"
}
safe_func_export git-merge-pr

git-merge-write-usage ()
{
    echo "Usage: git-merge-write sha protocol tgtorg tgtrepo tgtbranch srcorg srcrepo srcbranch [merged-by]"
}
safe_func_export git-merge-write-usage

git-merge-write ()
{
    ##@@ none||none||git-merge-write||
    gitfuncs_audit "$@"

    [ -z "$1" ] && git-merge-write-usage && return 1

    local sha=$1;shift
    local protocol=$1;shift;
    local tgt=($1 $2 $3);shift;shift;shift
    local src=($1 $2 $3);shift;shift;shift
    local merged_by=$(id -n -u)
    [ -n "$1" ] && merged_by=$1 && shift;
    local resp
    local merge_audit_value="${sha}@$(date +%Y_%m_%d-%H_%M_%S)@$merged_by"
    src[2]=$(echo "${src[2]}" | sed 's/\//---/g')
    tgt[2]=$(echo "${tgt[2]}" | sed 's/\//---/g')
    local merge_audit_key_by_tgt="merge-pr-by-tgt.${protocol}--${tgt[0]}--${tgt[1]}--${tgt[2]}.${protocol}--${src[0]}--${src[1]}--${src[2]}"
    git config -f ~/.gitconfig.merge_audit "$merge_audit_key_by_tgt" "$merge_audit_value"

    local merge_audit_key_by_src="merge-pr-by-src.${protocol}--${src[0]}--${src[1]}--${src[2]}.${protocol}--${tgt[0]}--${tgt[1]}--${tgt[2]}"
    git config -f ~/.gitconfig.merge_audit "$merge_audit_key_by_src" "$merge_audit_value"
}
safe_func_export git-merge-write

git-merge-find-usage ()
{
    echo "Usage: git-merge-find-usage ..."
    echo "       TBD"
}
safe_func_export git-merge-find-usage

git-merge-find ()
{
    ##@@ none||none||git-merge-find||Is there a merge record in ~/.gitconfig.merge_audit for given or current branch.
    gitfuncs_audit "$@"

    local opt_silent=0
    local opt_all=0
    OPTSARGS=$(getoptp -o sha --long silent,help,all -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--silent) opt_silent=1; shift ;;
            -h|--help) $usage_func; return $OK ;;
            -a|--all) opt_all=1; shift ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local r
    local b
    local search
    local searchid
    if [ -n "$1" ]
    then
        search="${1}"
        searchid="${1}"
    else
        if ((opt_all==0))
        then
            git-in-a-repo
            if (( $? == 0 ))
            then
                r=$(git remote -v | grep origin | grep '(fetch)' | perl -ane '$F[1] =~ s/[\/:]/--/g; print $F[1]')
                b=$(git-get-current-branch)
            else
                echo "Not in a repo"
                return $NOT_OK
            fi
        fi
        search="${r}--${b}"
        rid=$(git remote -v | grep origin | grep '(fetch)' | perl -ane 'print $F[1]')
        searchid="${rid}:${b}"
    fi
    merged=$(git config -f ~/.gitconfig.merge_audit --list | grep -E -- "${search}" 2>/dev/null)
    if [ -z "$merged" ]
    then
        ((opt_silent)) || echo "No record of merging $searchid to anywhere."
        return $NOT_OK
    else
        echo "$merged" | perl -ne '
BEGIN { $me = getlogin };
chomp;
my ($k, $v) = split(/=/);
my ($sha,$date,$who) = split(/@/,$v);
my ($tag,$tgt,$src) = split(/\./, $k);
if ($tag eq q(merge-pr-by-tgt)) {
    $src =~ s/---/\//g;
    $tgt =~ s/---/\//g;
    my @srcparts = split(/--/, $src);
    my @tgtparts = split(/--/, $tgt);
    my @m = (qq(Merged $sha),
             qq(  from $srcparts[0]:$srcparts[1]/$srcparts[2]:$srcparts[3]),
             qq(    to $tgtparts[0]:$tgtparts[1]/$tgtparts[2]:$tgtparts[3]),
             qq(    on $date));
    push @m, qq(    by $who) if ($who ne $me);
    push @m, qq ();

    push @out, {
        d => $date,
        m => join(qq(\n),@m)
   };
}
END {
    print(map {$_->{m}} sort {$a->{d} cmp $b->{d}} @out)
};
'
        return $OK
    fi
}
safe_func_export git-merge-find

git-merge-find-branch ()
{

    git config -f ~/.gitconfig.merge_audit --list | grep "$@"
}
safe_func_export git-merge-find-branch

git-branch-info ()
{
    ##@@ none||none||git-branch-info||Read, write or delete meta information for a branch
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"
    local branch=$(git rev-parse --abbrev-ref HEAD)
    local timestamp=''
    local delete=0
    OPTSARGS=$(getoptp -o b:tdu --long branch:,timestamp,delete,unset -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --branch|-b) branch=$2; shift; shift;;
            --timestamp|-t) timestamp="[$(date)]"; shift;;
            --delete|-d|--unset|-u) delete=1; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    local get_option='--get'
    local full_key="branch.${branch}"
    local key=$1
    if [ -n "$key" ]
    then
        full_key="${full_key}.${key}"
    elif ((delete))
    then
        echo "Cannot delete without an exact key to match on"
        return 1
    else
        get_option='--get-regexp'
    fi

    shift ## $@ is now the value if writing. All spaces will be converted to
          ## %20.
    if [ -z "$1" ]
    then
        if((delete))
        then
            ## Remove existing key
            git config --unset $full_key
        else
            ## Read existing key
            git config $get_option $full_key | \
                perl -pe 's/%20/ /g' | \
                sort
        fi
    else
        local value=$(echo $@ | perl -pe 's/\s/%20/g')
        git config $full_key "${timestamp}$value"
    fi
}
safe_func_export git-branch-info

git-st-ext ()
{
    ##@@ none||none||git-st-ext||Read or write a note about this fork's current status
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        git-branch-info --timestamp local-status "$@"
    else
        git-branch-info local-status
        local gmdw=$(git-branch-info delete-worktree)
        [ -n "$gmdw" ] && echo "Worktree scheduled for removal on or after $( date --date=@$gmdw)"
        git-merge-find
        git-branch-info-pull-request
    fi
}
safe_func_export git-st-ext

git-st-ext-all ()
{
    ##@@ none||none||git-st-ext||Read all notes about repo current statuses
    gitfuncs_audit "$@"

    for i in $(git-go --listfull)
    do
        ( builtin cd $i
          local s=$(git-st-ext)
          [ -n "$s" ] && echo $i - $s
        )
    done
}
safe_func_export git-st-ext-all

git-delete-current-repo ()
{
    ##@@ none||none||git-delete-current-repo||
    gitfuncs_audit "$@"

    git-parse-remote-v
    git-delete-repo $(echo ${gitfuncs_remotes[origin]} | tr '[/:]' '[  ]')
    return $?
}
safe_func_export git-delete-current-repo

git-rebase-log ()
{
    ##@@ none||none||git-rebase_log||Show the log, rebase on the last commit id
    gitfuncs_audit "$@"

    local rebase_sha
    local resp
    if [ -z "$1" ]
    then
        ## Show the current commit
        func-echo --head 'Current commits:'
        git log -2
        ## The first one we can rebase on is the third one in the log
        rebase_sha=$(git-log-grab-sha -3)
    else
        rebase_sha=$1
    fi

    func-echo --head 'Rebaseable commits:'
    while ((1))
    do
        ## show the log
        git-log-shas-range $rebase_sha $rebase_sha

        resp=$(func-pick "Rebase on $rebase_sha" "y/n/q" 'n')
        if [ "$resp" = 'q' ]
        then
            return $TRUE
        fi
        if [ "$resp" = 'y' ]
        then
            git rebase -i $rebase_sha
            local status=$?
            (($status)) && return $status
            func-echo --head 'Log is now:'
            git log ${rebase_sha}^1..HEAD
            return $status
        fi

        ## Get the next log
        rebase_sha=$(git-log-grab-sha -2 $rebase_sha)
    done
}
safe_func_export git-rebase-log

git-log-rebase ()
{
    git-rebase-log "$@"
}
safe_func_export git-log-rebase

_git_cd_to ()
{
    local tgt=$(realpath $1)
    local src=$(pwd)
    builtin cd $tgt && apush GITFUNCS_OLDPWDS "$src" ## Push only if we can get
                                                     ## to the target
    return $?

}
safe_func_export _git_cd_to

_git_cd_return ()
{
    local tgt=$(apop GITFUNCS_OLDPWDS) ## We pop no matter what so bad dirs are
                                       ## cleared from the stack and we don't
                                       ## get stuck on them.
    [ -n "$tgt" ] && builtin cd $tgt
    return $?
}
safe_func_export _git_cd_return

## Express to the top of the stack
_git_cd_unwind ()
{
    local tgt=$(ashift GITFUNCS_OLDPWDS)
    if [ -n "$tgt" ]
    then
        ## We pop no matter what so bad dirs are cleared from the stack and we
        ## don't get stuck on them.
        aclear GITFUNCS_OLDPWDS && builtin cd $tgt
    fi
    return $?
}
safe_func_export _git_cd_unwind

git-retimestamp ()
{
    ##@@ none||none||git-retimestsamp||Adjust all non-modified, tracked files to have the date of their last commit, not the pull date.
    gitfuncs_audit "$@"
    local verbose=0
    if [[ "$1" =~ -v ]]
    then
        verbose=1
    fi

    ## Get the files
    declare -A gitfiles
    for i in $(git ls-files)
    do
        gitfiles[$i]=1
    done

    ## Remove any that are currently modified
    local msgd=''
    for i in $(git-is-mod)
    do
        if [ -z "$msgd" ]
        then
            msgd=1
            if ((verbose==0))
            then
                echo Will not consider modified files
            else
                echo Will not consider the following modified files:
            fi
        fi
        ((verbose)) && echo $i
        unset gitfiles[$i]
        [ -n "${gitfiles[$i]}" ] && echo "WOAH DIDNT DELETE gitfiles[$i] - '${gitfiles[$i]}'"
    done

    ## Parse the log
    local gitdate
    date > /tmp/get-retimestamp.log
    git log  --date=iso --name-only | \
        while read -r i;
        do
            if [ -z "$i" ]
            then
                noop=1
            elif [[ $i =~ Date: ]]
            then
                gitdate=$(echo $i | sed -E 's/Date:\s+//')
            elif [ -n "${gitfiles[$i]}" ]
            then
                echo "gitfiles[$i] => ${gitfiles[$i]}" >> /tmp/get-retimestamp.log
                unset gitfiles[$i]
                [ -n "${gitfiles[$i]}" ] && echo "WOAH DIDNT DELETE gitfiles[$i] - '${gitfiles[$i]}'"
                local filedate=$(stat -c %y $i | sed 's/\.[0-9]+//')
                if [ ! "$filedate" = "$gitdate" ]
                then
                    if ((verbose))
                    then
                        echo
                        echo $i...
                        ls -la $i
                    fi
                    touch -d "$gitdate" $i
                    if ((verbose))
                    then
                        ls -la $i
                    fi
                fi
            fi
        done
}
safe_func_export git-retimestamp

## TODO: git-create-patches-usage

git-create-patches ()
{
    ##@@ none||none||git-create-patches||
    gitfuncs_audit "$@"

    if [ ! "$(pwd)" = "$(git-root)" ]
    then
        echo "You must be in root dir of repo or worktree ($(git-root)), not $(pwd)"
        return $NOT_OK
    fi

    local patchdir
    patchdir="./patches_dir.outbound"

    local patchpath
    patchpath=$(realpath $patchdir)
    if [ ! -d $patchpath ]
    then
        mkdir $patchpath || return $?
    fi

    local source_repo="$(echo $(hostname):$(git-root) | tr [/] [..])"
    local patchindir
    patchindir="./patches_dir.from.${source_repo}"
    local patchinpath
    patchinpath=$(realpath $patchindir)

    echo "Creating patches..."
    local patchlist
    patchlist=$(mktemp --suffix=.git-create-patches)
    local workpatchpath
    workpatchpath=$(mktemp -d)
    git format-patch -o $workpatchpath --full-index --root > $patchlist
    if [ ! -s $patchlist ]
    then
        echo "No patches to apply."
        return
    fi

    local newsha
    newsha=$(git-log-grab-sha -1)
    local config_key_root
    config_key_root=BOGUS
    local new_files
    new_files=$(diff $patchpath $workpatchpath 2>&1 | grep "Only in $workpatchpath" | sed -e 's/Only in //' -e 's/: /\//' )
    if [ -z "$new_files" ]
    then
        echo "No new patches to apply."
        return
    fi

    cp -pvf $new_files $patchpath
    \rm -f $patchpath/restore.*
    local restorescript
    restorescript=$patchpath/restore.${newsha}

    ##
    ## This generates the restore script for use on the other end
    ##
    echo "## -*- sh -*-
PATCHPATH=\$(dirname \$(realpath \$0))
GITREPOROOT=\$(dirname \$PATCHPATH)
if [ ! -d \$GITREPOROOT/.git ]
then
    echo \"Not in a git repo. git init \$GITREPOROOT and re-run\"
    exit 1
fi
last_applied=''
current_branch=\$(git symbolic-ref HEAD | sed 's!refs\/heads\/!!')
config_key_root=\"branch.\${current_branch}.lastpatched-from.${source_repo}.\"
last_applied=\$(git config --get \${config_key_root}patch )
if [ -z \"\$last_applied\" ]
then
  git config --add \${config_key_root}patch 0
  git config --add \${config_key_root}date  'none'
fi
patchcount=$(cat $patchlist | wc -l)
patchnum=0
restart=\$(realpath \$0).\$(date +%Y%m%d%H%M%S).restart
restartlink=\$(realpath \$0).restart
for i in $(cat $patchlist | PATCHPATH=$workpatchpath perl -ne 'chomp;s|$ENV{PATCHPATH}|\$PATCHPATH|;print(qq(\\\n$_ ))')
do
  ((patchnum+=1))
  echo
  echo \"-- \$patchnum/\$patchcount --\"
  if [ \"\$i\" \\> \"\$last_applied\" ]
  then
    log=\${i}.log
    (git am \$i; s=\$?; echo \$s) 2>&1 | tee \$log
    status=\$(tail -1 \$log)
    if [ ! \$status = '0' ]
    then
      cat <<EORESTART > \$restart
## \$((patchnum-1)) was the last successful patch

## Errors for patch \$patchnum:
\$(cat \$log | sed 's/^/## /')

## These mark the failed patch as succeeded:
git config \${config_key_root}patch \$i;
git config \${config_key_root}date  \"\\\$(date)\"

## This restarts the process:
\$0
EORESTART

      chmod +x \$restart
      \\rm -f \$restartlink
      ln -s \$restart  \$restartlink

      cat <<EORESTART | tee -a \$restart

## The error log has been retained in
##    \$log
## and
##    \$restart
## which can be accessed by
##    \$restartlink

## After you have fixed the issue with the appropriate
## git incantations, restart the patching process by executing
##    \$restartlink

## The 'appropriate git incantations' can be one of two sets of actions:

## THESE ACTIONS HAVE BEEN CONFIRMED TO WORK:

## o Skip that patch with git am --skip

##   OR

## o Apply ALL the edits in the patch file by hand. It
##   appears that patch application is an all or nothing
##   proposition; if one or more fails, the good ones
##   are not applied.
## o git add all modified files
## o git am --continue to commit the adds and make the
##   commit entry.

## THESE ACTIONS HAVE **NOT** BEEN CONFIRMED TO WORK:

## o Rollback the patch with git am --abort
## o Apply ONLY the FAILED edits in the failed patch by hand.
## o Remove the failed patch and its index entry (at the top
##   of the patch file) from the patch file.
## o Reapply the patch file with git am.
##
## These actions should relieve you of having to execute
## the good patches by hand.

## Either way once you have either reapplied or skipped the
## patch, execute
##    \$restartlink
## in order to continue with the next patch.
##
EORESTART

      exit \$status
    else
      \\rm -f \$log
    fi
    git config \${config_key_root}patch \$i
    git config \${config_key_root}date  \"\$(date)\"
    read -p 'Return to continue, CTRL-C to exit'
  else
    echo \"\$i <= \$last_applied, skipping\"
  fi
done
" > $restorescript
    chmod a+rwx $restorescript
    local sharfile=$(git-root)/$(basename $(git-root)).shar
    (cd $patchdir && shar -q -o $sharfile *.patch $(basename $restorescript))
    echo "1 - $ cp ${sharfile}* {git root of the target}"
    echo "2 - $ cd {git root of the target}"
    echo "3 - $ mkdir $patchindir && unshar -d $patchindir $(basename $sharfile)*"
    echo "4 - $ cd $patchindir"
    echo "5 - $ ./$(basename $restorescript)"
}
safe_func_export git-create-patches

git-post-new ()
{
    ##@@ none||none||git-post-new||
    gitfuncs_audit "$@"

    func-echo "Making a $GITFUNCS_CHANGELOG_NAME file"
    touch $(git-root)/$GITFUNCS_CHANGELOG_NAME

    if [ "$1" = '-t' ]
    then
        func-echo "Setting timestamps..."
        git-retimestamp
    fi
}
safe_func_export git-post-new

git-in-a-repo ()
{
    git-root 2>/dev/null 1>&2
    return $?
}
safe_func_export git-in-a-repo

git-branch-info-pull-request ()
{
    ##@@ none||none||git-branch-info||Read or write pull request information for a branch
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"
    local branch=$(git rev-parse --abbrev-ref HEAD)
    OPTSARGS=$(getoptp -o b: --long branch: -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --branch|-b) branch=$2; shift; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return $NOT_OK ;;
        esac
    done

    git-branch-info --branch $branch pull-request "$1"
}
safe_func_export git-branch-info-pull-request

git-diff-two-repos-on-disk-usage ()
{
    cat<<EOUSAGE
Usage: git-diff-two-repos-on-disk [src] tgt
       git-diff-two-repos-on-disk [-h|-help]

       Compare two repos on disk. If only one repo is specified,
       'src' is taken as the current directory, which should be
       a repo root.
EOUSAGE
}

git-diff-two-repos-on-disk ()
{
    ##@@ none||none||git-diff-two-repos-on-disk||
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"

    OPTSARGS=$(getoptp -o h --long help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func ${FUNCNAME} && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func ${FUNCNAME}; return $NOT_OK ;;
        esac
    done

    local -A repo
    if [ -n "$2" ]
    then
        repo[this]=$(realpath $1)
        repo[other]=$(realpath $2)
    else
        repo[this]=$(pwd)
        repo[other]=$(realpath $1)
    fi

    if [ ${repo[this]} = ${repo[other]} ]
    then
        echo Other dir is this dir. Whoops! Bye.
        return $NOT_OK
    fi

    local -A list
    list[this]=$(mktemp --suffix=.git-diff-two-repos-on-disk.this)
    list[other]=$(mktemp  --suffix=.git-diff-two-repos-on-disk.other)

    local -A opposed
    opposed[this]=other
    opposed[other]=this

    local which
    for which in this other
    do
        perl -e 'chdir $ARGV[0];
                 print qx(git ls-files)' ${repo[$which]} > ${list[$which]}
    done

    local -A seen
    for which in this other
    do
        local line
        while IFS='' read -r line || [[ -n "$line" ]]
        do
            if [ -z "${seen[$line]}" ]
            then
                seen[$line]=$line

                local output=$(diff -q "${repo[$which]}/$line" "${repo[${opposed[$which]}]}/$line")
                if [[ "$output" =~ 'No such file or directory' ]]
                then
                    echo "Copying ${repo[$which]}/$line ${repo[${opposed[$which]}]}/$line"
                    cp -vf ${repo[$which]}/$line ${repo[${opposed[$which]}]}/$line
                elif [ -n "$output" ]
                then
                    echo '*****'
                    echo git diff "${repo[$which]}/$line" "${repo[${opposed[$which]}]}/$line"
                    git diff "${repo[$which]}/$line" "${repo[${opposed[$which]}]}/$line"
                fi
            fi
        done < ${list[$which]}
    done
}
safe_func_export git-diff-two-repos-on-disk

git-pull-usage ()
{
    cat <<EOUSAGE
Usage: git-pull [-t]
       git pull followed by a descriptinve git status.

       -t resets the timestamps on the pulled files
          to their original commit times
EOUSAGE
}
safe_func_export git-pull-usage

git-pull ()
{
    ##@@ none||none||git-pull||Show log state after pull. -t to invoke timestamp fixer.
    gitfuncs_audit "$@"
    local usage_func="${FUNCNAME}-usage"

    local opt_t=0
    OPTSARGS=$(getoptp -o th --long timestamp,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func ${FUNCNAME} && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -t|--timestamp) opt_t=1; shift ;;
            -h|--help) $usage_func; return $OK ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func ${FUNCNAME}; return $NOT_OK ;;
        esac
    done

    local oldsha=$(git-log-grab-sha -1)
    git pull
    if ((opt_t))
    then
        func-echo "Setting timestamps..."
        git-retimestamp
        func-echo Done
    fi
    git-log-shas-range -f "pre-pull:" $oldsha $(git-log-grab-sha -1)
}
safe_func_export git-pull

git-regressive-diffs ()
{
    cat <<EOF
for i in $(git log -l bin/dpkg-buildd-cleanup | grep -E '^commit' | sed 's/commit //')
do
  if [ -z "$newer" ]
  then
     newer=$i
  elif [ -z "$older" ]
  then
     older=$i;
  else
     git diff $older $newer
     newer=$older
     older=$i
done
## last one
diff $older $newer
EOF
}
safe_func_export git-regressive-diffs

git-rename-worktree-usage ()
{
    echo "Usage: git-rename-worktree old_worktree new_worktree"
    echo "       where new_worktree will live in the same"
    echo "       directory as the old_worktree. Primarily"
    echo "       used when renaming the branch that the worktree"
    echo "       corresponds to."
}
safe_func_export git-rename-worktree-usage

git-rename-worktree ()
{
    ##@@ none||none||git-rename-worktree||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    if (($#!=2))
    then
        $usage_func
        return $NOT_OK
    fi

    local status
    local old_worktree_path=$(realpath $1)
    local old_worktree=$(basename $1)
    shift
    local new_worktree=$1
    shift
    if [ ! $(basename $new_worktree) = $new_worktree ]
    then
        func-echo "Cannot move out of parent directory"
        return $NOT_OK
    fi

    if (($#))
    then
        $usage_func
        echo "       argument(s) '$*' are illegal"
        return $NOT_OK
    fi

    local new_worktree_path=$(dirname $old_worktree_path)/$new_worktree
    _git_cd_to $old_worktree_path
    local cb=$(git-get-current-branch)
    if [ "$cb" = "$old_worktree" ]
    then
        func-echo "Renaming branch first..."
        git-rename-branch $old_worktree $new_worktree
        status=$?
        if ((status != $OK ))
        then
            _git_cd_unwind
            return $NOT_OK
        fi
    fi

    ## Get the metadata directory for this worktree
    local metadatadir=$(cat .git | grep -E '^gitdir:' | sed 's/.* //')

    ## Get the metadata files for this worktree
    local heregit=$(pwd)/.git
    local theregit=${metadatadir}/gitdir

    ## Change the metadata files
    perl -pi e "s/$old_worktree/$new_worktree/g" $heregit $theregit \
        || return $NOT_OK

    ## Move the metadata dir
    local newmetadatadir=$(dirname $metadatadir)/$new_worktree
    mv $metadatadir $newmetadatadir || return $NOT_OPK

    ## Move us
    _git_cd_to ..
    mv $old_worktree_path $new_worktree_path || return $NOT_OPK

    ## Clean up stuff
    git-go-set

    ## Go to new worktree
    builtin \cd $new_worktree_path
    return $?
}
safe_func_export git-rename-worktree

git-worktree-rename ()
{
    git-rename-worktree "$@"
}
safe_func_export git-worktree-rename

git-grep ()
{
    ##@@ none||none||git-grep||
    gitfuncs_audit "$@"

    local copt
    local cnum
    local edit=0
    declare -a args
    while (($#))
    do
        if [ "$1" = '-C' ]
        then
            ## Window around match
            copt=$1;shift;
            cnum=$1;shift
        elif [ "$1" = '--edit' ]
        then
            edit=1;shift
        else
            apush args "$1"; shift;
        fi
    done

    if [ -n "$copt" ]
    then
        git grep -l "${args[@]}" | xargs grep $copt $cnum "${args[@]}"
    elif ((edit))
    then
        local found=$(git grep -l "${args[@]}")
        if [ -n "$found" ]
        then
            $EDITOR $found & ## If editor is a screen app, it will start up
                             ## 'stopped' in background.
        else
            echo 'No files to edit'
        fi
    else
        git grep "${args[@]}"
    fi
}
safe_func_export git-grep

git-set-triangle-usage ()
{
    local cmd=$1;shift
    local protocol=$1
    if [ -z "$protocol" ]
    then
        protocolarg=$(kvget gitfuncs_gitsvcs $protocol)
    else
        protocolarg=''
    fi

    cat <<EOUSAGE
Usage: $cmd $protocolarg upstream-namespace namespace repo
       Changes and adds appropriate entries in local git config such that the
       triangle workflow is set up between an upstream repo, your fork of that
       repo, and the current local clone of the fork. We also add our own entry
       that annotates the fact that we ran this function to accomplish all
       this.
EOUSAGE
}

git-set-triangle ()
{
    ##@@ none||none||git-set-triangle||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"

    [ -z "$4" ] && $usage_func ${FUNCNAME} && return 1

    local protocolurl=$1
    local protocolkeycheck=$(kvgetkeys  gitfuncs_gitsvcs | grep -E "^$protocolurl$")
    if [ -n "$protocolkeycheck" ] ; then
        echo "Supposed to provide a URL, not a service name. Converting..."
        protocolurl=$(kvget gitfuncs_gitsvcs $protocolkeycheck)
        if [ -z "$protocolurl" ]
        then
            echo "No url found for protocol '$1'";
            return 1
        fi
    fi

    local upstream_namespace=$2
    local origin_namespace=$3
    local repo=$4

    declare -A triangle_workflow
    triangle_workflow[branch.master.merge]="refs/heads/master"
    triangle_workflow[branch.master.mergeoptions]="--ff-only"
    triangle_workflow[branch.master.remote]="upstream"

    triangle_workflow[remote.origin.fetch]="+refs/heads/*:refs/remotes/origin/*"
    triangle_workflow[remote.origin.url]="${protocolurl}${origin_namespace}/${repo}"
    triangle_workflow[remote.pushdefault]="origin"
    triangle_workflow[remote.upstream.url]="${protocolurl}${upstream_namespace}/${repo}"

    local key
    for key in ${!triangle_workflow[@]}
    do
        git config --replace-all $key "${triangle_workflow[$key]}" || return $?
    done

    ## These two are special because they repeat
    key='remote.upstream.fetch'
    ## Replace all blows away all $key entries before adding this one
    git config --replace-all $key "+refs/heads/*:refs/remotes/upstream/*" || return $?
    ## Now safe to add this one - it won't be duped.
    git config --add         $key "+refs/notes/*:refs/notes/*" || return $?

    ## We do this last as a marker.
    git config --replace-all gitfuncs.git-set-triangle.created "$(date +%Y%m%d.%H%M%S%z)"
}
safe_func_export git-set-triangle

## No functions below this line.

for external in github
do
    . ${GITFUNCS_FILE}.$external
done

auditfuncs-end
