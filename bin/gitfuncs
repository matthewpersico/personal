# -*- sh -*-

# gitfuncs

GITFUNCS_FILE=${BASH_SOURCE[0]}

auditfuncs_init $GITFUNCS_FILE
safe_func_export gitfuncs_audit

gitfuncs-edit ()
{
    gitfuncs_audit "$@"
    xo $GITFUNCS_FILE
}

gitfuncs-reload ()
{
    gitfuncs_audit "$@"
    . $GITFUNCS_FILE
}
alias gitfuncs-load=gitfuncs-reload

gitfuncs-help () {
    help_strings $GITFUNCS_FILE "$@"
}

GITFUNCS_CHANGELOG_NAME=mopChangeLog
export GITFUNCS_CHANGELOG_NAME

gitfuncs_gitroot_MBIG=${HOME}/MBIG
gitfuncs_gitroot=${HOME}/gits
gitfuncs_githook_root=${HOME}/.git_template
gitfuncs_githook_dir=${HOME}/.git_template/hooks

declare -A gitfuncs_gitsvcs
gitfuncs_gitsvcs[bbgithub]='bbgithub:'
gitfuncs_gitsvcs[devgit]='devgit:'
gitfuncs_gitsvcs[github]='https://github.com/'
gitfuncs_gitsvcs[bitbucket]='https://bitbucket.org/'

## This will be checked on each login and any time gitfuncs-reload is run. It's
## only ever executed when logging into a vm just after creation.
if [ ! -e $gitfuncs_gitroot ]
then
    echo "gits dir not set up. Setting up..."

    mkdir -vp $gitfuncs_gitroot/devgit
    mkdir -vp $gitfuncs_gitroot/bbgithub
    mkdir -vp $gitfuncs_gitroot/github
    mkdir -vp $gitfuncs_gitroot/bitbucket
    cat <<EOF >>$gitfuncs_gitroot/README
This directory level indicates which git system is being used.  Currently, only
devgit, bbgithub, github, and bitbucket should be here.
EOF

    mkdir -vp $gitfuncs_gitroot/bbgithub/mpersico5
    mkdir -vp $gitfuncs_gitroot/github/matthewpersico
    mkdir -vp $gitfuncs_gitroot/bitbucket/matthew_persico
    cat <<EOF >>$gitfuncs_gitroot//bbgithub/README
This directory level indicates git repo organization.  If we are using the
fork/clone methodology, then the only 'organization' at this level should
be your own namespace, unless you have directly cloned a 'master' repo.
EOF
fi


##
## Random aliases
##
alias gitpush='git push '
! $CRON && alias gitk="$(which gitk | tail -1 | sed 's/ +//') &"
alias git-grep='git grep '
alias gitgrep='git grep '
alias gitnp='git --no-pager '

##
## Goodies
##
git-st-por-usage () {
    echo "Usage: git-st-por [--strip [--]| -s [--]]  [arg ...]"
    echo "       git-st-por [--help|-h]"
    echo
    echo "       'git status' in porcelain mode."
    echo
    echo "       '--strip' will get remove the leading"
    echo "       status indicators. You need the '--'"
    echo "       that follows if you are passing other"
    echo "       'git status' options down."
    echo
    echo "       'arg' is any argument (or option, see"
    echo "       above) that you would normally"
    echo "       pass to 'git status'"
}

git-st-por ()
{
    ##@@ none||none||git-st-por||git status in porcelain mode
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local opt_strip=0
    OPTSARGS=$(getoptp -o sh --long strip,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--strip) opt_strip=1; shift ;;
            -h|--help) $usage_func; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    if ((opt_strip))
    then
        git st --porcelain "$@" | sed 's/.* //'
    else
        git st --porcelain "$@"
    fi
    return $?
}

git-find-usage () {
    echo 'Usage: git-find [[--all | -a] | [--untracked | -u]] fileExprssion'
    echo '  A convenience function around'
    echo '    git ls-files $(git rev-parse --show-toplevel) | grep -E fileExpression'
    echo '  By default, only finds files that are in the repo'.
    echo '  --untracked - finds only files that are NOT in the repo.'
    echo '  --all       - finds repo and non repo files.'
}

git-find ()
{
    ##@@ none||none||git-find||A convenience function around: git ls-files $(git rev-parse --show-toplevel) | grep -E fileExpression'
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local opt_untracked_only=0
    local opt_all=0
    OPTSARGS=$(getoptp -o auh --long all,untracked-only,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --untracked_only|-u) opt_untracked_only=1; shift ;;
            --all|-a) opt_all=1; shift ;;
            -h|--help) $usage_func; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    if [ "$opt_untracked_only" = 1 ] && [ "$opt_all" = 1 ]
    then
        echo "--untracked_only and --all are mutually exclusive"
        $usage_func
        exit 1
    fi

    local ls_files_opts="-c"
    if [ "$opt_untracked_only" = 1 ]
    then
        ls_files_opts="-o"
    elif [ "$opt_all" = 1 ]
    then
        ls_files_opts="-c -o"
    fi

    local to_find='*'
    [ -n "$@" ] && to_find="$@"
    git ls-files $ls_files_opts $(git rev-parse --show-toplevel) | grep -E "$to_find" | sort
}
alias gitfind=git-find

git-find-conflicts ()
{
    ##@@ none||none||git-find-conflicts||search git repo files for the opening conflict marker (<<<<<<)
    gitfuncs_audit "$@"

    local opts='-l'
    if [ "$1" != '' ]
    then
        opts="$@"
    fi
    git grep $opts -E '^<<<<<<<' | sort -u
}

git-status-with-changelog ()
{
    ##@@ none||none||git-status-with-changelog||Mix in $GITFUNCS_CHANGELOG_NAME text with correspoding file entries in git status.
    gitfuncs_audit "$@"

    ## All of the *-changelog functions work best in the git-root, which is
    ## where the $GITFUNCS_CHANGELOG_NAME is anyway
    local pwd=$(pwd)
    local gr=$(git-root)
    if [ ! "$pwd" = "$gr" ]
    then
        echo "Current directory ($pwd) is not the git root ($gr)"
        local resp=$(yesno "Go there?")
        if [ "$resp" = 'n' ]
        then
            return 1
        fi
        _git_cd_go $gr  || return $?
    else
        gr=''
    fi

    local usage_func="${FUNCNAME}-usage"
    local diff
    local noless
    OPTSARGS=$(getoptp -o sh --long diff,noless,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --diff) diff='--diff'; shift ;;
            --noless) noless='--noless'; shift ;;
            -h|--help) $usage_func; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    local args="$@"
    if [ -z "$args" ]
    then
        args=$(git-status-parse --all) ## matches default git status setting
    fi
    local out=$(mktemp)
    git-process-changelog --withstatus $diff $noless $args 1>$out 2>&1
    if [ -n "$noless" ]
    then
        cat $out
    else
        less -RE $out
    fi
    \rm -f $out
    status=$?
    [ -n "$gr" ] && _git_cd_return
    return $?
}
alias git-st-cl='git-status-with-changelog '
alias git-st-ch='git-status-with-changelog '

git-commit-with-changelog ()
{
    ##@@ none||none||git-commit-with-changelog||Use $GITFUNCS_CHANGELOG_NAME entries to create commit messages
    gitfuncs_audit "$@"

    ## All of the *-changelog functions work best in the git-root, which is
    ## where the $GITFUNCS_CHANGELOG_NAME is anyway
    local pwd=$(pwd)
    local gr=$(git-root)
    if [ ! "$pwd" = "$gr" ]
    then
        echo "Current directory ($pwd) is not the git root ($gr)"
        local resp=$(yesno "Go there?")
        if [ "$resp" = 'n' ]
        then
            return 1
        fi
        _git_cd_go $gr || return $?
    else
        gr=''
    fi

    local usage_func="${FUNCNAME}-usage"

    local opt_a
    local opt_v

    ## Options first
    OPTSARGS=$(getoptp -o av -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -a)
                opt_a=$1
                shift ;;
            -v)
                opt_v=$1
                shift;;
            -h) $usage_func; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    local files="$@"
    ## This causes the same behavior as git commit with no args (default to
    ## only staged files), but we need to pass files into git-process.
    [ -z "$files" ] && files=$(git-what-is-staged)
    [ -n "$opt_a" ] && files=$(git-what-is-modified)
    git-process-changelog --commit $opt_v $files
    status=$?
    [ -n "$gr" ] && _git_cd_return
    return $status
}

git-process-changelog-usage ()
{
    echo "git-process-changelog [-v] [ --write | [ --withstatus ] [ --diff ]"
    echo "    Only one $GITFUNCS_CHANGELOG_NAME in git root is supported."
}

git-process-changelog ()
{
    ##@@ none||none||git-process-changelog||'Guts' function for *-with-changelog functions
    gitfuncs_audit "$@"

    ## All of the *-changelog functions work best in the git-root, which is
    ## where the $GITFUNCS_CHANGELOG_NAME is anyway
    local pwd=$(pwd)
    local gr=$(git-root)
    if [ ! "$pwd" = "$gr" ]
    then
        _git_cd_go $gr  || return $?
    else
        gr=''
    fi

    local usage_func="${FUNCNAME}-usage"

    local action='read'
    local parse_flag=''
    local diff=''
    local opt_v='' ## passed to commit
    local status=0
    local parsed_cl=$(mktemp)
    local pcl=$(which parse-changelog)
    local pcl_flags=''
    local noless=''

    ## Options first
    OPTSARGS=$(getoptp -o hv --long commit,withstatus,diff,noless,help -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -v) opt_v=$1
                shift;;
            --commit)
                action=commit;
                pcl_flags="$pcl_flags --write --ncl $parsed_cl"
                shift ;;
            --withstatus)
                action=withstatus;
                pcl_flags="$pcl_flags --withstatus";
                shift ;;
            --diff)
                pcl_flags="$pcl_flags --diff"
                shift ;;
            --noless)
                noless=1
                shift ;;
            -h|--help) $usage_func; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    ## Everything else is a file
    if [ -z $1 ]
    then
        echo "No files specified."
        [ -n "$gr" ] && _git_cd_return
        return 1
    fi
    local filelist
    for i in "$@"
    do
        filelist="$filelist $(realpath $i)"
    done

    ## Find the changelog
    local changelogdir=$(git-root)
    if ((status != 0))
    then
        $usage_func
        [ -n "$gr" ] && _git_cd_return
        return $status
    fi

    local changelog="${changelogdir}/$GITFUNCS_CHANGELOG_NAME"
    if [ ! -r $changelog ]
    then
        echo "$changelog not readable"
        [ -n "$gr" ] && _git_cd_return
        return 1
    fi
    if [ "$action" = 'commit' ] && [ ! -w $changelog ]
    then
        echo "$changelog not writable"
        [ -n "$gr" ] && _git_cd_return
        return 1
    fi

    local changelogbkp="${changelog}.bkp"

    local others=$(find $changelogdir -name ChangeLog | grep -v "$changelog")
    if [ -n "$others" ]
    then
        echo "Found $others. No other $GITFUNCS_CHANGELOG_NAME allowed under $changelogdir."
        [ -n "$gr" ] && _git_cd_return
        return 1
    fi

    ## Backup
    cp -f $changelog $changelogbkp

    $DEBUG_PROCESS_CHANGELOG $pcl --cl $changelog $pcl_flags $filelist
    status=$?
    if ((status!=0))
    then
        [ -n "$gr" ] && _git_cd_return
        return $status
    fi

    if [ "$action" = 'commit' ]
    then
        git commit -F $parsed_cl --edit $opt_v $filelist
        status=$?
        if((status!=0))
        then
            ## Restore
            echo "Rolling back $changelog"
            cp -f $changelogbkp $changelog
            [ -n "$gr" ] && _git_cd_return
            return $status
        fi
    fi
    [ -f $changelogbkp ] && \rm -f $changelogbkp
    [ -n "$gr" ] && _git_cd_return

}

git-cat-cl ()
{
    ##@@ none||none||git-cat-cl||'cat' the ChangeLog in the git root
    gitfuncs_audit "$@"

    local cl=$(git-root)/$GITFUNCS_CHANGELOG_NAME
    [ -r $cl ] && cat $cl && return 0
    echo "$cl not found."
    return 1
}

git-strip-repo ()
{
    ##@@ none||none||git-strip-repo||Remove the text '(repo)' from the argument.
    gitfuncs_audit "$@"

    echo $1 | sed 's/(repo)//'
}

git-add-repo-tag ()
{
    ##@@ none||none||git-add-repo-tag||Add the text '(repo)' to the argument.
    gitfuncs_audit "$@"

    echo "$1(repo)"
}

git-go-set ()
{
    ##@@ none||none||git-go-set||
    gitfuncs_audit "$@"

    local set_x=0
    if [ "$GIT-GO-SET_DEBUG" = '1' ]
    then
        set_x=1
        set -x ## set by envvar
    fi
    git-go-set-filename

    local current_git_go_file=$(git-go-get-filename)
    local repo_find_roots
    local search_roots="$gitfuncs_gitroot"
    local addmbig="$1"
    if [ "$addmbig" = '' ]
    then
        grep MBIG $current_git_go_file
        status=$?
        if ((status==0))
        then
            addmbig=1
        fi
    fi
    if [ "$addmbig" = '1' ]
    then
        search_roots="$search_roots $gitfuncs_gitroot_MBIG"
    fi
    for i in $search_roots
    do
        if [ -e $i ]
        then
            repo_find_roots="$repo_find_roots $i"
        fi
    done
    local repo_tops=$(find $repo_find_roots -maxdepth 1 -mindepth 1 -type d -follow)
    ## We can use -maxdepth 3 to speed things up drastically because of the
    ## standard host/repo for devgit, host/namespace/repo for bbgithub and
    ## similarly for other git hosts.
    local finds
    for d in ${HOME}/personal \
                    ${HOME}/.git_template \
                    ${HOME}/.emacs.d \
                    ${HOME}/.emacs.d/taps/mpersico5 \
                    ${HOME}/examples \
                    $repo_tops
    do
        [ -d $d ] && finds="$finds $d"
    done

    local repos=$(find $finds -maxdepth 3 -name .git -type d | sed 's|/.git$||g' | sort -u)

    ## And then we do worktree (wt) search
    local repo
    local wts
    for repo in $repos
    do
        wts="$wts $(find $repo/wt -name .git -type f 2>/dev/null | sed 's|/.git$||g')"
    done

    ## We add $HOME here and set repo_tops_re after we find the repos so that
    ## the two repos in the home dir don't mess everything up.
    local repo_tops_re=":$(echo $repo_tops ${HOME}| sed 's/ /:/g'):"

    local repo_roots=$(local i j
                         for i in $repos $wts
                         do
                             git-add-repo-tag $i
                             j=$i
                             while [ -n "$j" ] && [ "$j" != 'done' ]
                             do
                                 if [ "$j" != "$i" ]
                                 then
                                     echo $j
                                 fi
                                 if [[ $repo_tops_re =~ ":$j:" ]]
                                 then
                                     j='done'
                                 else
                                     j=$(dirname $j)
                                 fi
                                 #for debugging:
                                 if [ $set_x = '1' ]
                                 then
                                     pause 'DEBUG MODE: Hit return to continue: '
                                 fi
                             done
                         done)
    echo $repo_roots $repo_tops | tr ' ' '\n' | sort -u | sed "s|${HOME}/||" > $gitfuncs_git_go_file
    ls ${HOME}/gits/.git-go* | grep -v $gitfuncs_git_go_file | xargs \rm -f
    if [ "$set_x" = '1' ]
    then
        set +x
    fi
}

git-go-set-filename ()
{
    ##@@ none||none||git-go-set-filename||
    gitfuncs_audit "$@"

    gitfuncs_git_go_file=${HOME}/gits/.git-go.$(date +%Y%m%d)
}

git-go-get-filename ()
{
    ##@@ none||none||git-go-get-filename||
    gitfuncs_audit "$@"

    ls -rt ${HOME}/gits/.git-go.* | head -1
}

_git-go-get ()
{
    gitfuncs_audit "$@"

    ## no, we don't need getopt processing here. This is an internal func so we
    ## just have to GET IT RIGHT when we call it.
    local update=$1
    shift
    local roots=$1
    shift
    local mbig=$1
    shift
    local wt=$1
    shift
    local filter=$1
    shift

    git-go-set-filename
    if [ ! -e $gitfuncs_git_go_file ] || ((update))
    then
        git-go-set $mbig
    fi

    local tmpfile=$(mktemp --suffix=._git-go-get)
    cp $gitfuncs_git_go_file $tmpfile

    if ((roots==0))
    then
        cat $tmpfile | grep '(repo)' | sed 's/(repo)//' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((mbig==0))
    then
        cat $tmpfile | grep -v 'MBIG' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((wt==0))
    then
        cat $tmpfile | grep -v '/wt/' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if [ -n "$filter" ]
    then
        cat $tmpfile | grep $filter > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    cat $tmpfile
    \rm -f $tmpfile
}

git-go-usage ()
{
    gitfuncs_audit "$@"

    echo "Usage: git-go [--list[full]] [--update|-u] [--roots|-r] [--mbig|-m] [--wt|--nowt ] [dirmatch]"
    echo "       git-go [-h|--help]"
    echo
    echo "       Presents a list of all git repos"
    echo "       in ${HOME}/gits"
    echo "       for you to choose and then cd to."
    echo
    echo "       --list will skip the choosing part and just exit, printing"
    echo "           each repo dir with ~"
    echo
    echo "       --listfull will skip the choosing part and just exit, printing"
    echo "           each repo dir with ~ expanded"
    echo
    echo "       --update will rescan to pick up new and deleted"
    echo "           repos and worktrees"
    echo
    echo "       --roots will add the non-git directories"
    echo "           where gits live so you can add new repos"
    echo
    echo "       --mbig will add the directories in MBIG"
    echo
    echo "       --wt will add the worktree subdirectories"
    echo "           in repos. This is the default."
    echo "       --nowt will not add them."
    echo
    echo "       'dirmatch' will filter the list"
    echo
}

git-go ()
{
    ##@@ none||none||git-go||
    gitfuncs_audit "$@"

    local PS3="Choose by number, q to quit: "
    local opt_list=0
    local opt_update=0
    local opt_roots=0
    local opt_mbig=0
    local opt_wt=1
    local opt_subwt_only=0
    local OPTSARGS=$(getoptp -o lurmh --long list,update,roots,mbig,wt,nowt,subwt,help,listfull -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && git-go-usage && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -l|--list) opt_list=1; shift ;;
            --listfull) opt_list=2; shift ;;
            -m|--mbig) opt_mbig=1; shift ;;
            -r|--roots) opt_roots=1; shift ;;
            -u|--update) opt_update=1; shift ;;
            --wt) opt_wt=1; shift ;;
            --nowt) opt_wt=0; shift ;;
            --subwt) opt_subwt_only=1; shift ;;
            -h|--help) git-go-usage; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-go-usage; return 1 ;;
        esac
    done

    local REPOS REPO tgt
    tgt=$1
    if [[ "$tgt" =~ /$ ]]
    then
        tgt="$(dirname $tgt)/$(basename $tgt)"
    fi
    REPOS=$(_git-go-get $opt_update $opt_roots $opt_mbig $opt_wt "$tgt")
    if ((opt_subwt_only))
    then
        git-inside-work-tree
        if [ "$?" = '1' ]
        then
            echo "Not in a git repo. Showing all repos."
        else
            local current_repo_full=$(git rev-parse --show-toplevel | sed 's|/wt/.*||')
            local current_repo=$(echo $current_repo_full | sed "s|${HOME}/||")
            if [ ! -d $current_repo_full/wt ]
            then
                echo "No worktrees here. Showing all repos."
            else
                REPOS=$(echo $REPOS | tr ' ' '\n' | grep $current_repo/wt)
            fi
        fi
    fi
    if [ -z "$REPOS" ]
    then
        echo $tgt does not match any repo
        git-go-usage
        return 1
    fi
    if [ "$(echo $REPOS | wc -w)" = '1' ]
    then
        echo "Matches only $REPOS. Going there."
        REPO=$REPOS
    else
        if (($opt_list==1))
        then
            local r
            for r in $REPOS
            do
                echo '~'/$r
            done
        elif (($opt_list==2))
        then
            local r
            for r in $REPOS
            do
                echo ~/$r
            done
        else
            REPOS=$(tail_number_add $REPOS)
            COLUMNS=1 ## One character wide terminal, forces list to be one column.
            select REPO in $REPOS
            do
                if (($opt_list))
                then
                    return
                fi
                if [ -n "$REPO" ]
                then
                    REPO=$(tail_number_strip "$REPO")
                    break
                elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
                then
                    return
                else
                    echo "'$REPLY' is an invalid choice"
                fi
            done
        fi
    fi
    if((!opt_list))
    then
        ## dirlist, not builtin cd to take advantage this cd enhancement
        dirlist ${HOME}/$(git-strip-repo $REPO)
        git-check-this-hook
    fi
    return
}
alias gitgo='git-go '
alias gitog='git-go '
alias gitwt='git-go --subwt '
alias git-list='git-go -l '

git-get-current-branch ()
{
    ##@@ none||none||git-get-current-branch||
    gitfuncs_audit "$@"

    ( if [ -n "$1" ]
      then
          ## dirlist, not builtin cd, to take advantage this cd enhancement
          dirlist $1
      fi
      git rev-parse --abbrev-ref HEAD
    )
}
alias git-get-current-branch='git-get-current-branch '
alias git-branch-get-current='git-get-current-branch '

git-help ()
{
    ##@@ none||none||git-help||
    gitfuncs_audit "$@"

    local tmpfile=$(mktemp --suffix=.git-help)
    ls -c1 $PERSONALBIN/*bbgh* 2>/dev/null | sed 's|.*/|script |' > ${tmpfile}.gh1
    ls -c1 $PERSONALBIN/*git* 2>/dev/null| sed 's|.*/|script |' > ${tmpfile}.gh2
    declare -F | grep git | grep -v _git > ${tmpfile}.gh3

    sort -u ${tmpfile}.gh*
    \rm -f ${tmpfile}.gh*
}

git-rename-branch-usage ()
{
    echo "Usage: git-rename-branch old_branch new_branch"
}

git-rename-branch ()
{
    ##@@ none||none||git-rename-branch||
    gitfuncs_audit "$@"

    if (($#!=2))
    then
        git-rename-branch-usage
        return 1
    fi

    local old_branch=$1; shift
    local new_branch=$1; shift
    if (($#))
    then
        git-rename-branch-usage
        echo "       argument(s) '$*' are illegal"
        return 1
    fi

    echo "git branch -m $old_branch $new_branch ..."
    git branch -m $old_branch $new_branch        || return $? # Rename branch locally.

    echo "git push origin --delete $old_branch ..."
    git push origin --delete $old_branch         || return $? # Delete the old
                                                              # branch. DON'T
                                                              # DO THIS IF YOU
                                                              # HAVE AN OPEN
                                                              # PULL REQUEST!!!

    echo "git push --set-upstream origin $new_branch"
    git push --set-upstream origin $new_branch                # Push the new
                                                              # branch, set
                                                              # local branch to
                                                              # track the new
                                                              # remote.
    return $?
}
alias git-rename-branch='git-rename-branch '
alias git-branch-rename='git-rename-branch '

## I prefer not to delete branches. I'd rather rename them
git-close-branch ()
{
    ##@@ none||none||git-close-branch||
    gitfuncs_audit "$@"

    local old_branch=$1
    if [ -z "$old_branch" ]
    then
        local branchesa=($(git-branch-list))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return
        fi
        local PS3="Choose by number, q to quit: "
        local selected
        COLUMNS=1 ## One character wide terminal, forces list to be one column.
        select selected in ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                old_branch=$selected
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi

    local new_branch=closed/$(date +%Y_%m_%d_%H_%M_%S)/$old_branch
    git-rename-branch $old_branch $new_branch
    status=$?
    ((status != 0)) && return $status

    ## Update with changed branches
    git-go-set
    return $?
}
alias git-close-branch='git-close-branch '
alias git-branch-close='git-close-branch '

git-close-current-branch ()
{
    ##@@ none||none||git-close-current-branch||
    gitfuncs_audit "$@"

    git-close-branch $(git-get-current-branch)
    return $?
}
alias git-close-current-branch=git-close-current-branch
alias git-branch-close-current='git-close-current-branch '

git-delete-branch ()
{
    ##@@ none||none||git-delete-branch||
    gitfuncs_audit "$@"

    local no_remote=0
    if [ "$1" = '--no-remote' ] || [ "$1" = '--local-only' ]
    then
        no_remote=1
        shift;
    fi
    local branch=$1;
    local current_branch=$(git-get-current-branch)
    if [ -z "$branch" ]
    then
        local branchesa=($(git-branch-list))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return 1
        fi
        local PS3="Choose by number, q to quit: "
        local selected
        COLUMNS=1 ## One character wide terminal, forces list to be one column
        select selected in ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo $selected is current. Cannot delete current.
                else
                    branch=$selected
                    break
                fi
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return 0
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi

    if [ -n "$branch" ]
    then
        ## $branch was either $1 or we did not ctrl-c out of the select.
        if [ "$branch" = "$current_branch" ]
        then
            echo "Nope, you can't delete the current branch."
            return 1
        fi
        git branch -d $branch || return $?; ## This could fail. If so, go clean
                                            ## manually. Sometimes you get
                                            ## instructions on how to do that.
        if [ "$no_remote" = '1' ]
        then
            return 0
        fi

        remotes=$(git remote)
        for remote in $remotes
        do
            local inremote=$(git-branch-list -r | grep "$remote/$branch")
            if [ -n "$inremote" ]
            then
                local resp=$(yesno "Try deleting in remote $remote" n)
                if [ "$resp" == 'y' ]
                then
                    git push --delete $remote $branch ## This should not fail
                                                      ## since we have checked
                                                      ## that the branch exists
                                                      ## in the remote.
                fi
            fi
        done
    fi

    ## Update with changed branches
    git-go-set
    return $?
}
alias git-delete-branch='git-delete-branch '
alias git-branch-delete='git-delete-branch '

git-set-locals ()
{
    ##@@ none||none||git-set-locals||
    gitfuncs_audit "$@"

    local localgitpaths='/home/mpersico5/gits/bbgithub/bbgh/bin
                           /home/mpersico5/gits/bbgithub/glow/bin'
    local lgp
    for lgp in ${localgitpaths}
    do
        addpath -f -p PATH $lgp
        echo "Using $lgp ($(git-get-current-branch $lgp))"
    done
}

git-update-this-hook ()
{
    ##@@ none||none||git-update-hook||
    gitfuncs_audit "$@"

    local hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${gitfuncs_githook_dir}/* | grep -v README.md)
    else
        local h
        local newh
        for h in $hooks
        do
            newh="$newh ${gitfuncs_githook_dir}/$h"
        done
        hooks="$newh"
    fi
    local REPOS REPO
    REPOS=$(_git-go-get 0 0 1 0)
    for REPO in $REPOS
    do
        for h in $hooks
        do
           local hookdir="${HOME}/$(git-strip-repo $REPO)/.git/hooks"
           if [ -e "$hookdir/$(basename $h)" ]
           then
               cp -v $h $hookdir
           fi
        done
    done
}

git-push-hook ()
{
    ##@@ none||none||git-push-hook||
    gitfuncs_audit "$@"

    local current_template=$(git config --get init.templatedir)
    if [ "$current_template" != "${gitfuncs_githook_root}" ]
    then
        echo "Error: Config says init.templatedir = '$current_template'"
        echo "       It should be '${gitfuncs_githook_root}'"
        echo "       Please correct."
        return 1
    fi

    if [ ! -d "$current_template" ]
    then
        echo "Error: Can't find '$current_template'"
        echo "       Please correct."
        return 1
    fi

    local hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${gitfuncs_githook_dir}/*)
    else
        local h
        local newh
        for h in $hooks
        do
            newh="$newh ${gitfuncs_githook_dir}/$h"
        done
        hooks="$newh"
    fi

    local REPOS REPO
    REPOS=$(_git-go-get 0 0 1 0 | grep -v ".git_template" )
    for REPO in $REPOS
    do

        echo "== $REPO"
        for h in $hooks
        do
            local hooktgtdir="${HOME}/$(git-strip-repo $REPO)/.git/hooks"
            if [ -f $hooktgtdir ]
            then
                echo $hooktgtdir is a file. whoops....
                ## Fix up accidental directory overwrite
                \rm $hooktgtdir
                mkdir $hooktgtdir
            fi

            local hooktgtpath="$hooktgtdir/$(basename $h)"
            if [ ! -e $hooktgtpath ] || [ $h -nt $hooktgtpath ]
            then
                if [ ! -e $hooktgtpath ]
                then
                    echo "$hooktgtpath not found. Copying from $h..."
                elif [ $h -nt $hooktgtpath ]
                then
                    echo "$hooktgtpath out of date. Updating from $h..."
                fi
                cp -pv $h $hooktgtpath
                chmod +x $hooktgtpath
            elif [ $h -ot $hooktgtpath ]
            then
                local tmpout=$(mktemp)
                diff  $h  $hooktgtpath 1>$tmpout 2>&1
                if [ -s $tmpout ]
                then
                    echo "$hooktgtpath newer than $h. Here's the diff, older to newer:"
                    cat $tmpout
                fi
                rm -f $tmpout
            fi
        done
    done
}

git-check-this-hook ()
{
    ##@@ none||none||git-check-hook||
    gitfuncs_audit "$@"

    local gitloc="./.git"
    if [ -f $gitloc ]
    then
        ## We are probably in a worktree...
        gitloc=$(cat .git | sed 's/.* //')
        gitloc=${gitloc%%/worktrees*}
    fi
    if [ ! -d $gitloc ]
    then
        echo "Cannot run git-check-hook outside base repo dir - can't find .git"
        return 1
    fi
    ret=0
    local hookloc="${gitloc}/hooks"
    for i in $(ls ${hookloc}/* | grep -v '.sample')
    do
        if [ ! -x $i ]
        then
            echo "INFO: git hook $i is not executable. Making it so."
            chmod a+x $i
        fi
    done
    return 0
}

git-checkout ()
{
    ##@@ none||none||git-checkout||
    gitfuncs_audit "$@"

    local newbranch=$1
    local createbranch=''
    if [ -z "$newbranch" ]
    then
        local branchesa=($(git-branch-list))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return 1
        fi
        local current_branch=$(git-get-current-branch)
        local PS3="Choose by number, q to quit: "
        local newonemsg="Create a new one from $current_branch"
        local selected
        COLUMNS=1 ## One character wide terminal, forces list to be one column
        select selected in "'$newonemsg'" ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo "$selected is current. Cannot checkout current."
                elif [ "$selected" == "'$newonemsg'" ]
                then
                    while [ -z "$newbranch" ]
                    do
                        read -p "Enter a new branch name: " newbranch
                    done
                    if [ -d './wt' ]
                    then
                        local resp=$(yesno "As a worktree" y)
                        if [ "$resp" == 'y' ]
                        then
                            builtin cd ./wt || return $?
                            git-worktree-create $newbranch
                            return $?
                        fi
                    fi
                    createbranch='-b'
                else
                    newbranch=$(echo $selected | sed 's|\*||')
                fi
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return 0
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi
    if [ -n "$newbranch" ]
    then
        if [ "$newbranch" = 'help' ]
        then
            echo "Use -help or --help"
            return
        fi
        if [ "$newbranch" = 'info' ]
        then
            git branch -vv
            return
        fi
        git checkout $createbranch $newbranch
        status=$?
        if [ "$status" = '0' ] && [ "$createbranch" = '-b' ]
        then
            echo "Setting upstream..."
            git push --set-upstream origin $newbranch
        fi

        ## Update with changed branches
        git-go-set
        return $?
    fi
    return 0
}
alias git-checkout='git-checkout '
alias git-branches='git-checkout '
alias git-br='git-checkout '
alias gitbr='git-checkout '

declare -A gitfuncs_remotes

git-parse-remote-v ()
{
    ##@@ none||none||git-parse-remote-v||
    gitfuncs_audit "$@"

    gitfuncs_remotes=()
    for i in $( git remote -v | sed -r -e 's/\(.*//' -e 's/ +$//' -e 's/\t/=/' | sort -ru)
    do
        key=${i%=*}
        value=${i#*=}
        gitfuncs_remotes[$key]=$value
    done
}
alias git-parse-remote-v='git-parse-remote-v '

git-check-with-remote-usage ()
{
    echo "Usage: $1 --branch otherBranch [--remote remote] [gitRoot]"
}

git-check-with-remote ()
{
    ##@@ none||none||git-check-with-remote||
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local iam=${FUNCNAME[0]}
    if [ "${FUNCNAME[1]}" = 'git-check-with-master' ]
    then
        iam=git-check-with-master
    fi

    local opt_branch=''
    local opt_remote='origin'
    local opt_bail_on_dirty='0'
    local OPTSARGS=$(getoptp -o hb:r:c --long help,branch:,remote:,bail_on_dirty -n $iam -- "$@")
    status=$?
    ((status != 0)) && $usage_func $iam && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --bail_on_dirty) opt_bail_on_dirty=1; shift;;
            -r|--remote) opt_remote="$2"; shift; shift ;;
            -b|--branch) opt_branch="$2"; shift; shift ;;
            -h|--help) $usage-func $iam; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func $iam; return 1 ;;
        esac
    done

    if [ -z "$opt_branch" ]
    then
        echo "--branch required"
        git-check-with-remote-usage $iam
        return 1
    fi

    local cb=$(git rev-parse --abbrev-ref HEAD)
    status=$?
    ((status != 0 )) && return 1

    if [ "$cb" == '' ]
    then
        cat <<EOF

$iam is used to check your current git repo DEVELOPMENT branch in your local
clone against changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you do not appear to even be in a repo. I'm exiting. Try again in a
proper repo.

EOF
        return 1
    fi

    if [ "$cb" == "$opt_branch" ]
    then
        cat <<EOF

$iam is used to check your current git repo DEVELOPMENT branch in your local
clone against changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you appear to be on branch "${opt_branch}", the branch you want to
sync with. I'm exiting. Get off the branch "${opt_branch}" and onto another
branch Then rerun the command. Or just do a 'git pull' if you really need to
refresh this branch.

EOF
        return 1
    fi

    ## Check the local branch against its origin
    stcheck=$(mktemp --suffix=.git-check-with-remote)
    git status 1>$stcheck 2>&1
    grep "Your branch is up-to-date with 'origin/$cb'." $stcheck 1>/dev/null
    status=$?
    if [ "$status" != '0' ]
    then
        cat $stcheck
        cat <<EOF
Your branch should be up to date with its origin in order to simplify the
check.
EOF
        if ((opt_bail_on_dirty))
        then
            echo Exiting.
            return 1
        else
            local resp=$(yesno "Do you want to continue anyway" n)
            if [ "$resp" == 'n' ]
            then
                return 1
            fi
        fi
    fi

    local ok_to_pull=1
    ((opt_confirm)) && ok_to_pull=0

    ## Now grab the remote branch
    local gflog=$(mktemp)
    git fetch ${opt_remote} ${opt_branch} 2>$gflog
    local rc=$?
    if ((rc))
    then
        cat $gflog
        rm $gflog
        return 1
    fi
    rm $gflog

    ## Log the local branch
    local locallog=$(mktemp --suffix=.git-check-with-remote.locallog)
    git log > $locallog

    ## Log the local copy of the remote branch
    local remotelog=$(mktemp --suffix=.git-check-with-remote.remotelog)
    git log ${opt_remote}/${opt_branch} > $remotelog

    ## Diff 'em
    local difflog=$(mktemp --suffix=.git-check-with-remote.difflog)
    diff $locallog $remotelog 1> $difflog 2>&1

    if [ -s $difflog ]
    then
        if [ "$(cat $difflog | wc -l)" = '10' ] \
               && [ ! "$(grep -E "Merge pull request.*$(git-get-current-branch)" $difflog)" = '' ]
        then
            echo "Only diff to ${opt_remote} is merge pull request."
        else
            echo
            echo "*** git repo: $(pwd)"
            echo "*** Current branch $(git-get-current-branch) and ${opt_remote}/${opt_branch} are not synced:"
            echo
            cat $difflog
        fi
    fi

    rm -f $locallog $remotelog $difflog
    return 0
}

git-check-with-master ()
{
    ##@@ none||none||git-check-with-master||

    git-parse-remote-v
    ## clone-and-fork repos need to check with the master in the canonical
    ## upstream branch.  If there is no 'upstream', then it's probably a clone
    ## only, so check against the master in origin.
    if [ -n "${gitfuncs_remotes[upstream]}" ]
    then
        git-check-with-remote --remote upstream --branch master "$@"
    elif [ -n "${gitfuncs_remotes[origin]}" ]
    then
        git-check-with-remote --remote origin --branch master "$@"
    fi
    return $?
}

git-sync-with-remote-usage ()
{
    echo "Usage: $1 --branch otherBranch [--remote remote] [--confirm]"
    echo "       remoteRepoTag defaults to 'origin'"
}
alias git-sync-with-remote-usage='git-sync-with-remote-usage '

git-sync-with-remote ()
{
    ##@@ none||none||git-sync-with-remote||
    gitfuncs_audit "$@"

    local opt_branch=''
    local opt_remote='origin'
    local opt_confirm='0'
    local opt_stash='0'
    local do_stash='0'

    local iam=${FUNCNAME[0]}
    if [ "${FUNCNAME[1]}" = 'git-sync-with-master' ]
    then
        iam=git-sync-with-master
    fi
    local OPTSARGS=$(getoptp -o hb:r:c --long help,branch:,remote:,confirm -n $iam -- "$@")
    status=$?
    ((status != 0)) && git-sync-with-remote-usage && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--stash) opt_stash=1; shift;;
            -c|--confirm) opt_confirm=1; shift;;
            -r|--remote) opt_remote="$2"; shift; shift ;;
            -b|--branch) opt_branch="$2"; shift; shift ;;
            -h|--help) git-sync-with-remote-usage $iam; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-sync-with-remote-usage $iam; return 1 ;;
        esac
    done

    if [ -z "$opt_branch" ]
    then
        echo "--branch required"
        git-sync-with-remote-usage $iam
        return 1
    fi

    local cb=$(git rev-parse --abbrev-ref HEAD)
    status=$?
    ((status != 0 )) && return 1

    if [ "$cb" == '' ]
    then
        cat <<EOF

$iam is used to keep your current git repo DEVELOPMENT branch in your local
clone in sync with changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you do not appear to even be in a repo. I'm exiting. Try again in a
proper repo.

EOF
        return 1
    fi

    if [ "$cb" == "$opt_branch" ]
    then
        cat <<EOF

$iam is used to keep your current git repo DEVELOPMENT branch in your local
clone in sync with changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you appear to be on branch "${opt_branch}",
the branch you want to sync with. I'm exiting. Get off this branch and onto
another branch. Then rerun the command. Or just do a 'git status' to check this
branch or a 'git pull' if you really need to refresh this branch.

EOF
        return 1
    fi

    ## Stash any modified items before checking and proceeding.
    local needs_stash=$(git-is-staged && git-is-unstaged | wc -w)
    if ((needs_stash))
    then
        if ((opt_stash))
        then
            do_stash=1
        else
            git status
            local resp=$(yesno "Stash" n)
            echo  resp is $rep
            if [ "$resp" = 'n' ]
            then
                echo "Will not proceed without a stash"
                return 1
            else
                do_stash=1
            fi
        fi
    else
        if ((opt_stash))
        then
            echo "stash not needed"
        fi
    fi
    if ((do_stash))
    then
        git stash
        status=$?
        if [ "$status" = '0' ]
        then
            ok_to_pop=1
        else
            return $status
        fi
    fi

    ## Check the local branch against its origin
    stcheck=$(mktemp --suffix=.git-sync-with-remote)
    git status 1>$stcheck 2>&1
    grep "Your branch is up-to-date with 'origin/$cb'." $stcheck 1>/dev/null
    status=$?
    if [ "$status" != '0' ]
    then
        cat $stcheck
        cat <<EOF
Your branch should be up to date with its origin in order to simplify the
rebase.
EOF
        local resp=$(yesno "Do you want to continue anyway" n)
        if [ "$resp" == 'n' ]
        then
            if ((do_stash))
            then
                git stash pop
            fi
            return 0
        fi
    fi

    local ok_to_pull=1
    ((opt_confirm)) && ok_to_pull=0

    git fetch ${opt_remote} ${opt_branch}

    local diffout=$(mktemp --suffix=.gf-syr)
    git diff ...${opt_remote} > $diffout 2>&1
    local diffc=$(cat $diffout | wc -l)
    if ((diffc)) && ((opt_confirm))
    then
        echo "===== diffs ====="
        cat $diffout
        \rm $diffout
    fi

    local logout=$(mktemp --suffix=.gf-syr)
    git log ...${opt_remote} > $logout 2>&1
    local logc=$(cat $logout | wc -l)
    if ((logc)) && ((opt_confirm))
    then
        ((diffc)) && echo
        echo "=====  log  ====="
        cat $logout
        \rm $logout
    fi

    if ((diffc)) || ((logc))
    then
        if ((opt_confirm))
        then
            local resp=$(yesno "Ok to pull" n)
            if [ "$resp" == 'n' ]
            then
                if ((do_stash))
                then
                    git stash pop
                    return 0
                fi
            fi
        fi
    else
        echo "No difference with remote. Exiting."
        if ((do_stash))
        then
            git stash pop
            return 0
        fi
    fi

    git pull --rebase ${opt_remote} ${opt_branch}
    status=$?
    if [ ! "$status" = '0' ]
    then
        cat <<EOF

It appears the pull --rebase was not successful. Assuming the issue was not a
system issue, but rather related to conflicts:

1) Edit each file in conflict, looking for the (partial) conflict marker
   "<<<<<". Once you see the issue, fix the code and save the file.

2) "git add" any files you've changed.

Once any conflicts are resolved, do a "git status". You will see files under
the section "Changes to be committed" if:

1) You fixed any conflicts.

2) There are changes in the branch "${opt_branch}" that need to be added in
   that have no conflicts.

If you see any such files, run "git commit". That will complete the merge into
your branch.

Then push the branch up to your fork so you can submit a pull request.

EOF
        if ((do_stash))
        then
            echo "Leaving stash stashed so a not to further complicate the issue"
        fi
        return 1
    fi

    echo
    echo "pull --rebase successful. Pushing..."
    git push
    status=$?
    if [ "$status" != '0' ]
    then
        resp=$(yesno "'git push' complained. Shall I re-push with --force" n)
        if [ "$resp" = 'y' ]
        then
            git push --force
            status=$?
        fi
    fi

    local ask_pop=0
    if [ ! "$status" = '0' ]
    then
        cat <<EOF
It appears that the git push was not successful and you declined to use --force,
or the --force was also unsuccessful.
EOF
        if ((do_stash))
        then
            cat <<EOF
It may be that you decided not to force the push since you still have work to do,
in which case you will want to pop the latest stash.
EOF
            ask_pop=1
        fi
    fi

    if ((do_stash))
    then
        resp='y'
        if ((ask_pop))
        then
            resp=$(yesno "Shall I pop the last git stash" n)
        fi
        if [ "$resp" = 'y' ]
        then
            git stash pop
            return $?
        fi
    fi

}
alias git-sync-with-remote='git-sync-with-remote '

git-sync-with-master ()
{
    ##@@ none||none||git-sync-with-master||
    gitfuncs_audit "$@"

    local status

    git-parse-remote-v
    ## clone-and-fork repos need to sync with the master in the canonical
    ## upstream branch.  If there is no 'upstream', then it's probably a clone
    ## only, so sync against the master in origin.
    if [ -n "${gitfuncs_remotes[upstream]}" ]
    then
        git-sync-with-remote --remote upstream --branch master "$@"
    elif [ -n "${gitfuncs_remotes[origin]}" ]
    then
        git-sync-with-remote --remote origin --branch master "$@"
    fi
    status=$?

    return $status
}
alias git-update='git-sync-with-master '
alias git-rebase-on-master='git-sync-with-master '

git-diff-faq ()
{
    ##@@ none||none||git-diff-faq||
    gitfuncs_audit "$@"

    cat <<EOF

--- Branch diffing

The trick to diffing two branches is that is must be done locally. Make sure
both branches have been pulled down from their remotes before tyring to use
them in a diff.

diff two branches:
    git diff branch1 branch2

diff current branch vs other branch:
    git diff other

    *Note - the sense of the diff is from the other back to the current, as if
            you typed 'git diff other current' . If you want the diff from
            current to other then use 'git diff current other'

diff specific files between two branches:
    git diff branch1 branch2 -- file [file...]

EOF
}

bbgithub-fork-and-clone ()
{
    ##@@ none||none||bbgithub-fork-and-clone||
    gitfuncs_audit "$@"

    local proto=bbgithub
    if [ -z "$1" ]
    then
        cat <<EOUSAGE
Usage: bbgithub-fork-and-clone namespace repo
       forks $proto:namespace/repo
       to    $proto:$USER/repo
       then clones to 'repo' in a directory path
       ending in $proto/$USER, which must be the pwd.

       If the fork already exists, and all you want
       to do is make a new local clone, run this command
       anyway. It will not re-fork.

EOUSAGE
        return 1
    fi
    local namespace=$1;shift
    local repo=$1;shift
    local cwpath=$(realpath $(pwd))
    local local_namespace=$(basename $cwpath)
    local local_proto=$(basename $(dirname $cwpath))
    if [ "$local_namespace" != "$USER" ] || \
           [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto/$USER"
        echo "You are in $cwpath"
        local shouldbein="$gitfuncs_gitroot/$proto/$USER"
        if [ ! -d $shouldbein ]
        then
            echo "Cannot find '$shouldbein'."
            echo "Correct and re-execute."
            return 1
        else
            local resp=$(yesno "cd to $shouldbein")
            if [ "$resp" = 'n' ]
            then
                echo "Correct and re-execute."
                return 1
            else
                dirlist $shouldbein
            fi
        fi
    fi

    local cmd="glow clone-fork $proto:$namespace/$repo"
    ## does the fork of namespace/repo to user/repo
    ## clones user/repo to repo
    ## does git remote add upstream $proto:namespace/repo
    echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status

    ## dirlist, not builtin cd, to take advantage this cd enhancement
    dirlist $repo
    git remote -v

    ## Check for master. Some repos arrange it so that the default for clones
    ## is other than master.
    master_exists=$(git branch | grep -E '^(\* master|master)$')

    if [ -n "$master_exists" ]
    then
        echo 'Dumping the origin master in favor of the upstream master...'
        echo git checkout -b temp
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -d master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -r -d origin/master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git checkout --track upstream/master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git checkout master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -d temp
        echo status=$?; [ "$status" != '0' ] && return $status
    fi

    echo "Setting up for worktrees..."
    mkdir wt
    ls -ld $(pwd)/wt

    ## Add this repo to the list
    git-go-set
}
alias fork-and-clone-bbgithub='bbgithub-fork-and-clone '

_guts_clone ()
{
    gitfuncs_audit "$@"

    if [ -z "$1" ]
    then
        echo "Usage: _guts_clone proto namespace repo"
        echo "       pwd must match |/proto\$|"
        return 1
    fi

    local proto=$1;shift

    if [ -z "$1" ]
    then
        echo "Usage: ${proto}_clone namespace repo"
        echo "       pwd must match |/$proto\$|"
        return 1
    fi

    local namespace=$1;shift
    local repo=$1;shift
    local cwpath=$(realpath $(pwd))
    local local_proto=$(basename $cwpath)
    if [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto"
        echo "You are in $cwpath"
        local shouldbein="$gitfuncs_gitroot/$proto"
        if [ ! -d $shouldbein ]
        then
            echo "Cannot find '$shouldbein'."
            echo "Correct and re-execute."
            return 1
        else
            local resp=$(yesno "cd to $shouldbein")
            if [ "$resp" = 'n' ]
            then
                echo "Correct and re-execute."
                return 1
            else
                _git_cd_go $shouldbein
            fi
        fi
    fi

    if [ -z "${gitfuncs_gitsvcs[$proto]}" ]
    then
        echo "$proto is unknown. Valid protocols are:${!gitfuncs_gitsvcs[@]}"
        return 1
    fi

    local tgt="$namespace/$repo"
    if [ -e $tgt ]
    then
        local resp=$(yesno "'$tgt' exists. Will not clone over it. Remove it." n)
        [ "$resp" = 'n' ] && return 1
        rm -rf $tgt
    fi

    local cmd="git clone ${gitfuncs_gitsvcs[$proto]}$namespace/$repo $namespace/$repo"
    echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status

    ## dirlist, not builtin cd, to take advantage this cd enhancement
    dirlist $namespace/$repo
    git remote -v

    ## Add this repo to the list
    git-go-set
}

devgit-clone ()
{
    ##@@ none||none||devgit-clone||
    gitfuncs_audit "$@"

    _guts_clone devgit "$@"
}
alias git-clone-devgit='devgit-clone '

bbgithub-clone ()
{
    ##@@ none||none||bbgithub-clone||
    gitfuncs_audit "$@"

    _guts_clone bbgithub "$@"
}
alias git-clone-bbgithub='bbgithub-clone '

github-clone ()
{
    ##@@ none||none||github-clone||
    gitfuncs_audit "$@"

    _guts_clone github "$@"
}
alias git-clone-github='github-clone '

bitbucket-clone ()
{
    ##@@ none||none||bitbucket-clone||
    gitfuncs_audit "$@"

    _guts_clone bitbucket "$@"
}
alias git-clone-bitbucket='bitbucket-clone '

_guts-whack ()
{
    gitfuncs_audit "$@"

    if [ -z "$1" ]
    then
        echo "Usage: _guts-whack proto namespace repo"
        echo "       pwd must match |/proto\$|"
        return 1
    fi

    local proto=$1;shift

    if [ -z "$1" ]
    then
        echo "Usage: ${proto}-whack namespace repo"
        echo "       pwd must match |/$proto\$|"
        return 1
    fi

    local namespace=$1;shift
    repo=$(basename $namespace) ## Trailing / whacking...
    local repo=$1;shift
    repo=$(basename $repo)
    if [ -z "$repo" ]
    then
        echo "Usage: ${proto}-whack namespace repo"
        echo "       Did you namespace/repo?"
        return 1
    fi

    local cwpath=$(realpath $(pwd))
    local local_proto=$(basename $cwpath)
    if [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto"
        echo "You are in $cwpath"
        echo "Correct and re-execute."
        return 1
    fi

    if [ -z "${gitfuncs_gitsvcs[$proto]}" ]
    then
        echo "$proto is unknown. Valid protocols are:${!gitfuncs_gitsvcs[@]}"
        return 1
    fi
    (
        ## subshell to avoid cd issues

        ## Go to what we want to whack, to make sure it's there...
        echo gitgo $proto/$namespace/$repo
        gitgo $proto/$namespace/$repo
        status=$?
        if ((status==0))
        then
            ## ...and make sure it's clean
            dirty=$(git status --porcelain)
            if [ -z "$dirty" ]
            then
                ## We're clean. Whack it.
                builtin cd ..
                pwd
                \rm -r -i $repo
                status=$?
                if ((status==0))
                then
                    ## Remove it from the list of local git repos
                    git-go-set
                fi
            else
                status=1
                git status
            fi
        fi
        return $status
    )
    status=$?
    return $status
}

devgit-whack ()
{
    ##@@ none||none||devgit-whack||
    gitfuncs_audit "$@"

    _guts-whack devgit "$@"
}
alias devgit-whack='devgit-whack '
alias git-whack_devgit='devgit-whack '
alias git-whack-devgit='devgit-whack '

bbgithub-whack ()
{
    ##@@ none||none||bbgithub-whack||
    gitfuncs_audit "$@"

    _guts-whack bbgithub "$@"
}
alias bbgithub-whack='bbgithub-whack '
alias git-whack_bbgithub='bbgithub-whack '
alias git-whack-bbgithub='bbgithub-whack '

github-whack ()
{
    ##@@ none||none||github-whack||
    gitfuncs_audit "$@"

    _guts-whack github "$@"
}
alias github-whack='github-whack '
alias git-whack_github='github-whack '
alias git-whack-github='github-whack '

bitbucket-whack ()
{
    ##@@ none||none||bitbucket-whack||
    gitfuncs_audit "$@"

    _guts-whack bitbucket "$@"
}
alias bitbucket-whack='bitbucket-whack '
alias git-whack_bitbucket='bitbucket-whack '
alias git-whack-bitbucket='bitbucket-whack '

git-what-is-staged ()
{
    ##@@ none||none||git-what-is-staged||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered, staged for commit'
    else
        git-status-parse --staged
    fi
}
alias git-is-staged='git-what-is-staged '
alias git-what-is-committable='git-what-is-staged '
alias git-is-committable='git-what-is-staged '

git-what-is-unstaged ()
{
    ##@@ none||none||git-what-is-unstaged||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered, not staged for commit'
    else
        git-status-parse --unstaged
    fi
}
alias git-is-unstaged='git-what-is-unstaged '

git-what-is-untracked ()
{
    ##@@ none||none||git-what-is-untracked||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files not tracked in the repo'
    else
        git-status-parse --untracked
    fi
}
alias git-is-untracked='git-what-is-untracked '

git-what-is-modified ()
{
    ##@@ none||none||git-what-is-modified||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files altered, both staged and not staged for commit'
    else
        git-status-parse --staged --unstaged
    fi
}
alias git-is-modified='git-what-is-modified '
alias git-is-mod='git-what-is-modified '

git-what-is-unmodified ()
{
    ##@@ none||none||git-what-is-unmodified||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files unaltered, but tracked'
    else
        git-status-parse --unmodified
    fi
}
alias git-is-unmodified='git-what-is-unmodified '

git-what-is-deleted ()
{
    ##@@ none||none||git-what-is-deleted||
    gitfuncs_audit "$@"

    if [ -n "$1" ]
    then
        echo 'Files deleted, both staged and not staged for commit'
    else
        git-status-parse --deleted
    fi
}
alias git-is-deleted='git-what-is-deleted '

git-track-remote-branch ()
{
    ##@@ none||none||git-track-remote-branch||
    gitfuncs_audit "$@"

    local remote=$1
    local branch=$2
    if [ -z "$remote" ] || [ -z "$branch" ]
    then
        echo "Usage: git-track-remote-branch remote branch"
        echo "       Missing one or both arguments"
        return 1
    fi
    git fetch $remote || return $?
    git checkout -b $branch --track $remote/$branch
    return $?
}
alias git-fetch-remote-branch='git-track-remote-branch '

## Useful in prompts (PS1).
git-inside-work-tree ()
{
    ##@@ none||none||git-inside-work-tree||
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift

    local print=$1;shift
    local v=$(git rev-parse  --is-inside-work-tree 2>/dev/null)
    local r=0
    [ "$v" != "true" ] && r=1
    [ "$print" = '-p' ] && echo $v
    return $r ## 0 if in tree, 1 if not
}
safe_func_export git-inside-work-tree
alias git-inside-work-tree='git-inside-work-tree '

git-get-stash-count ()
{
    ##@@ none||none||git-get-stash-count||
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift

    local no0=0; [ "$1" = '-no0' ] && no0=1 && shift;
    local pre=$1;shift
    local post=$1;shift
    git-inside-work-tree $na
    if [ "$?" = '0' ]
    then
        local c=$(git stash list | wc -l)
        ((c==0)) && ((no0)) && return
        echo "${pre}${c}${post}"
    fi
}
safe_func_export git-get-stash-count
alias git-stash-get-count='git-get-stash-count '

git-worktree-create-usage ()
{
    echo "Usage: git-worktree-create branch [remote]"
    echo "       default remote is 'origin'"
}
alias git-create-worktree-usage='git-create-worktree-usage '
alias git-worktree-create-usage='git-create-worktree-usage '

git-worktree-fetch ()
{
    gitfuncs_audit "$@"

    git-worktree-create --fetch "$@"
    return $?
}

git-worktree-create ()
{
    ##@@ none||none||git-worktree-create||
    gitfuncs_audit "$@"

    local verbose=1
    local fetch_existing=0
    local fetch_opt=''
    local status=0
    ## Make sure pwd ends in wt
    if [[ ! "$(pwd)" =~ /wt$ ]]
    then
        if [ -d ./wt ]
        then
            builtin cd ./wt
        else
            echo "* Current directory is $(pwd)."
            echo '* No wt subdir.'
            echo '* Will not manipulate worktrees outside of wt dir. Aborting.'
            return 1
        fi
    fi

    if [ "$1" = '--fetch' ]
    then
        fetch_existing=1
        fetch_opt="-r"
        shift
    fi

    if [ -z "$1" ]
    then
        echo '* Need a branch name to use for the worktree spec.'
        git-worktree-create-usage
        return 1
    fi
    local wt=$1
    shift

    local remote=$1
    [ -n "$remote" ] && shift
    [ -z "$remote" ] && remote=origin
    echo "* Using '$remote' as remote."

    ((verbose)) && echo '* Check for existing worktrees with same name'
    wtdir="$(pwd)/$wt"
    if [ -e $wtdir ]
    then
        echo "* $wtdir already exists. Aborting."
        return 1
    fi

    local wtsubdir=$wt
    local wtbranch=$wt

    ## TODO: Allow for suffix to append to worktree name so you can dup them if
    ## you need to.
    ((verbose)) && echo '* Check for existing branch'
    local create_branch="-b"
    local exists=$(git-branch-list $fetch_opt | grep $wt)
    if [ -n "$exists" ]
    then
        echo "* Branch $wt already exists. Using it."
        create_branch=''
        wtbranch="$wt"
    elif [ "$fetch_existing" = '1' ]
    then
        echo "* Branch $wt does not exist to be fetched."
        return 1
    else
        ## Since this worktree is going to create a branch of the local master,
        ## make sure the local master (where we should be right now) it is up
        ## to date.
        if [ "$(git-get-current-branch)" != 'master' ]
        then
            echo "* Will not create a branch and worktree from a non-master branch"
            return 1
        fi
        echo "* Checking local master, starting point for branch."
        git pull
        status=$?
        ((status)) && return 1 ## assuming the error message will be printed to
                               ## stderr...
    fi

    ## Now create the work tree and create/fetch the branch.
    ((verbose)) && echo "* git worktree add $create_branch $wtsubdir $wtbranch"
    git worktree add $create_branch "$wtsubdir" "$wtbranch"
    status=$?
    if ((status))
    then
        echo "* Aborting."
        return 1
    fi

    ((verbose)) && echo "* cd $wtsubdir"
    ## dirlist, not builtin cd, to take advantage this cd enhancement
    dirlist $wtsubdir

    if [ -n "$create_branch" ]
    then
        ((verbose)) && echo "* git push --set-upstream $remote $wtbranch"
        git push --set-upstream $remote $wtbranch
    else
        cat <<EOF
**** What's the best way to pull the existing branch? Should we:
     1) git push --set-upstream $remote $wtbranch
        even though we did not create the branch and we have
        nothing to push at this time?
     2) git pull
        to get the existing branch contents?
     3) git checkout track -b $remote/$wtbranch
        to track?
     4) Modify the git worktree add command to account
        for branch existance.

     Obviously, we have done none of these. Figure out the best one.
     Then for short term:
        - Do it.
        - $ touch $GITFUNCS_CHANGELOG_NAME;git-go-get

     For long term:
        - Fix git-worktree-create to DTRT.
EOF
    fi

    ## Add a ChangeLog
    touch $GITFUNCS_CHANGELOG_NAME

    ## Add this repo to the list
    git-go-set

    return 0
}
alias git-create-worktree='git-worktree-create '
alias git-worktree='git-worktree-create '
alias git-wt='git-worktree-create '
alias gitwt='git-worktree-create '

git-delete-current-worktree ()
{
    gitfuncs_audit "$@"

    git-delete-worktree "$@" $(pwd)
    status=$?
    return $status
}

git-delete-worktree-usage ()
{
    echo "Usage: $1 [--force] worktree"
}

git-delete-worktree ()
{
    ##@@ none||none||git-delete-worktree||
    gitfuncs_audit "$@"

    local iam=${FUNCNAME[0]}
    if [ "${FUNCNAME[1]}" = 'git-delete-current-worktree' ]
    then
        iam=${FUNCNAME[1]}
    fi

    local usage_func="${FUNCNAME}-usage"
    local opt_force=0
    OPTSARGS=$(getoptp -o sh --long force,help -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func $iam && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -s|--force) opt_force=1; shift ;;
            -h|--help) $usage_func $iam; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func $iam; return 1 ;;
        esac
    done

    local opwd=$(pwd)
    local worktree=$1;
    local worktreefull=$(realpath $1);

    builtin cd $worktreefull

    ##@@ none||none||git-delete-current-worktree||
    ## Make sure we are in a proper worktree.
    if [ ! -f .git ] || [[ ! "$(pwd)" =~ /wt/ ]]
    then
        echo "$worktree is not a proper worktree for deletion"
        return 1
    fi

    ## Check for cleanliness.
    if [ "$(git status --porcelain | wc -l)" != '0' ] || \
           [ "$(git status | grep 'Your branch is' | grep -v 'up-to-date' | wc -l)" != '0' ]
    then
        if((!opt_force))
        then
            git status
            echo
            echo "Will not delete current worktree. Clean worktree or re-run command with --force."
            return 1
        fi
    fi

    ## Current branch
    local current_branch=$(git-get-current-branch)

    ## Confirm
    local current_dir=$(basename $(pwd))
    if [ "$current_branch" != "$current_dir" ]
    then
        echo "Branch '$current_branch' does not match current subdir '$current_dir'."
        echo "I'm bailing; you fix this mess."
        return 1
    fi
    git status
    local rc=$?
    local resp=$(yesno "git status returned $rc. Continue with deletion");
    if [ "$resp" = 'n' ]
    then
        return 0
    fi

    ## Whack it. Start with the current dir.
    local delit=$(basename $(pwd))
    builtin cd ..
    \rm -r $delit; (( $? != 0 )) && echo "Bad rm of ./$delit (from $(pwd)). Aborting." && return 1;

    ## Work our way up to the first non empty dir or the 'wt' dir, whichever we
    ## get to first, and stop deleting.
    while [ "$(basename $(pwd))" != 'wt' ]
    do
        if [ -z "$(ls -A $(pwd))" ]
        then
            #it's empty
            delit=$(basename $(pwd))
            builtin cd ..
            \rm -r $delit; (( $? != 0 )) && echo "Bad rm of ./$delit (from $(pwd)). Aborting." && return 1;
        fi
    done

    ## Now fix the administrative files.
    git worktree prune

    ## Now the take care of the branch.
    local resp=$(pick  "Keep, close or delete associated branch $current_branch" 'k/c/d' '' )
    if [ "$resp" != 'k' ]
    then

        ## Have to be in a git repo to do this.
        while [ "$(basename $(pwd))" != 'wt' ]
        do
            builtin cd ..
        done
        builtin cd ..
        if [ "$resp" = 'd' ]
        then
            git-delete-branch $current_branch
        else
            git-close-branch $current_branch
        fi
    fi

    [ -d $opwd ] && builtin cd ## If $opwd was the worktree directory, it won't
                               ## be there anymore. Stay where we are.

    git-go-set

    return 0
}
alias git-delete-current-worktree='git-delete-current-worktree '
alias git-worktree-delete-current='git-delete-current-worktree '

git-in-a-worktree ()
{
    ##@@ none||none||git-in-a-worktree||
    ## 0 is true!
    gitfuncs_audit "$@"

    [[  "$(pwd)" =~ /wt/ ]]; return $?
}

git-worktree-root ()
{
    ##@@ none||none||git-worktree-root||print the master root where the wt dir is
    gitfuncs_audit "$@"

    local in_a_wt=$(git-in-a-worktree)
    if (( in_a_wt == 1 ))
    then
        echo "Must be in a wt"
        return 1;
    fi

    local files=$(git ls-files)
    if [ -z "$files" ]
    then
        echo "No git files found. Is current dir '$(pwd)' a git repo?"
        return 1;
    fi

    local root=$(pwd);
    root=${root%%/wt*}
    echo $root
}

git-run-precommit-hook ()
{
    ##@@ none||none||git-run-precommit-hook||
    gitfuncs_audit "$@"

    local hookroot
    local in_a_wt=$(git-in-a-worktree)
    if (( in_a_wt == 0 ))
    then
        hookroot=$(git-worktree-root)
    else
        hookroot=$(git-root)
    fi

    ${hookroot}/.git/hooks/pre-commit $*
}

git-worktree-diff-to-root ()
{
    ##@@ none||none||git-worktree-diff-to-root||diff worktree file against root file
    gitfuncs_audit "$@"

    local in_a_wt=$(git-in-a-worktree)
    if (( in_a_wt == 1 ))
    then
        echo "Must be in a wt"
        return 1;
    fi

    local files=$(git ls-files)
    if [ -z "$files" ]
    then
        echo "No git files found. Is current dir '$(pwd)' a git repo?"
        return 1;
    fi

    local root=$(pwd);
    root=${root%%/wt*}
    for i in $files
    do
        if [ "$1" = '--reverse' ]
        then
            git --no-pager diff --no-index --color=always ${root}/$i $i 2>&1
        else
            git --no-pager diff --no-index --color=always $i ${root}/$i 2>&1
        fi
    done | less -RE
}

git-worktree-diff-from-root ()
{
    ##@@ none||none||git-worktree-diff-rom-root||diff root file against worktree file
    gitfuncs_audit "$@"

    git-worktree-diff-to-root --reverse "$@"
    return $?
}


git-add-remote-usage ()
{
    cat <<EOF
usage: git-add-remote proto namespace"
       Adds proto:namespace/current_repo"
       as a remote named 'namespace'."
       Use this to get at people's"
       branches on a repo fork."
EOF
}

git-add-remote ()
{
    ##@@ none||none||git-add-remote||
    gitfuncs_audit "$@"

    if [ "$#" != '2' ]
    then
        git-add-remote-usage; return 1
    fi
    local proto=$1; shift
    local remote=$1; shift
    current_repo=$(git-get-current-repo-name)
    git remote add $remote $proto:$remote/$current_repo
    local $status=$?
    if (( $status == 0 ))
    then
        git remote -v | grep $remote
    fi
    return $status
}
alias git-remote-add='git_add_remote'

alias git-remotes='git remote -v '

git-state ()
{
    ##@@ none||none||git-state||
    gitfuncs_audit "$@"

    (echo
    echo "=== Latest log entry:"
    git log -1
    echo
    echo "=== Status:"
    local short=$(git-st-ext)
    [ -n "$short" ] && echo "--- Short: $short"
    echo "--- Long:"
    git-st-cl --noless "$@") | less -RE
}
alias git-st='git-state '

git-get-current-repo-name ()
{
    ##@@ none||none||git-get-current-repo-name||
    gitfuncs_audit "$@"

    git remote -v | grep origin | sed 's|.*/||' | sed 's/ .*//' | sort -u
}

git-branch-list ()
{
    ##@@ none||none||git-branch-list||
    gitfuncs_audit "$@"

    local strip=1
    local remote=''
    local OPTSARGS=$(getoptp -o r --long strip,nostrip,remote -n $FUNCNAME -- "$@")
    status=$?
    ((status != 0)) && echo "Exiting." && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -r | --remote) remote='-r'; shift;;
            --strip) strip=1; shift;;
            --nostrip) strip=0; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; return 1 ;;
        esac
    done

    ## Update the local branches with remote
    git remote update

    local opts="--list --no-color $remote"
    if ((strip))
    then
        git branch $opts | sed 's/.* //'
    else
        git branch $opts
    fi

}

git-logg ()
{
    ##@@ none||none||git-logg||
    gitfuncs_audit "$@"

    git log --all --graph --pretty=format:'%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
}

alias git-clean='git clean -e wt/ '

git-restore ()
{
    ##@@ none||none||git-restore||
    gitfuncs_audit "$@"

    echo "Use 'git log' to find the id of the revision that contains"
    echo "the prior version of the file you want to revert to."
    echo "Then execute 'git checkout theGitID the/file/to/revert'."
}
alias git-revert='git-restore '

git-find-deleted ()
{
    ##@@ none||none||git-find-deleted||The revision in which the given file was deleted.
    gitfuncs_audit "$@"

    git rev-list -n 1 HEAD -- "$1"
}

git-find-last-existed ()
{
    ##@@ none||none||git-find-last-existed||The revision before which the given file was deleted.
    gitfuncs_audit "$@"

    git rev-list -n 1 $(git-find-deleted "$1")^ -- "$1"
}

git-checkout-last-existed()
{
    ##@@ none||none||git-checkout-last-existed||Find the revision in which the given file last existed and check it out
    gitfuncs_audit "$@"

    git checkout $(git-find-last-existed "$1") "$1"
}

git-stdout-last-existed()
{
    ##@@ none||none||git-checkout-last-existed||Find the revision in which the given file last existed and print to stdout (or file.uuid if --file specified).
    gitfuncs_audit "$@"

    local file=''
    if [ "$1" = '-file' ]
    then
        file='-file'
        shift;
    fi
    for f in "$@"
    do
        git-to-stdout $file $(git-find-last-existed "$f") "$f"
    done
}

git-root ()
{
    ##@@ none||none||git-root||
    gitfuncs_audit "$@"; local na; [ "$1" = "-na" ] && na='-na' && shift

    git rev-parse --show-toplevel
}

git-gui ()
{
    ##@@ none||none||git-gui||
    gitfuncs_audit "$@"

    git gui "$@" &
}

alias gitgui='git-gui '

git-pull-with-checkpoint ()
{
    ##@@ none||none||git-pull-with-checkpoint||Write a file with the current UUID before pulling updates.
    gitfuncs_audit "$@"

    git log -1 > $(git-root).git-pull-checkpoint
    git pull "$@"
}

git-diff-to-checkpoint ()
{
    ##@@ none||none||git-diff-to-checkpoint||Diff the current state of the local repo against the state as it was stored in git-pull-with-checkpoint
    gitfuncs_audit "$@"

    local oldid=$(grep $(git-root).git-pull-checkpoint| head -1 | sed 's/commit//')
    local newid=$(git log -1 | head -1 | sed 's/commit//')
    git diff $oldid $newid
}

git-to-stdout-usage ()
{
    echo 'Usage: git-to-stdout [--file] uuid objectname [objectname...]'
    echo '       From the version specified by "uuid" print the objects'
    echo '       requested to stdout. "objectname" must be fully quailifed'
    echo '       from the repo root, not current directory. If --file'
    echo '       is specified, then write to file to objectname.uuid instead'
}

git-to-stdout ()
{
    ##@@ none||none||git-to-stdout||Equivalent of cvs -p. Provide a uuid and one or more path/to/file arguments.
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    OPTSARGS=$(getoptp -o hf --long help,file -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    local file=0
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) $usage_func; return 0 ;;
            -f|--file) file=1; shift ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    if (($# < 2 ))
    then
        $usage_func
        return 1
    fi

    local uuid=$1;shift
    for i in $@
    do
        if ((file))
        then
            echo ${i}.${uuid}
            git show ${uuid}:${i} > $(git-root)/${i}.${uuid}
        else
            git show ${uuid}:${i};
        fi
    done
}

bbgithub-merge-pull-request ()
{
    ##@@ none||none||bbgithub-merge-pull-request||Merge a bbgithub remote pull request from command line.
    git-merge-pull-request bbgithub "$@"
    return $?
}

git-merge-pull-request ()
{
    ##@@ none||none||git-merge-pull-request||Merge a remote pull request from command line.
    gitfuncs_audit "$@"

    if [ -z "$1" ]
    then
        echo "Usage: git-merge-pull-request protocol org repo user prbranch"
        echo "       Merge the branch 'prbranch' from user/repo"
        echo "       into the 'master' branch in a local clone of"
        echo "       org/repo. The clone is created fresh; if there is"
        echo "       already a clone at that location, it will fail."
        echo "       'protocol' is one of 'bbgithub', 'github', 'bitbucket"
        return 1
    fi
    local proto=$1;shift
    if [ -z "${gitfuncs_gitsvcs[$proto]}" ]
    then
        echo "$proto is unknown. Valid protocols are:${!gitfuncs_gitsvcs[@]}"
        return 1
    fi

    if [ -z "$1" ]
    then
        echo "Usage: ${proto}-merge-pull-request org repo user prbranch"
        echo "       Merge the branch 'prbranch' from user/repo"
        echo "       into the 'master' branch in a local clone of"
        echo "       org/repo."
        echo
        echo "       ${proto}-merge-pull-request org repo prbranch"
        echo "       Merge the branch 'prbranch' from org/repo"
        echo "       into the 'master' branch in a local clone of"
        echo "       org/repo. WARNING - INCOMPLETE IMPLEMENTATION"
        echo "       as of 2016-06-15"
        echo
        echo "       In either case, the updated clone is examined"
        echo "       and the user is asked to push the updated"
        echo "       local master branch back up to the origin."
        echo
        echo "       Note: The local clone is reconstituted"
        echo "             each time."
        return 1
    fi

    local namespace=$1;shift
    local repo=$1;shift
    local user
    local prbranch
    local mergesrc

    if [ "$#" = '2' ]
    then
        echo "Merging from branch in other repo"
        user=$1;shift
        prbranch=$1;shift
        merge_src='remote'
    elif [ "$#" = '1' ]
    then
        echo "Merging from branch in this repo"
        local prbranch=$1;shift
        merge_src='origin'
    fi

    echo "* Clone $proto:$namepsace/repo..."
    ${proto}-clone $namespace $repo
    local status=$?
    ((status)) && return $status

    echo "****** Current last commit on master branch"
    git log -1
    status=$?
    ((status)) && return $status
    echo "****** ************************************"

    if [ "$merge_src" = 'remote' ]
    then
        echo "* Add $proto:$user/$repo as a remote"
        git remote add $user $proto:$user/$repo
        status=$?
        ((status)) && return $status

        echo "* Fetch only the pull request branch ($prbranch) from $proto:$user/$repo"
        git fetch $user $prbranch
        status=$?
        ((status)) && return $status

        echo "* Do the merge"
        git rebase master $user/$prbranch
        status=$?
        ((status)) && return $status

        echo "****** Last two commits on master"
        git log -2
        status=$?
        ((status)) && return $status
        echo "****** **************************"

        echo "Success is defined as"
        echo "1) You are reading this message."
        echo "2) The second log entry from 'Last two commits on master'"
        echo "   should match then entry from 'Current last commit on master branch'."
        echo
    else
        echo "* Fetch only the pull request branch ($prbranch) from $proto:$namespace/$repo"
        git fetch $proto:$namespace/$repo $prbranch
        status=$?
        ((status)) && return $status

        echo "* Do the merge"
        git rebase master origin/$prbranch
        status=$?
        ((status)) && return $status
        git checkout master

        pause 'Go to another terminal, do a git log and see what you got. Then quit this, come back and fix the code accordingly.'
        ## INSERT SOME git log comparison instructions here!!!!!!
        return 1
    fi

    local resp=$(yesno "Should push back up to ${proto} with 'git push origin HEAD:master'")
    local retval
    if [ "$resp" = 'y' ]
    then
        pwd
        git push origin HEAD:master
        retval=$?
    else

        echo "Ok. Remember to 'git push origin HEAD:master' soon before the master head advances."
        retval=0
    fi
}
alias git-merge-pr='git-merge-pull-request '

git-meta ()
{
    ##@@ none||none||git-meta||Read or write meta information for a branch
    gitfuncs_audit "$@"

    local usage_func="${FUNCNAME}-usage"
    local branch=$(git rev-parse --abbrev-ref HEAD)
    OPTSARGS=$(getoptp -o b: --long branch: -n $FUNCNAME -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --branch-b) branch=$2; shift; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    local key=$1
    if [ -z "$key" ]
    then
        echo Need a key to save
        return 1
    fi

    shift
    local value="$@"

    if [ -z "$value" ]
    then
        ## Read existing key
        git config --get "branch.${branch}.${key}"
    else
        git config "branch.${branch}.${key}" "$value"
    fi
}

git-st-ext ()
{
    ##@@ none||none||git-st-ext||Read or write a note about this fork's current status
    gitfuncs_audit "$@"

    local git_st_ext_file="$(git-root)/.git-st-ext"
    if [ -e $git_st_ext_file ]
    then
        local oldstat=$(cat $git_st_ext_file)
        \rm $git_st_ext_file
        git-meta local-status "$oldstat"
    fi

    if [ -n "$@" ]
    then
        git-meta local-status "$@"
    else
        git-meta local-status
    fi
}

git-st-ext-all ()
{
    ##@@ none||none||git-st-ext||Read all notes about repo current statuses
    gitfuncs_audit "$@"

    for i in $(git-go --listfull)
    do
        ( builtin cd $i
          local s=$(git-st-ext)
          [ -n "$s" ] && echo $i - $s
        )
    done
}

git-delete-current-repo ()
{
    gitfuncs_audit "$@"

    git-delete-repo $(pwd)
    status=$?
    return $status
}

git-delete-repo ()
{
    ##@@ none||none||git-delete-repo||Delete the repo
    gitfuncs_audit "$@"

    local opwd=$(pwd)
    local repo=$1;
    local repofull=$(realpath $1);

    builtin cd $repofull

    ## Make sure we are in a proper repo.
    if [ ! -d .git ]
    then
        echo "$repo is not a proper repo for deletion"
        return 1
    fi

    ## Make sure it's clean.
    if [ -d wt ]
    then
        echo "wt subdir found:"
        ls -la wt
        echo
        echo "Will not delete current repo"
        return 1
    fi

    git status 1>/dev/null 2>&1
    local rc=$?
    if ((rc)) || \
           [ "$(git status --porcelain | wc -l)" != '0' ] || \
           [ "$(git status | grep 'Your branch is' | grep -v 'up-to-date' | wc -l)" != '0' ]
    then
        git status
        echo
        echo "Will not delete current repo"
        return 1
    fi

    ## Whack it. Start and end with the current dir.
    local delit=$(basename $(pwd))
    builtin cd ..
    \rm -rf $delit; (( $? != 0 )) && echo "Bad rm of ./$delit (from $(pwd)). Aborting." && return 1;
    echo "Done. Not touching remote repo."

    [ -d $opwd ] && builtin cd ## If $opwd was the repo directory, it won't be
                               ## there anymore. Stay where we are.

    git-go-set

    return 0
}

_git_cd_go ()
{
    local tgt=$(realpath $1)
    local src=$(pwd)
    builtin cd $tgt && apush GITFUNCS_OLDPWDS "$src" ## Push only if we can get
                                                     ## to the target
    return $?

}

_git_cd_return ()
{
    local tgt=$(apop GITFUNCS_OLDPWDS) ## We pop no matter what so bad dirs are
                                       ## cleared from the stack and we don't
                                       ## get stuck on them.
    [ -n "$tgt" ] && builtin cd $tgt
    return $?
}

_git_cd_unwind ()
{
    local tgt=$(ashift GITFUNCS_OLDPWDS)
    if [ -n "$tgt" ]
    then
        ## We pop no matter what so bad dirs are cleared from the stack and we
        ## don't get stuck on them.
        aclear GITFUNCS_OLDPWDS && builtin cd $tgt
    fi
    return $?
}

## Can't use local outside a function.
typeset forlater='

in order to keep my scripts separate from the main repo

git_create_orphan_branch ()
{
ASUD RAHMAN
14:48:14 git checkout --orphan <new branch>
14:48:22 creates a new branch that is disconnected from the other branches
14:48:40 then you can do git checkout -b <work branch> followed by git merge <new branch>
14:49:00 <work branch> will now contain the stuff you normally have plus the stuff you put in <new branch>
MATTHEW PERSICO
14:52:54 I will try that.
- git checkout --orphan myTools
- *write theTools *
- git commit the theTools
Then do as above. If I need to update any of theTools, I think I would
- finish the current branch work, and commit only those file, not theTools
- git checkout myTools
- git commit theTools

I will try this out. Thanks.

--orphan <new_branch>

Create a new orphan branch, named <new_branch>, started from <start_point> and
switch to it. The first commit made on this new branch will have no parents and
it will be the root of a new history totally disconnected from all the other
branches and commits.

The index and the working tree are adjusted as if you had previously run "git
checkout <start_point>". This allows you to start a new history that records a
set of paths similar to <start_point> by easily running "git commit -a" to make
the root commit.

This can be useful when you want to publish the tree from a commit without
exposing its full history. You might want to do this to publish an open source
branch of a project whose current tree is "clean", but whose full history
contains proprietary or otherwise encumbered bits of code.

If you want to start a disconnected history that records a set of paths that is
totally different from the one of <start_point>, then you should clear the
index and the working tree right after creating the orphan branch by running
"git rm -rf ." from the top level of the working tree. Afterwards you will be
ready to prepare your new files, repopulating the working tree, by copying them
from elsewhere, extracting a tarball, etc.
}
alias git-create-orphan-branch=''git_create_orphan_branch ''

'
