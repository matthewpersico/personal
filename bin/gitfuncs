# -*- sh -*-

# gitfuncs

GITFUNCS_FILE=${BASH_SOURCE[0]}

auditfuncs_init $GITFUNCS_FILE

gitfuncs_edit ()
{
    gitfuncs_audit "$@"
    xo $GITFUNCS_FILE
}
## I define functions with '_' and aliases with '-' because the emaacs modes
## that parse for functions to generate jump lists don't see functions with '-'
## in their name. Ugh.
alias gitfuncs-edit=gitfuncs_edit

gitfuncs_reload ()
{
    gitfuncs_audit "$@"
    . $GITFUNCS_FILE
}
alias gitfuncs-reload=gitfuncs_reload

mpersico5_gitroot_MBIG=${HOME}/MBIG
mpersico5_gitroot=${HOME}/gits
mpersico5_githook_root=${HOME}/.git_template
mpersico5_githook_dir=${HOME}/.git_template/hooks

## This will be checked on each login and any time gitfuncs_reload is run. It's
## only ever executed when logging into a vm just after creation.
if [ ! -e $mpersico5_gitroot ]
then
    echo "gits dir not set up. Setting up..."

    mkdir -vp $mpersico5_gitroot/devgit
    mkdir -vp $mpersico5_gitroot/bbgithub
    cat <<EOF >>$mpersico5_gitroot/README
This directory level indicates which git system is being used.  Currently, only
devgit and bbgithub should be here.
EOF

    mkdir -vp $mpersico5_gitroot/bbgithub/mpersico5
    cat <<EOF >>$mpersico5_gitroot//bbgithub/README
This directory level indicates git repo organization.  If we are using the
fork/clone methodology, then the only 'organization' at this level should
be mpersico5, unless you have directly cloned a 'master' repo.
EOF
fi

_git_st_strip_usage ()
{
    gitfuncs_audit "$@"
    echo "Usage: git-st-strip [arg ...]"
    echo "       git-st-strip [--help|-h]"
    echo
    echo "       Runs 'git status -s' and removes the leading"
    echo "       status indicators"
    echo
    echo "       'arg' is any argument you would normally"
    echo "       pass to 'git status'. If you pass options,"
    echo "       behavior is undefined."
}
alias _git-st-strip-usage=_git_st_strip_usage

git_st_strip ()
{
    gitfuncs_audit "$@"
    typeset OPTSARGS=$(getopt -o h --long help -n 'git-st-strip' -- "$@")
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) _git-st-strip-usage; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-st-strip-usage; return 1 ;;
        esac
    done

    git status -s "$@" | sed 's/.* //'
}
alias git-st-strip=git_st_strip

git_find ()
{
    gitfuncs_audit "$@"
    if [ "$#" = '0' ]
    then
        git ls-files
    else
        git ls-files | grep "$@"
    fi
}
alias git-find=git_find
alias gitfind=git_find

git_find_conflicts ()
{
    gitfuncs_audit "$@"
    git grep -l "<<<<<<<" | sort -u
}

alias git_grep='git grep '
alias git-grep='git grep '
alias gitgrep='git grep '

git_find_changelogs ()
{
    gitfuncs_audit "$@"

    typeset i
    typeset potentials
    for i in "$@"
    do
        if [ -e $i ]
        then
            potentials="$potentials $i"
        fi
        ## Else the arg might be a commit arg passed in.
    done

    if [ -z "$potentials" ]
    then
        potentials=$(git_what_can_be_committed)
    fi

    if [ -z "$potentials" ]
    then
        echo "Nothing to commit."
        return 1
    fi

    typeset -A changelogs ## assoc array with realpath expansion will eliminate
                          ## dups, if any
    typeset key
    typeset clcount=0
    for i in $potentials
    do
        if [ -f $i ] && [ -f "$(dirname $i)/ChangeLog" ]
        then
            key=$(realpath $(dirname $i)/ChangeLog)
            changelogs[$key]=$key
            (( clcount += 1 ))
        elif [ -d $i ]
        then
            for j in $(find $i -name ChangeLog)
            do
                key=$(realpath $j)
                changelogs[$key]=$key
                (( clcount += 1 ))
            done
        fi
    done

    echo ${changelogs[@]}
}

git_join_changelogs ()
{
    gitfuncs_audit "$@"

    typeset f=git.commit.$$
    echo "## Delete all lines if you want to abort - :q! won't work." > $f
    echo "## Enter a summary line:" >> $f
    echo '' >> $f
    echo '' >> $f
    echo 'Details:' >> $f

    typeset changelogs=$(git_find_changelogs "$@")
    if [ -n "$changelogs" ]
    then
	    cat $changelogs | grep -v mpersico5 | sed 's/\t//g' >> $f
    else
	    echo "## No ChangeLogs found" >> $f
    fi
    echo $f
}

git_preview_changelogs ()
{
    gitfuncs_audit "$@"
    typeset masterCl=$(git_join_changelogs "$@")
    less $masterCl
    rm -f $masterCl
}

alias git-preview-changelogs='git_preview_changelogs '

git_commit_with_changelog ()
{
    gitfuncs_audit "$@"
    typeset changelogs=$(git_find_changelogs)
    typeset masterCl=$(git_join_changelogs "$@")
    git commit -F $masterCl --edit "$@"
    typeset status=$?
    if ((status==0))
    then
	    \rm $changelogs $masterCl
    fi
}
alias git-commit-with-changelog=git_commit_with_changelog

git_strip_repo ()
{
    gitfuncs_audit "$@"
    echo $1 | sed 's/(repo)//'
}

git_add_repo_tag ()
{
    gitfuncs_audit "$@"
    echo "$1(repo)"
}

git_go_set ()
{
    gitfuncs_audit "$@"
    local set_x=0
    if [ "$GIT_GO_SET_DEBUG" = '1' ]
    then
        set_x=1
        set -x
    fi
    git_go_set_filename
    echo "Regenerating .git-go ($mpersico5_git_go_file)..." >&2

    local repo_find_roots
    for i in $mpersico5_gitroot $mpersico5_gitroot_MBIG
    do
        if [ -e $i ]
        then
            repo_find_roots="$repo_find_roots $i"
        fi
    done
    local repo_tops=$(find $repo_find_roots -maxdepth 1 -mindepth 1 -type d -follow)
    local repos=$(find ${HOME}/personal ${HOME}/.git_template $repo_tops -name .git -type d | sed 's|/.git$||g' | sort -u)

    ## We add $HOME here and set repo_tops_re after we find the repos so that
    ## the two repos in the home dir don't mess everything up.
    typeset repo_tops_re=":$(echo $repo_tops ${HOME}| sed 's/ /:/g'):"

    typeset repo_roots=$(typeset i j
                         for i in $repos
			             do
                             git_add_repo_tag $i
			                 j=$i
			                 while [ -n "$j" ] && [ "$j" != 'done' ]
			                 do
                                 if [ "$j" != "$i" ]
                                 then
                                     echo $j
                                 fi
				                 if [[ $repo_tops_re =~ ":$j:" ]]
				                 then
				                     j='done'
				                 else
				                     j=$(dirname $j)
				                 fi
                                 #for debugging:
                                 if [ $set_x = '1' ]
                                 then
                                     pause 'DEBUG MODE: Hit return to continue: '
                                 fi
			                 done
			             done)
    echo $repo_roots $repo_tops | tr ' ' '\n' | sort -u | sed "s|${HOME}/||" > $mpersico5_git_go_file
    ls ${HOME}/gits/.git-go* | grep -v $mpersico5_git_go_file | xargs rm -f
    if [ "$set_x" = '1' ]
    then
        set +x
    fi
}
alias git-go-set=git_go_set

git_go_set_filename ()
{
    gitfuncs_audit "$@"
    mpersico5_git_go_file=${HOME}/gits/.git-go.$(date +%Y%m%d)
}
alias git-go-set-filename=git_go_set_filename

_git_go_get()
{
    gitfuncs_audit "$@"
    ## no, we don't need getopt processing here. This is an internal func so we
    ## just have to GET IT RIGHT when we call it.
    typeset update=$1
    shift
    typeset roots=$1
    shift
    typeset mbig=$1
    shift
    typeset filter=$1
    shift
    git-go-set-filename
    if [ ! -e $mpersico5_git_go_file ] || ((update))
    then
	    git-go-set
    fi

    local tmpfile=$(mktemp)
    cp $mpersico5_git_go_file $tmpfile

    if ((roots==0))
    then
        cat $tmpfile | grep '(repo)' | sed 's/(repo)//' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((mbig==0))
    then
        cat $tmpfile | grep -v 'MBIG' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if [ -n "$filter" ]
    then
        cat $tmpfile | grep $filter > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    cat $tmpfile
    rm -f $tmpfile
}

git_go_usage ()
{
    gitfuncs_audit "$@"
    echo "Usage: git-go [--update|-u] [--roots|-r] [--mbig|-m] [dirmatch]"
    echo "       git-go [-h|--help]"
    echo
    echo "       Presents a list of all git repos"
    echo "       in ${HOME}/gits"
    echo "       for you to choose and then cd to."
    echo
    echo "       --roots will add the non-git directories"
    echo "           where gits live so you can add new repos"
    echo
    echo "       --mbig will add the directories in MBIG"
    echo
    echo "       'dirmatch' will filter the list"
    echo
}
alias git-go-usage=git_go_usage

git_go ()
{
    gitfuncs_audit "$@"
    typeset PS3="Choose by number, q to quit: "
    typeset opt_update=0
    typeset opt_roots=0
    typeset opt_mbig=0
    typeset OPTSARGS=$(getopt -o urmh --long update,roots,mbig,help -n 'git-go' -- "$@")
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -m|--mbig) opt_mbig=1; shift ;;
            -r|--roots) opt_roots=1; shift ;;
            -u|--update) opt_update=1; shift ;;
            -h|--help) git-go-usage; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-go-usage; return 1 ;;
        esac
    done

    typeset REPOS REPO
    REPOS=$(_git_go_get $opt_update $opt_roots $opt_mbig "$1")
    if [ -z "$REPOS" ]
    then
        echo $1 does not match any repo
        git_go_usage
        return
    fi
    if [ "$(echo $REPOS | wc -w)" = '1' ]
    then
        echo "Matches only $REPOS. Going there."
        REPO=$REPOS
    else
        select REPO in $REPOS
        do
	        if [ -n "$REPO" ]
	        then
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
	        fi
        done
    fi
    ## cd, not builtin cd to take advantage of any cd enhancements that
    ## are in effect (via a cd alias or a cd script in PATH)
	cd ${HOME}/$(git_strip_repo $REPO)
    git_hook_check
	return
}
alias git-go=git_go
alias gitgo=git_go
alias gitog=git_go

git_get_current_branch ()
{
    gitfuncs_audit "$@"
    ( if [ -n "$1" ]
      then
          ## cd, not builtin cd to take advantage of any cd enhancements that
          ## are in effect (via a cd alias or a cd script in PATH)
          cd $1
      fi
      git rev-parse --abbrev-ref HEAD
    )
}
export -f git_get_current_branch
alias git-get-current-branch=git_get_current_branch

git_help ()
{
    gitfuncs_audit "$@"
    local tmpfile=$(mktemp)
    ls -c1 $PERSONALBIN/*bbgh* 2>/dev/null | sed 's|.*/|script |' > ${tmpfile}.gh1
    ls -c1 $PERSONALBIN/*git* 2>/dev/null| sed 's|.*/|script |' > ${tmpfile}.gh2
    declare -F | grep git | grep -v _git > ${tmpfile}.gh3

    sort -u ${tmpfile}.gh*
    \rm -f ${tmpfile}.gh*
}
alias git-help=git_help

git_rename_branch ()
{
    gitfuncs_audit "$@"
    typeset old_branch=$1
    shift
    typeset new_branch=$2
    shift
    if (($#))
    then
        echo "Usage: git-rename-branch old_branch new_branch=$2"
        echo "       argument(s) '$*' are illegal"
        return 1
    fi

    git branch -m $old_branch $new_branch        || return $? # Rename branch locally.

    git push origin :$old_branch                 || return $? # Delete the old
                                                              # branch. DON'T
                                                              # DO THIS IF YOU
                                                              # HAVE AN OPEN
                                                              # PULL REQUEST!!!

    git push --set-upstream origin $new_branch                # Push the new
                                                              # branch, set
                                                              # local branch to
                                                              # track the new
                                                              # remote.
    return $?
}
alias git-rename-branch=git_rename_branch

git_close_branch ()
{
    gitfuncs_audit "$@"
    typeset old_branch=$1
    typeset new_branch=closed/$(date +%Y_%m_%d_%H_%M_%S)/$old_branch
    git-rename-branch $old_branch $new_branch
    return $?
}
alias git-close-branch=git_close_branch

git_delete_branch ()
{
    gitfuncs_audit "$@"
    local branch=$1;
    local current_branch=$(git_get_current_branch)
    if [ -z "$branch" ]
    then
        local branchesa=($(git branch --list | sed 's/.* //' ))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return
        fi
        typeset PS3="Choose by number, q to quit: "
        typeset selected
        select selected in ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                branch=$selected
                break;
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi

    if [ -n "$branch" ]
    then
        ## it was either $1 or we did not ctrl-c out of the select
        if [ "$branch" = "$current_branch" ]
        then
            echo "Nope, you can't delete the current branch."
            return
        fi
        git branch -d $branch || return $?;
        remotes=$(git remote)
        for remote in $remotes
        do
            local inremote=$(git branch --list -r | grep "$remote/$branch")
            if [ -n "$inremote" ]
            then
                local resp=$(yesno "Try deleting in remote $remote" n)
                if [ "$resp" == 'y' ]
                then
                    git branch -r -d $remote/$branch ## This should not fail
                                                     ## since we have checked
                                                     ## that the branch exists
                                                     ## in the remote
                fi
            fi
        done
    fi
    return 0
}
alias git-delete-branch=git_delete_branch

git_set_locals ()
{
    gitfuncs_audit "$@"
    typeset localgitpaths='/home/mpersico5/gits/bbgithub/bbgh/bin
                           /home/mpersico5/gits/bbgithub/glow/bin'
    typeset lgp
    for lgp in ${localgitpaths}
    do
        addpath -f -p PATH $lgp
        echo "Using $lgp ($(git-get-current-branch $lgp))"
    done
}
alias git-set-locals=git_set_locals

git_hook_update ()
{
    gitfuncs_audit "$@"
    typeset hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${mpersico5_githook_dir}/* | grep -v README.md)
    else
        typeset h
        typeset newh
        for h in $hooks
        do
            newh="$newh ${mpersico5_githook_dir}/$h"
        done
        hooks="$newh"
    fi
    typeset REPOS REPO
    REPOS=$(_git_go_get 0 0 1)
    for REPO in $REPOS
    do
        for h in $hooks
        do
           typeset hookdir="${HOME}/$(git_strip_repo $REPO)/.git/hooks"
           if [ -e "$hookdir/$(basename $h)" ]
           then
               cp -v $h $hookdir
           fi
        done
    done
}
alias git-hook-update='git_hook_update '

git_hook_push ()
{
    gitfuncs_audit "$@"
    git init --template=${mpersico5_githook_root}
    typeset hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${mpersico5_githook_dir}/*)
    else
        typeset h
        typeset newh
        for h in $hooks
        do
            newh="$newh ${mpersico5_githook_dir}/$h"
        done
        hooks="$newh"
    fi

    typeset REPOS REPO
    REPOS=$(_git_go_get 0 0 1)
    for REPO in $REPOS
    do
        for h in $hooks
        do
            typeset hooktgtdir="${HOME}/$(git_strip_repo $REPO)/.git/hooks"
            if [ -f $hooktgtdir ]
            then
                echo $hooktgtdir is a file. whoops....
                ## Fix up accidental directory overwrite
                \rm $hooktgtdir
                mkdir $hooktgtdir
            fi

            typeset hooktgtpath="$hooktgtdir/$(basename $h)"
            if [ ! -e $hooktgtpath ] || [ $h -nt $hooktgtpath ]
            then
                if [ ! -e $hooktgtpath ]
                then
                    echo "$hooktgtpath not found. Copying from $h..."
                elif [ $h -nt $hooktgtpath ]
                then
                    echo "$hooktgtpath out of date. Updating from $h..."
                fi
                cp -v $h $hooktgtpath
                chmod +x $hooktgtpath
            fi
        done
    done
}

git_hook_check ()
{
    gitfuncs_audit "$@"
    if [ ! -d .git ]
    then
        echo "Cannot run git_hook_check outside base repo dir - can't find .git"
        return 1
    fi
    ret=0
    for i in $(ls .git/hooks/* | grep -v '.sample')
    do
        if [ ! -x $i ]
        then
            echo "INFO: git hook $i is not executable. Making it so."
            chmod a+x $i
        fi
    done
    return 0
}

git_checkout ()
{
    gitfuncs_audit "$@"
    local newbranch=$1
    local createbranch=''
    if [ -z "$newbranch" ]
    then
        local tmpfile=$(mktemp)
        git branch | sed 's|\* |*|' > $tmpfile
        typeset branch
        typeset current_branch=$(grep '*' $tmpfile)
        local PS3="Choose by number, q to quit: "
        local newonemsg="Create a new one from $current_branch"
        select branch in "'$newonemsg'" $(cat $tmpfile)
        do
            if [ -n "$branch" ]
            then
                if [ "$branch" == "$current_branch" ]
                then
                    echo $branch is current.
                elif [ "$branch" == "'$newonemsg'" ]
                then
                    while [ -z "$newbranch" ]
                    do
                        read -p "Enter a new branch name: " newbranch
                    done
                    createbranch='-b'
                else
                    newbranch=$(echo $branch | sed 's|\*||')
                fi
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi
    if [ -n "$newbranch" ]
    then
        git checkout $createbranch $newbranch
        status=$?
        if [ "$status" = '0' ] && [ "$createbranch" = '-b' ]
        then
            echo "Setting upstream..."
            git push --set-upstream origin $newbranch
        fi
    fi
}

alias git-checkout='git_checkout '
alias git-branches='git_checkout '

git_sync_with_master ()
{
    gitfuncs_audit "$@"
    local cb=$(git rev-parse --abbrev-ref HEAD)
    status=$?
    if ((status != 0 ))
    then
        return 1
    fi

    if [ "$cb" == '' ]
    then
        cat <<EOF

git_sync_with_master is used to keep your git repo DEVELOPMENT branch in your
local clone in sync with changes to the upstream "master" branch. However, you
do not appear to even be in a repo. I'm exiting. Try again in a proper repo.

EOF
        return 1
    fi

    if [ "$cb" == 'master' ]
    then
        cat <<EOF

git_sync_with_master is used to keep your git repo DEVELOPMENT branch in your
local clone in sync with changes to the upstream "master" branch. However, you
appear to be on the "master", not a DEVELOPMENT branch, so what the hell are
you doing? I'm exiting. Get off the "master" and onto a DEVELOPMENT
branch. Then rerun the command.

EOF
        return 1
    fi

    stcheck=$(mktemp)
    git status 1>$stcheck 2>&1
    grep "Your branch is up-to-date with 'origin/$cb'." $stcheck 1>/dev/null
    status=$?
    if [ "$status" != '0' ]
    then
        cat $stcheck
        cat <<EOF
Your branch should be up to date with its origin in order to simplify the
rebase. Make it so and then rerun the command.
EOF
        return 1
    fi

    cat <<EOF

In the current local repo, we are going to

  git pull --rebase upstream master

which will "replay" you existing changes as if you originally branched from the
current tip of the master branch, not the prior one.

Working...

EOF
    sleep 2
    git pull --rebase upstream master
    status=$?
    if [ "$status" = '0' ]
    then
        echo
        echo "pull --rebase successful. Do not forget to git push,"
        echo "prossibly needing --force, by try without first."
        return 0
    else
        cat <<EOF

It appears the pull --rebase was not successful. Assuming the issue was not a
system issue, but rather related to conflicts:

1) Edit each file in conflict, looking for the (partial) conflict marker
   "<<<<<". Once you see the issue, fix the code and save the file.

2) "git add" any files you've changed.

Once any conflicts are resolved, do a "git status". You will see files under
the section "Changes to be committed" if:

1) You fixed any conflicts.

2) There are changes in the "master" that need to be added in that have no
   conflicts.

If you see any such files, run "git commit". That will complete the merge into
your branch.

Then push the branch up to your fork so you can submit a pull request.

EOF

        return 1
    fi

}

alias git-update='git_sync_with_master '
alias git-sync-with-master='git_sync_with_master '
alias git-rebase-on-master='git_sync_with_master '

git_diff_faq ()
{
    gitfuncs_audit "$@"
    cat <<EOF

--- Branch diffing

The trick to diffing two branches is that is must be done locally. Make sure
both branches have been pulled down from their remotes before tyring to use
them in a diff.

diff two branches:
    git diff branch1 branch2

diff current branch vs other branch:
    git diff other

    *Note - the sense of the diff is from the other back to the current, as if
            you typed 'git diff other current' . If you want the diff from
            current to other then use 'git diff current other'

diff specific files between two branches:
    git diff branch1 branch2 -- file [file...]

EOF
}

alias git-diff-faq=git_diff_faq

bbgithub_fork_and_clone ()
{
    gitfuncs_audit "$@"
    local proto=bbgithub
    local namespace=$1;shift
    local repo=$1;shift
    local cwpath=$(realpath $(pwd))
    local local_namespace=$(basename $cwpath)
    local local_proto=$(basename $(dirname $cwpath))
    if [ "$local_namespace" != "$USER" ] || \
           [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto/$USER"
        echo "You are in $cwpath"
        echo "Correct and re-execute."
        return 1
    fi

    local cmd="glow clone-fork $proto:$namespace/$repo"
    ## does the fork of namespace/repo to user/repo
    ## clones user/repo to repo
    ## does git remote add upstream bbgithub:namespace/repo
    echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status

    cd $repo
    git remote -v

    ## Check for master. Some repos arrange it so that the default for clones
    ## is other than master.
    master_exists=$(git branch | grep -E '^(\* master|master)$')

    if [ -n "$master_exists" ]
    then
        echo 'Dumping the origin master in favor of the upstream master...'
        echo git checkout -b temp
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -d master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -r -d origin/master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git checkout --track upstream/master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git checkout master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -d temp
        echo status=$?; [ "$status" != '0' ] && return $status
    fi

    ## Add this repo to the list
    git_go_set
}

_guts_clone ()
{
    gitfuncs_audit "$@"
    local proto=$1;shift
    local namespace=$1;shift
    local repo=$1;shift
    local cwpath=$(realpath $(pwd))
    local local_proto=$(basename $cwpath)
    if [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto"
        echo "You are in $cwpath"
        echo "Correct and re-execute."
        return 1
    fi

    local cmd="git clone $proto:$namespace/$repo $namespace/$repo"
    echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status

    cd $namespace/$repo
    git remote -v

    ## Add this repo to the list
    git_go_set
}

devgit_clone ()
{
    gitfuncs_audit "$@"
    _guts_clone devgit "$@"
}

bbgithub_clone ()
{
    gitfuncs_audit "$@"
    _guts_clone bbgithub "$@"
}

git_what_is_modified ()
{
    gitfuncs_audit "$@"
    ## $1 used to specify a particular dir.
    echo
    git status $1 | grep modified: | sed 's/.*modified://' | sed 's/ //g'
}
alias git-what-is-modified='git_what_is_modified '

git_what_can_be_committed ()
{
    gitfuncs_audit "$@"    ## Get the top level of the current repo
    typeset tl=$(git rev-parse --show-toplevel)

    typeset potentials
    ## Figure out what could be committed from the current state of the repo.
    ## $(git st --porcelain -uno)
    potentials=$(git st -v | grep -- 'diff --git' | cut -d' ' -f 4 | sed 's|b/||')

    typeset f
    typeset files
    typeset dirs
    for f in $potentials
    do
        if [ -f $f ]
        then
            files="$files $f"
        elif [ -d $f ]
        then
            dirs="$dirs $f"
            files="$files $(find $f -type f)"
        fi
    done
    echo "$dirs $files" | tr ' ' '\n' | uniq
}

alias git-what-can-be-committed='git_what_can_be_committed '
alias git-what-is-committable='git_what_can_be_committed '



local forlater='

git_create_orphan_branch()
{
ASUD RAHMAN
14:48:14 git checkout --orphan <new branch>
14:48:22 creates a new branch that is disconnected from the other branches
14:48:40 then you can do git checkout -b <work branch> followed by git merge <new branch>
14:49:00 <work branch> will now contain the stuff you normally have plus the stuff you put in <new branch>
MATTHEW PERSICO
14:52:54 I will try that.
- git checkout --orphan myTools
- *write theTools *
- git commit the theTools
Then do as above. If I need to update any of theTools, I think I would
- finish the current branch work, and commit only those file, not theTools
- git checkout myTools
- git commit theTools

I will try this out. Thanks.

--orphan <new_branch>

Create a new orphan branch, named <new_branch>, started from <start_point> and
switch to it. The first commit made on this new branch will have no parents and
it will be the root of a new history totally disconnected from all the other
branches and commits.

The index and the working tree are adjusted as if you had previously run "git
checkout <start_point>". This allows you to start a new history that records a
set of paths similar to <start_point> by easily running "git commit -a" to make
the root commit.

This can be useful when you want to publish the tree from a commit without
exposing its full history. You might want to do this to publish an open source
branch of a project whose current tree is "clean", but whose full history
contains proprietary or otherwise encumbered bits of code.

If you want to start a disconnected history that records a set of paths that is
totally different from the one of <start_point>, then you should clear the
index and the working tree right after creating the orphan branch by running
"git rm -rf ." from the top level of the working tree. Afterwards you will be
ready to prepare your new files, repopulating the working tree, by copying them
from elsewhere, extracting a tarball, etc.
}

'
