# -*- sh -*-

# git1funcs

GITFUNCS_FILE=${BASH_SOURCE[0]}

auditfuncs_init $GITFUNCS_FILE

gitfuncs_edit ()
{
    gitfuncs_audit "$@"
    xo $GITFUNCS_FILE
}
export -f gitfuncs_edit
## I define functions with '_' and aliases with '-' because the emacs modes
## that parse for functions to generate jump lists don't see functions with '-'
## in their name. Ugh.
alias gitfuncs-edit=gitfuncs_edit

gitfuncs_reload ()
{
    gitfuncs_audit "$@"
    . $GITFUNCS_FILE
}
export -f gitfuncs_reload
alias gitfuncs-reload=gitfuncs_reload

gitfuncs_gitroot_MBIG=${HOME}/MBIG
gitfuncs_gitroot=${HOME}/gits
gitfuncs_githook_root=${HOME}/.git_template
gitfuncs_githook_dir=${HOME}/.git_template/hooks
declare -A gitfuncs_gitsvcs
gitfuncs_gitsvcs[bbgithub]='bbgithub:'
gitfuncs_gitsvcs[devgit]='devgit:'
gitfuncs_gitsvcs[github]='https://github.com/'
gitfuncs_gitsvcs[bitbucket]='https://bitbucket.org/'

## This will be checked on each login and any time gitfuncs_reload is run. It's
## only ever executed when logging into a vm just after creation.
if [ ! -e $gitfuncs_gitroot ]
then
    echo "gits dir not set up. Setting up..."

    mkdir -vp $gitfuncs_gitroot/devgit
    mkdir -vp $gitfuncs_gitroot/bbgithub
    mkdir -vp $gitfuncs_gitroot/github
    mkdir -vp $gitfuncs_gitroot/bitbucket
    cat <<EOF >>$gitfuncs_gitroot/README
This directory level indicates which git system is being used.  Currently, only
devgit, bbgithub, github, and bitbucket should be here.
EOF

    mkdir -vp $gitfuncs_gitroot/bbgithub/mpersico5
    mkdir -vp $gitfuncs_gitroot/github/matthewpersico
    mkdir -vp $gitfuncs_gitroot/bitbucket/matthew_persico
    cat <<EOF >>$gitfuncs_gitroot//bbgithub/README
This directory level indicates git repo organization.  If we are using the
fork/clone methodology, then the only 'organization' at this level should
be your own namespace, unless you have directly cloned a 'master' repo.
EOF
fi

##
## Random aliases
##
alias gitpush='git push '
alias gitk="$(which gitk | tail -1 | sed 's/ +//') &"
alias git_grep='git grep '
alias git-grep='git grep '
alias gitgrep='git grep '

##
## Goodies
###
_git_st_strip_usage ()
{
    gitfuncs_audit "$@"
    echo "Usage: git-st-strip [arg ...]"
    echo "       git-st-strip [--help|-h]"
    echo
    echo "       Runs 'git status -s' and removes the leading"
    echo "       status indicators"
    echo
    echo "       'arg' is any argument you would normally"
    echo "       pass to 'git status'. If you pass options,"
    echo "       behavior is undefined."
}
export -f _git_st_strip_usage
alias _git-st-strip-usage=_git_st_strip_usage

git_st_strip ()
{
    gitfuncs_audit "$@"
    local OPTSARGS=$(getopt -o h --long help -n 'git-st-strip' -- "$@")
    status=$?
    ((status != 0)) && _git_st_strip_usage && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) _git-st-strip-usage; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-st-strip-usage; return 1 ;;
        esac
    done

    git status -s "$@" | sed 's/.* //'
}
export -f git_st_strip
alias git-st-strip=git_st_strip

git_find ()
{
    gitfuncs_audit "$@"
    if [ "$#" = '0' ]
    then
        git ls-files
    else
        git ls-files | grep "$@"
    fi
}
export -f git_find
alias git-find=git_find
alias gitfind=git_find

git_find_conflicts ()
{
    gitfuncs_audit "$@"
    local opts='-l'
    if [ "$1" != '' ]
    then
        opts="$@"
    fi
    git grep $opts -E '^<<<<<<<' | sort -u
}
export -f git_find_conflicts
alias git-find-conflicts='git_find_conflicts '

git_find_changelogs ()
{
    gitfuncs_audit "$@"

    local i
    local potentials
    for i in "$@"
    do
        if [ -e $i ]
        then
            potentials="$potentials $i"
        fi
        ## Else the arg might be a commit arg passed in.
    done

    if [ -z "$potentials" ]
    then
        potentials=$(git_what_can_be_committed)
    fi

    if [ -z "$potentials" ]
    then
        echo "Nothing to commit."
        return 1
    fi

    local -A changelogs ## assoc array with realpath expansion will eliminate
                          ## dups, if any
    local key
    local clcount=0
    for i in $potentials
    do
        if [ -f $i ] && [ -f "$(dirname $i)/ChangeLog" ]
        then
            key=$(realpath $(dirname $i)/ChangeLog)
            changelogs[$key]=$key
            (( clcount += 1 ))
        elif [ -d $i ]
        then
            for j in $(find $i -name ChangeLog)
            do
                key=$(realpath $j)
                changelogs[$key]=$key
                (( clcount += 1 ))
            done
        fi
    done

    echo ${changelogs[@]}
}
export -f git_find_changelogs
alias git-find-changelogs='git_find_changelogs '

git_join_changelogs ()
{
    gitfuncs_audit "$@"

    local f=git.commit.$$
    echo "## Delete all lines if you want to abort - :q! won't work." > $f
    echo "## Enter a summary line:" >> $f
    echo '' >> $f
    echo '' >> $f
    echo 'Details:' >> $f

    local changelogs=$(git_find_changelogs "$@")
    if [ -n "$changelogs" ]
    then
        cat $changelogs | grep -v mpersico5 | sed 's/\t//g' >> $f
    else
        echo "## No ChangeLogs found" >> $f
    fi
    echo $f
}
export -f git_join_changelogs
alias git-join-changelogs='git_join_changelogs '

git_preview_changelogs ()
{
    gitfuncs_audit "$@"
    local masterCl=$(git_join_changelogs "$@")
    less $masterCl
    \rm -f $masterCl
}
export -f git_preview_changelogs
alias git-preview-changelogs='git_preview_changelogs '

git_commit_with_changelog ()
{
    gitfuncs_audit "$@"
    local changelogs=$(git_find_changelogs)
    local masterCl=$(git_join_changelogs "$@")
    git commit -F $masterCl --edit "$@"
    local status=$?
    if ((status==0))
    then
        \rm $changelogs $masterCl
    fi
}
export -f git_commit_with_changelog
alias git-commit-with-changelog=git_commit_with_changelog

git_strip_repo ()
{
    gitfuncs_audit "$@"
    echo $1 | sed 's/(repo)//'
}
export -f git_strip_repo
alias git-strip-repo='git_strip_repo '

git_add_repo_tag ()
{
    gitfuncs_audit "$@"
    echo "$1(repo)"
}
export -f git_add_repo_tag
alias git-add-repo-tag='git_add_repo_tag '

git_go_set ()
{
    gitfuncs_audit "$@"
    local set_x=0
    if [ "$GIT_GO_SET_DEBUG" = '1' ]
    then
        set_x=1
        set -x
    fi
    git_go_set_filename
    echo "Regenerating .git-go ($gitfuncs_git_go_file)..." >&2

    local repo_find_roots
    local search_roots="$gitfuncs_gitroot"
    local addmbig="$1"
    if [ "$addmbig" = '' ]
    then
        grep MBIG $gitfuncs_git_go_file
        status=$?
        if ((status==0))
        then
            addmbig=1
        fi
    fi
    if [ "$addmbig" = '1' ]
    then
        search_roots="$search_roots $gitfuncs_gitroot_MBIG"
    fi
    for i in $search_roots
    do
        if [ -e $i ]
        then
            repo_find_roots="$repo_find_roots $i"
        fi
    done
    local repo_tops=$(find $repo_find_roots -maxdepth 1 -mindepth 1 -type d -follow)
    ## We can use -maxdepth 3 to speed things up drastically because of the
    ## standard host/repo for devgit, host/namespace/repo for bbgithub and
    ## similarly for other git hosts.
    local repos=$(find ${HOME}/personal ${HOME}/.git_template $repo_tops -maxdepth 3 -name .git -type d | sed 's|/.git$||g' | sort -u)

    ## And then we do worktree (wt) search
    local repo
    local wts
    for repo in $repos
    do
        wts="$wts $(find $repo/wt -name .git -type f 2>/dev/null | sed 's|/.git$||g')"
    done

    ## We add $HOME here and set repo_tops_re after we find the repos so that
    ## the two repos in the home dir don't mess everything up.
    local repo_tops_re=":$(echo $repo_tops ${HOME}| sed 's/ /:/g'):"

    local repo_roots=$(local i j
                         for i in $repos $wts
                         do
                             git_add_repo_tag $i
                             j=$i
                             while [ -n "$j" ] && [ "$j" != 'done' ]
                             do
                                 if [ "$j" != "$i" ]
                                 then
                                     echo $j
                                 fi
                                 if [[ $repo_tops_re =~ ":$j:" ]]
                                 then
                                     j='done'
                                 else
                                     j=$(dirname $j)
                                 fi
                                 #for debugging:
                                 if [ $set_x = '1' ]
                                 then
                                     pause 'DEBUG MODE: Hit return to continue: '
                                 fi
                             done
                         done)
    echo $repo_roots $repo_tops | tr ' ' '\n' | sort -u | sed "s|${HOME}/||" > $gitfuncs_git_go_file
    ls ${HOME}/gits/.git-go* | grep -v $gitfuncs_git_go_file | xargs \rm -f
    if [ "$set_x" = '1' ]
    then
        set +x
    fi
}
export -f git_go_set
alias git-go-set=git_go_set

git_go_set_filename ()
{
    gitfuncs_audit "$@"
    gitfuncs_git_go_file=${HOME}/gits/.git-go.$(date +%Y%m%d)
}
export -f git_go_set_filename
alias git-go-set-filename=git_go_set_filename

_git_go_get ()
{
    gitfuncs_audit "$@"
    ## no, we don't need getopt processing here. This is an internal func so we
    ## just have to GET IT RIGHT when we call it.
    local update=$1
    shift
    local roots=$1
    shift
    local mbig=$1
    shift
    local wt=$1
    shift
    local filter=$1
    shift

    git-go-set-filename
    if [ ! -e $gitfuncs_git_go_file ] || ((update))
    then
        git-go-set $mbig
    fi

    local tmpfile=$(mktemp)
    cp $gitfuncs_git_go_file $tmpfile

    if ((roots==0))
    then
        cat $tmpfile | grep '(repo)' | sed 's/(repo)//' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((mbig==0))
    then
        cat $tmpfile | grep -v 'MBIG' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if ((wt==0))
    then
        cat $tmpfile | grep -v '/wt/' > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    if [ -n "$filter" ]
    then
        cat $tmpfile | grep $filter > ${tmpfile}.001
        mv ${tmpfile}.001 ${tmpfile}
    fi

    cat $tmpfile
    \rm -f $tmpfile
}
export -f _git_go_get

git_go_usage ()
{
    gitfuncs_audit "$@"
    echo "Usage: git-go [--update|-u] [--roots|-r] [--mbig|-m] [--wt|--nowt ] [dirmatch]"
    echo "       git-go [-h|--help]"
    echo
    echo "       Presents a list of all git repos"
    echo "       in ${HOME}/gits"
    echo "       for you to choose and then cd to."
    echo
    echo "       --roots will add the non-git directories"
    echo "           where gits live so you can add new repos"
    echo
    echo "       --mbig will add the directories in MBIG"
    echo
    echo "       --wt will add the worktree subdirectories"
    echo "           in repos. This is the default."
    echo "       --nowt will not add them."
    echo
    echo "       'dirmatch' will filter the list"
    echo
}
export -f git_go_usage
alias git-go-usage=git_go_usage

git_go ()
{
    gitfuncs_audit "$@"
    local PS3="Choose by number, q to quit: "
    local opt_update=0
    local opt_roots=0
    local opt_mbig=0
    local opt_wt=1
    local opt_subwt_only=0
    local OPTSARGS=$(getopt -o urmh --long update,roots,mbig,wt,nowt,subwt,help -n 'git-go' -- "$@")
    status=$?
    ((status != 0)) && git_go_usage && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -m|--mbig) opt_mbig=1; shift ;;
            -r|--roots) opt_roots=1; shift ;;
            -u|--update) opt_update=1; shift ;;
            --wt) opt_wt=1; shift ;;
            --nowt) opt_wt=0; shift ;;
            --subwt) opt_subwt_only=1; shift ;;
            -h|--help) git-go-usage; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-go-usage; return 1 ;;
        esac
    done

    local REPOS REPO tgt
    tgt=$1
    if [[ "$tgt" =~ /$ ]]
    then
        tgt="$(dirname $tgt)/$(basename $tgt)"
    fi

    REPOS=$(_git_go_get $opt_update $opt_roots $opt_mbig $opt_wt "$tgt")
    if ((opt_subwt_only))
    then
        git_inside_work_tree
        if [ "$?" = '1' ]
        then
            echo "Not in a git repo. Showing all repos."
        else
            local current_repo_full=$(git rev-parse --show-toplevel | sed 's|/wt/.*||')
            local current_repo=$(echo $current_repo_full | sed "s|${HOME}/||")
            if [ ! -d $current_repo_full/wt ]
            then
                echo "No worktrees here. Showing all repos."
            else
                REPOS=$(echo $REPOS | tr ' ' '\n' | grep $current_repo/wt)
            fi
        fi
    fi
    if [ -z "$REPOS" ]
    then
        echo $tgt does not match any repo
        git_go_usage
        return
    fi
    if [ "$(echo $REPOS | wc -w)" = '1' ]
    then
        echo "Matches only $REPOS. Going there."
        REPO=$REPOS
    else
        REPOS=$(tail_number_select $REPOS)
        select REPO in $REPOS
        do
            if [ -n "$REPO" ]
            then
                REPO=$(tail_number_strip "$REPO")
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi
    ## cd, not builtin cd to take advantage of any cd enhancements that
    ## are in effect (via a cd alias or a cd script in PATH)
    cd ${HOME}/$(git_strip_repo $REPO)
    git_check_hook
    return
}
export -f git_go
alias git-go='git_go '
alias gitgo='git_go '
alias gitog='git_go '
alias gitwt='git_go --subwt '

git_get_current_branch ()
{
    gitfuncs_audit "$@"
    ( if [ -n "$1" ]
      then
          ## cd, not builtin cd to take advantage of any cd enhancements that
          ## are in effect (via a cd alias or a cd script in PATH)
          cd $1
      fi
      git rev-parse --abbrev-ref HEAD
    )
}
export -f git_get_current_branch
alias git-get-current-branch='git_get_current_branch '
alias git-branch-get-current='git_get_current_branch '
alias git_branch_get_current='git_get_current_branch '

git_help ()
{
    gitfuncs_audit "$@"
    local tmpfile=$(mktemp)
    ls -c1 $PERSONALBIN/*bbgh* 2>/dev/null | sed 's|.*/|script |' > ${tmpfile}.gh1
    ls -c1 $PERSONALBIN/*git* 2>/dev/null| sed 's|.*/|script |' > ${tmpfile}.gh2
    declare -F | grep git | grep -v _git > ${tmpfile}.gh3

    sort -u ${tmpfile}.gh*
    \rm -f ${tmpfile}.gh*
}
export -f git_help
alias git-help=git_help

git_rename_branch_usage()
{
    echo "Usage: git-rename-branch old_branch new_branch"
}

git_rename_branch ()
{
    gitfuncs_audit "$@"
    if (($#!=2))
    then
        git_rename_branch_usage
        return 1
    fi

    local old_branch=$1; shift
    local new_branch=$1; shift
    if (($#))
    then
        git_rename_branch_usage
        echo "       argument(s) '$*' are illegal"
        return 1
    fi

    echo "git branch -m $old_branch $new_branch ..."
    git branch -m $old_branch $new_branch        || return $? # Rename branch locally.

    echo "git push origin --delete $old_branch ..."
    git push origin --delete $old_branch         || return $? # Delete the old
                                                              # branch. DON'T
                                                              # DO THIS IF YOU
                                                              # HAVE AN OPEN
                                                              # PULL REQUEST!!!

    echo "git push --set-upstream origin $new_branch"
    git push --set-upstream origin $new_branch                # Push the new
                                                              # branch, set
                                                              # local branch to
                                                              # track the new
                                                              # remote.
    return $?
}
export -f git_rename_branch
alias git-rename-branch='git_rename_branch '
alias git-branch-rename='git_rename_branch '
alias git_branch_rename='git_rename_branch '

## I prefer not to delete branches. I'd rather rename them
git_close_branch ()
{
    gitfuncs_audit "$@"
    local old_branch=$1
    if [ -z "$old_branch" ]
    then
        local branchesa=($(git_branch_list))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return
        fi
        local PS3="Choose by number, q to quit: "
        local selected
        select selected in ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                old_branch=$selected
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi

    local new_branch=closed/$(date +%Y_%m_%d_%H_%M_%S)/$old_branch
    git-rename-branch $old_branch $new_branch
    return $?
}
export -f git_close_branch
alias git-close-branch='git_close_branch '
alias git-branch-close='git_close_branch '
alias git_branch_close='git_close_branch '

git_close_current_branch ()
{
    gitfuncs_audit "$@"
    git-close-branch $(git_get_current_branch)
    return $?
}
export -f git_close_current_branch
alias git-close-current-branch=git_close_current_branch
alias git-branch-close-current='git_close_current_branch '
alias git_branch_close_current='git_close_current_branch '

git_delete_branch ()
{
    gitfuncs_audit "$@"
    local no_remote=0
    if [ "$1" = '--no-remote' ] || [ "$1" = '--local-only' ]
    then
        no_remote=1
        shift;
    fi
    local branch=$1;
    local current_branch=$(git_get_current_branch)
    if [ -z "$branch" ]
    then
        local branchesa=($(git_branch_list))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return 1
        fi
        local PS3="Choose by number, q to quit: "
        local selected
        select selected in ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo $selected is current. Cannot delete current.
                else
                    branch=$selected
                    break
                fi
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return 0
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi

    if [ -n "$branch" ]
    then
        ## $branch was either $1 or we did not ctrl-c out of the select
        if [ "$branch" = "$current_branch" ]
        then
            echo "Nope, you can't delete the current branch."
            return 1
        fi
        git branch -d $branch || return $?;
        if [ "$no_remote" = '1' ]
        then
            return 0
        fi

        remotes=$(git remote)
        for remote in $remotes
        do
            local inremote=$(git_branch_list -r | grep "$remote/$branch")
            if [ -n "$inremote" ]
            then
                local resp=$(yesno "Try deleting in remote $remote" n)
                if [ "$resp" == 'y' ]
                then
                    git push --delete $remote $branch ## This should not fail
                                                      ## since we have checked
                                                      ## that the branch exists
                                                      ## in the remote
                fi
            fi
        done
    fi

    return 0
}
export -f git_delete_branch
alias git-delete-branch='git_delete_branch '
alias git-branch-delete='git_delete_branch '
alias git_branch_delete='git_delete_branch '

git_set_locals ()
{
    gitfuncs_audit "$@"
    local localgitpaths='/home/mpersico5/gits/bbgithub/bbgh/bin
                           /home/mpersico5/gits/bbgithub/glow/bin'
    local lgp
    for lgp in ${localgitpaths}
    do
        addpath -f -p PATH $lgp
        echo "Using $lgp ($(git-get-current-branch $lgp))"
    done
}
export -f git_set_locals
alias git-set-locals=git_set_locals

git_update_hook ()
{
    gitfuncs_audit "$@"
    local hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${gitfuncs_githook_dir}/* | grep -v README.md)
    else
        local h
        local newh
        for h in $hooks
        do
            newh="$newh ${gitfuncs_githook_dir}/$h"
        done
        hooks="$newh"
    fi
    local REPOS REPO
    REPOS=$(_git_go_get 0 0 1 0)
    for REPO in $REPOS
    do
        for h in $hooks
        do
           local hookdir="${HOME}/$(git_strip_repo $REPO)/.git/hooks"
           if [ -e "$hookdir/$(basename $h)" ]
           then
               cp -v $h $hookdir
           fi
        done
    done
}
export -f git_update_hook
alias git-update-hook='git_update_hook '
alias git_hook_update='git_update_hook '
alias git-hook-update='git_update_hook '

git_push_hook ()
{
    gitfuncs_audit "$@"
    local current_template=$(git config --get init.templatedir)
    if [ "$current_template" != "${gitfuncs_githook_root}" ]
    then
        echo "Error: Config says init.templatedir = '$current_template'"
        echo "       It should be '${gitfuncs_githook_root}'"
        echo "       Please correct."
        return 1
    fi

    if [ ! -d "$current_template" ]
    then
        echo "Error: Can't find '$current_template'"
        echo "       Please correct."
        return 1
    fi

    local hooks="$@"
    if [ -z "$hooks" ]
    then
        hooks=$(ls ${gitfuncs_githook_dir}/*)
    else
        local h
        local newh
        for h in $hooks
        do
            newh="$newh ${gitfuncs_githook_dir}/$h"
        done
        hooks="$newh"
    fi

    local REPOS REPO
    REPOS=$(_git_go_get 0 0 1 0 | grep -v ".git_template" )
    for REPO in $REPOS
    do

        echo "== $REPO"
        for h in $hooks
        do
            local hooktgtdir="${HOME}/$(git_strip_repo $REPO)/.git/hooks"
            if [ -f $hooktgtdir ]
            then
                echo $hooktgtdir is a file. whoops....
                ## Fix up accidental directory overwrite
                \rm $hooktgtdir
                mkdir $hooktgtdir
            fi

            local hooktgtpath="$hooktgtdir/$(basename $h)"
            if [ ! -e $hooktgtpath ] || [ $h -nt $hooktgtpath ]
            then
                if [ ! -e $hooktgtpath ]
                then
                    echo "$hooktgtpath not found. Copying from $h..."
                elif [ $h -nt $hooktgtpath ]
                then
                    echo "$hooktgtpath out of date. Updating from $h..."
                fi
                cp -v $h $hooktgtpath
                chmod +x $hooktgtpath
            fi
        done
    done
}
export -f git_push_hook
alias git-push-hook='git_push_hook '
alias git_hook_push='git_push_hook '
alias git-hook-push='git_push_hook '

git_check_hook ()
{
    gitfuncs_audit "$@"
    local gitloc="./.git"
    if [ -f $gitloc ]
    then
        ## We are probably in a worktree...
        gitloc=$(cat .git | sed 's/.* //')
        gitloc=${gitloc%%/worktrees*}
    fi
    if [ ! -d $gitloc ]
    then
        echo "Cannot run git_check_hook outside base repo dir - can't find .git"
        return 1
    fi
    ret=0
    local hookloc="${gitloc}/hooks"
    for i in $(ls ${hookloc}/* | grep -v '.sample')
    do
        if [ ! -x $i ]
        then
            echo "INFO: git hook $i is not executable. Making it so."
            chmod a+x $i
        fi
    done
    return 0
}
export -f git_check_hook
alias git-check-hook='git_check_hook '
alias git_hook_check='git_check_hook '
alias git-hook-check='git_check_hook '

git_checkout ()
{
    gitfuncs_audit "$@"
    local newbranch=$1
    local createbranch=''
    if [ -z "$newbranch" ]
    then
        local branchesa=($(git_branch_list))
        if [ ${#branchesa[@]} == '0' ]
        then
            echo "No branches found. Are you in a git repo?"
            return
        fi
        local current_branch=$(git_get_current_branch)
        local PS3="Choose by number, q to quit: "
        local newonemsg="Create a new one from $current_branch"
        local selected
        select selected in "'$newonemsg'" ${branchesa[@]}
        do
            if [ -n "$selected" ]
            then
                if [ "$selected" == "$current_branch" ]
                then
                    echo $selected is current. Cannot checkout current.
                elif [ "$selected" == "'$newonemsg'" ]
                then
                    while [ -z "$newbranch" ]
                    do
                        read -p "Enter a new branch name: " newbranch
                    done
                    createbranch='-b'
                else
                    newbranch=$(echo $selected | sed 's|\*||')
                fi
                break
            elif [ "$(echo $REPLY | tr '[A-Z]' '[a-z]')" = 'q' ]
            then
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        done
    fi
    if [ -n "$newbranch" ]
    then
        if [ "$newbranch" = 'help' ]
        then
            echo "Use -help or --help"
            return
        fi
        if [ "$newbranch" = 'info' ]
        then
            git branch -vv
            return
        fi
        git checkout $createbranch $newbranch
        status=$?
        if [ "$status" = '0' ] && [ "$createbranch" = '-b' ]
        then
            echo "Setting upstream..."
            git push --set-upstream origin $newbranch
        fi
    fi
}
export -f git_checkout
alias git-checkout='git_checkout '
alias git-branches='git_checkout '
alias git-br='git_checkout '
alias gitbr='git_checkout '

declare -A gitfuncs_remotes

git_parse_remote_v ()
{
    gitfuncs_remotes=()
    for i in $( git remote -v | sed -r -e 's/\(.*//' -e 's/ +$//' -e 's/\t/=/' | sort -ru)
    do
        key=${i%=*}
        value=${i#*=}
        gitfuncs_remotes[$key]=$value
    done
}
alias git-parse-remote-v='git_parse_remote_v '

git_sync_with_master ()
{
    gitfuncs_audit "$@"

    git_parse_remote_v
    ## clone-and-fork repos need to sync with the master in the canonical
    ## upstream branch.  If there is no 'upstream', then it's probably a clone
    ## only, so sync against the master in origin.
    if [ -n "${gitfuncs_remotes[upstream]}" ]
    then
        git_sync_with_remote --remote upstream --branch master "$@"
    elif [ -n "${gitfuncs_remotes[origin]}" ]
    then
        git_sync_with_remote --remote origin --branch master "$@"
    fi
    return $?
}
export -f git_sync_with_master
alias git-sync-with-master='git_sync_with_master '
alias git-update='git_sync_with_master '
alias git-rebase-on-master='git_sync_with_master '

git_sync_with_remote_usage ()
{
    echo "Usage: $1 --branch otherBranch [--remote remote]"
    echo "       remoteRepoTag defaults to 'origin'"
}
export -f git_sync_with_remote_usage
alias git-sync-with-remote-usage='git_sync_with_remote_usage '

git_sync_with_remote ()
{
    gitfuncs_audit "$@"
    local opt_branch=''
    local opt_remote='origin'
    local iam=${FUNCNAME[0]}
    if [ "${FUNCNAME[1]}" = 'git_sync_with_master' ]
    then
        iam=git_sync_with_master
    fi
    local OPTSARGS=$(getopt -o hbr --long help,branch:,remote: -n $iam -- "$@")
    status=$?
    ((status != 0)) && git_synvcc_with_remote_usage && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -r|--remote) opt_remote="$2"; shift; shift ;;
            -b|--branch) opt_branch="$2"; shift; shift ;;
            -h|--help) git_sync_with_remote_usage $iam; return 0 ;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git_sync_with_upstream_usage $iam; return 1 ;;
        esac
    done

    if [ -z "$opt_branch" ]
    then
        echo "--branch required"
        git_sync_with_upstream_usage $iam
        return 1
    fi

    local cb=$(git rev-parse --abbrev-ref HEAD)
    status=$?
    if ((status != 0 ))
    then
        return 1
    fi

    if [ "$cb" == '' ]
    then
        cat <<EOF

$iam is used to keep your current git repo DEVELOPMENT branch in your local
clone in sync with changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you do not appear to even be in a repo. I'm exiting. Try again in a
proper repo.

EOF
        return 1
    fi

    if [ "$cb" == "$opt_branch" ]
    then
        cat <<EOF

        cat <<EOF

$iam is used to keep your current git repo DEVELOPMENT branch in your local
clone in sync with changes in

branch "${opt_branch}"
repo   "${opt_remote}" (${gitfuncs_remotes[$opt_remote]})

However, you appear to be on branch "${opt_branch}", the branch you want to
sync with. I'm exiting. Get off the branch "${opt_branch}" and onto another
branch Then rerun the command. Or just do a 'git pull' if you really need to
refresh this branch.

EOF
        return 1
    fi

    stcheck=$(mktemp)
    git status 1>$stcheck 2>&1
    grep "Your branch is up-to-date with 'origin/$cb'." $stcheck 1>/dev/null
    status=$?
    if [ "$status" != '0' ]
    then
        cat $stcheck
        cat <<EOF
Your branch should be up to date with its origin in order to simplify the
rebase. Make it so and then rerun the command.
EOF
        return 1
    fi

    cat <<EOF

In the current local repo, we are going to

  git pull --rebase ${opt_remote} ${opt_branch}

which will "replay" any existing changes on branch "${opt_branch}" so that it
will appear as if you had originally branched from the current tip of the
"${opt_branch}" branch, which is not necessarily the one you originally
branched off of.

Working...

EOF
    sleep 2
    git pull --rebase ${opt_remote} ${opt_branch}
    status=$?
    if [ "$status" = '0' ]
    then
        echo
        echo "pull --rebase successful. Pushing..."
        git push
        status=$?
        if [ "$status" != '0' ]
        then
            resp=$(yesno "'git push' complained. Shall I re-push with --force" n)
            if [ "$resp" = 'y' ]
            then
                git push --force
                status=$?
            fi
        fi
    fi
    if [ "$status" = '0' ]
    then
        return 0
    else
        cat <<EOF

It appears the pull --rebase was not successful. Assuming the issue was not a
system issue, but rather related to conflicts:

1) Edit each file in conflict, looking for the (partial) conflict marker
   "<<<<<". Once you see the issue, fix the code and save the file.

2) "git add" any files you've changed.

Once any conflicts are resolved, do a "git status". You will see files under
the section "Changes to be committed" if:

1) You fixed any conflicts.

2) There are changes in the branch "${opt_branch}" that need to be added in
   that have no conflicts.

If you see any such files, run "git commit". That will complete the merge into
your branch.

Then push the branch up to your fork so you can submit a pull request.

EOF

        return 1
    fi

}
export -f git_sync_with_remote
alias git-sync-with-remote='git_sync_with_remote '

git_diff_faq ()
{
    gitfuncs_audit "$@"
    cat <<EOF

--- Branch diffing

The trick to diffing two branches is that is must be done locally. Make sure
both branches have been pulled down from their remotes before tyring to use
them in a diff.

diff two branches:
    git diff branch1 branch2

diff current branch vs other branch:
    git diff other

    *Note - the sense of the diff is from the other back to the current, as if
            you typed 'git diff other current' . If you want the diff from
            current to other then use 'git diff current other'

diff specific files between two branches:
    git diff branch1 branch2 -- file [file...]

EOF
}
export -f git_diff_faq
alias git-diff-faq=git_diff_faq

bbgithub_fork_and_clone ()
{
    gitfuncs_audit "$@"
    local proto=bbgithub
    if [ -z "$1" ]
    then
        cat <<EOUSAGE
Usage: bbgithub_fork_and_clone namespace repo
       forks $proto:namespace/repo
       to    $proto:$USER/repo
       then clones to 'repo' in a directory path
       ending in $proto/$USER, which must be the pwd.

       If the fork already exists, and all you want
       to do is make a new local clone, run this command
       anyway. It will not re-fork.

EOUSAGE
        return 1
    fi
    local namespace=$1;shift
    local repo=$1;shift
    local cwpath=$(realpath $(pwd))
    local local_namespace=$(basename $cwpath)
    local local_proto=$(basename $(dirname $cwpath))
    if [ "$local_namespace" != "$USER" ] || \
           [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto/$USER"
        echo "You are in $cwpath"
        echo "Correct and re-execute."
        return 1
    fi

    local cmd="glow clone-fork $proto:$namespace/$repo"
    ## does the fork of namespace/repo to user/repo
    ## clones user/repo to repo
    ## does git remote add upstream $proto:namespace/repo
    echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status

    cd $repo
    git remote -v

    ## Check for master. Some repos arrange it so that the default for clones
    ## is other than master.
    master_exists=$(git branch | grep -E '^(\* master|master)$')

    if [ -n "$master_exists" ]
    then
        echo 'Dumping the origin master in favor of the upstream master...'
        echo git checkout -b temp
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -d master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -r -d origin/master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git checkout --track upstream/master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git checkout master
        echo status=$?; [ "$status" != '0' ] && return $status

        echo git branch -d temp
        echo status=$?; [ "$status" != '0' ] && return $status
    fi

    echo "Setting up for worktrees..."
    mkdir wt
    ls -ld $(pwd)/wt

    ## Add this repo to the list
    git_go_set
}
export -f bbgithub_fork_and_clone
alias bbgithub-fork-and-clone='bbgithub_fork_and_clone '
alias fork_and_clone_bbgithub='bbgithub_fork_and_clone '
alias fork-and-clone-bbgithub='bbgithub_fork_and_clone '

_guts_clone ()
{
    gitfuncs_audit "$@"

    if [ -z "$1" ]
    then
        echo "Usage: _guts_clone proto namespace repo"
        echo "       pwd must match |/proto\$|"
        return 1
    fi

    local proto=$1;shift

    if [ -z "$1" ]
    then
        echo "Usage: ${proto}_clone namespace repo"
        echo "       pwd must match |/$proto\$|"
        return 1
    fi

    local namespace=$1;shift
    local repo=$1;shift
    local cwpath=$(realpath $(pwd))
    local local_proto=$(basename $cwpath)
    if [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto"
        echo "You are in $cwpath"
        echo "Correct and re-execute."
        return 1
    fi

    if [ -z "${gitfuncs_gitsvcs[$proto]}" ]
    then
        echo "$proto is unknown. Valid protocols are:${!gitfuncs_gitsvcs[@]}"
        return 1
    fi
    local cmd="git clone ${gitfuncs_gitsvcs[$proto]}$namespace/$repo $namespace/$repo"
    echo $cmd ...
    $cmd
    status=$?; [ "$status" != '0' ] && return $status

    cd $namespace/$repo
    git remote -v

    ## Add this repo to the list
    git_go_set
}
export -f _guts_clone

devgit_clone ()
{
    gitfuncs_audit "$@"
    _guts_clone devgit "$@"
}
export -f devgit_clone
alias devgit-clone='devgit_clone '
alias git_clone_devgit='devgit_clone '
alias git-clone-devgit='devgit_clone '

bbgithub_clone ()
{
    gitfuncs_audit "$@"
    _guts_clone bbgithub "$@"
}
export -f bbgithub_clone
alias bbgithub-clone='bbgithub_clone '
alias git_clone_bbgithub='bbgithub_clone '
alias git-clone-bbgithub='bbgithub_clone '

github_clone ()
{
    gitfuncs_audit "$@"
    _guts_clone github "$@"
}
export -f github_clone
alias github-clone='github_clone '
alias git_clone_github='github_clone '
alias git-clone-github='github_clone '

bitbucket_clone ()
{
    gitfuncs_audit "$@"
    _guts_clone bitbucket "$@"
}
export -f bitbucket_clone
alias bitbucket-clone='bitbucket_clone '
alias git_clone_bitbucket='bitbucket_clone '
alias git-clone-bitbucket='bitbucket_clone '

_guts_whack ()
{
    gitfuncs_audit "$@"
    if [ -z "$1" ]
    then
        echo "Usage: _guts_whack proto namespace repo"
        echo "       pwd must match |/proto\$|"
        return 1
    fi

    local proto=$1;shift

    if [ -z "$1" ]
    then
        echo "Usage: ${proto}_whack namespace repo"
        echo "       pwd must match |/$proto\$|"
        return 1
    fi

    local namespace=$1;shift
    repo=$(basename $namespace) ## Trailing / whacking...
    local repo=$1;shift
    repo=$(basename $repo)
    if [ -z "$repo" ]
    then
        echo "Usage: ${proto}_whack namespace repo"
        echo "       Did you namespace/repo?"
        return 1
    fi

    local cwpath=$(realpath $(pwd))
    local local_proto=$(basename $cwpath)
    if [ "$local_proto" != "$proto" ]
    then
        echo "You must be in a local directory path ending in"
        echo "   $proto"
        echo "You are in $cwpath"
        echo "Correct and re-execute."
        return 1
    fi

    if [ -z "${gitfuncs_gitsvcs[$proto]}" ]
    then
        echo "$proto is unknown. Valid protocols are:${!gitfuncs_gitsvcs[@]}"
        return 1
    fi
    (
        ## subshell to avoid cd issues

        ## Go to what we want to whack, to make sure it's there...
        echo gitgo $proto/$namespace/$repo
        gitgo $proto/$namespace/$repo
        status=$?
        if ((status==0))
        then
            ## ...and make sure it's clean
            dirty=$(git status --porcelain)
            if [ -z "$dirty" ]
            then
                ## We're clean. Whack it.
                cd ..
                pwd
                set -x
                \rm -r -i $repo
                status=$?
                if ((status==0))
                then
                    ## Remove it from the list of local git repos
                    git_go_set
                fi
            else
                status=1
                git status
            fi
        fi
        return $status
    )
    status=$?
    set +x
    return $status
}
export -f _guts_whack

devgit_whack ()
{
    gitfuncs_audit "$@"
    _guts_whack devgit "$@"
}
export -f devgit_whack
alias devgit-whack='devgit_whack '
alias git_whack_devgit='devgit_whack '
alias git-whack-devgit='devgit_whack '

bbgithub_whack ()
{
    gitfuncs_audit "$@"
    _guts_whack bbgithub "$@"
}
export -f bbgithub_whack
alias bbgithub-whack='bbgithub_whack '
alias git_whack_bbgithub='bbgithub_whack '
alias git-whack-bbgithub='bbgithub_whack '

github_whack ()
{
    gitfuncs_audit "$@"
    _guts_whack github "$@"
}
export -f github_whack
alias github-whack='github_whack '
alias git_whack_github='github_whack '
alias git-whack-github='github_whack '

bitbucket_whack ()
{
    gitfuncs_audit "$@"
    _guts_whack bitbucket "$@"
}
export -f bitbucket_whack
alias bitbucket-whack='bitbucket_whack '
alias git_whack_bitbucket='bitbucket_whack '
alias git-whack-bitbucket='bitbucket_whack '

git_what_is_modified ()
{
    gitfuncs_audit "$@"
    ## $1 used to specify a particular dir.
    echo ''
    git status $1 | grep modified: | sed 's/.*modified://' | sed 's/ //g'
}
export -f git_what_is_modified
alias git-what-is-modified='git_what_is_modified '

git_what_can_be_committed ()
{
    gitfuncs_audit "$@"    ## Get the top level of the current repo
    local tl=$(git rev-parse --show-toplevel)

    local potentials
    ## Figure out what could be committed from the current state of the repo.
    ## $(git st --porcelain -uno)
    potentials=$(git st -v | grep -- 'diff --git' | cut -d' ' -f 4 | sed 's|b/||')

    local f
    local files
    local dirs
    for f in $potentials
    do
        if [ -f $f ]
        then
            files="$files $f"
        elif [ -d $f ]
        then
            dirs="$dirs $f"
            files="$files $(find $f -type f)"
        fi
    done
    echo "$dirs $files" | tr ' ' '\n' | uniq
}
export -f git_what_can_be_committed
alias git-what-can-be-committed='git_what_can_be_committed '
alias git-what-is-committable='git_what_can_be_committed '

git_track_remote_branch ()
{
    local remote=$1
    local branch=$2
    if [ -z "$remote" ] || [ -z "$branch" ]
    then
        echo "Usage: git_track_remote_branch remote branch"
        echo "       Missing one or both arguments"
        return 1
    fi
    git fetch $remote || return $?
    git checkout -b $branch --track $remote/$branch
    return $?
}
alias git-track-remote-branch='git_track_remote_branch '
alias git_branch_track_remote='git_track_remote_branch '
alias git-branch-track-remote='git_track_remote_branch '

## Useful in prompts (PS1).
git_inside_work_tree ()
{
    local print=$1;shift
    local v=$(git rev-parse  --is-inside-work-tree 2>/dev/null)
    local r=0
    [ "$v" != "true" ] && r=1
    [ "$print" = '-p' ] && echo $v
    return $r ## 0 if in tree, 1 if not
}
alias git-inside-work-tree='git_inside_work_tree '

git_get_stash_count ()
{
    local pre=$1;shift
    local post=$1;shift
    git_inside_work_tree
    if [ "$?" = '0' ]
    then
        local c=$(git stash list | wc -l)
        echo "${pre}${c}${post}"
    fi
}
alias git-get-stash-count='git_get_stash_count '
alias git_stash_get_count='git_get_stash_count '
alias git-stash-get-count='git_get_stash_count '

git_create_worktree_usage ()
{
    echo "Usage: git_create_worktree branch [remote]"
    echo "       default remote is 'origin'"
}
alias git-create-worktree-usage='git_create_worktree_usage '
alias git_worktree_create_usage='git_create_worktree_usage '
alias git-worktree-create-usage='git_create_worktree_usage '

git_create_worktree ()
{
    local verbose=1
    ## Make sure pwd ends in wt
    if [[ ! "$(pwd)" =~ /wt$ ]]
    then
        echo "Will not create worktrees outside of wt dir. Aborting."
        return 1
    fi

    if [ -z "$1" ]
    then
        echo 'Need a branch name to use for the worktree spec.'
        git_create_worktree_usage
        return 1
    fi
    local wt=$1
    shift

    local remote=$1
    shift
    if [ -z "$1" ]
    then
        remote=origin
        echo "Using 'origin' as remote."
    fi

    ((verbose)) && echo '## check for existing worktrees with same name'
    wtdir="$(pwd)/$wt"
    if [ -e $wtdir ]
    then
        echo "$wtdir already exists. Aborting."
        return 1
    fi

    ## TODO: Allow for suffix to append to worktree name so you can dup them if
    ## you need to.

    ((verbose)) && echo '## check for existing branch'
    local create_branch="-b"
    local exists=$(git_branch_list | grep $wt)
    if [ -n "$exists" ]
    then
        echo "Branch $wt already exists. Using it."
        create_branch=''
    fi
    ((verbose)) && echo git worktree add $create_branch "$wt" "$wt"
    git worktree add $create_branch "$wt" "$wt"
    status=$?
    if [ ! "$status" = '0' ]
    then
        echo "Aborting."
        return 1
    fi

    ((verbose)) && echo cd $wt
    cd $wt

    ((verbose)) && echo git push --set-upstream $remote $wt
    git push --set-upstream $remote $wt

    git_go_set

}
alias git-create-worktree='git_create_worktree '
alias git_worktree_create='git_create_worktree '
alias git-worktree-create='git_create_worktree '
alias git_worktree='git_create_worktree '
alias git-worktree='git_create_worktree '

git_delete_current_worktree ()
{
    ## Make sure we are in a proper worktree.
    if [ ! -f .git ] || [[ ! "$(pwd)" =~ /wt/ ]]
    then
        echo "$(pwd) is not a proper worktree for deletion"
        return 1
    fi

    ## Make sure it's clean.
    if [ "$(git status --porcelain | wc -l)" != '0' ] || \
           [ "$(git status | grep 'Your branch is' | grep -v 'up-to-date' | wc -l)" != '0' ]
    then
        git status
        echo
        echo "Will not delete current worktree"
        return 1
    fi

    git status
    local resp=$(yesno 'Hard check on status for a while. Continue with deletion');
    if [ "$resp" = 'n' ]
    then
        return 0
    fi
    ## Whack it. Start with the current dir.
    local delit=$(basename $(pwd))
    cd ..
    local resp=$(yesno "Hard check on rm for a while. Continue with $delit");
    [ "$resp" = 'n' ] && return 0
    \rm -r $delit; (( $? != 0 )) && echo "Bad rm. Aborting." && return 1;

    ## Work our way up to the first non empty dir or the 'wt' dir, whichever we
    ## get to first, and bail.
    while [ "$(basename $(pwd))" != 'wt' ]
    do
        if [ -z "$(ls -A $(pwd))" ]
        then
            #it's empty
            delit=$(basename $(pwd))
            cd ..
            resp=$(yesno "Hard check on rm for a while. Continue with $delit");
            [ "$resp" = 'n' ] && return 0
            \rm -r $delit; (( $? != 0 )) && echo "Bad rm. Aborting." && return 1;
        else
            git_go_set
            return 0
        fi
    done
}
alias git-delete-current-worktree='git_delete_current_worktree '
alias git_worktree_delete_current='git_delete_current_worktree '
alias git-worktree-delete-current='git_delete_current_worktree '

git_add_remote_usage ()
{
    cat <<EOF
usage: git_add_remote proto namespace"
       Adds proto:namespace/current_repo"
       as a remote named 'namespace'."
       Use this to get at people's"
       branches on a repo fork."
EOF
}

git_add_remote ()
{
    set -x
    if [ "$#" != '2' ]
    then
        git_add_remote_usage; return 1
    fi
    local proto=$1; shift
    local remote=$1; shift
    current_repo=$(git_get_current_repo_name)
    git remote add $remote $proto:$remote/$current_repo
    local $status=$?
    if (( $status == 0 ))
    then
        git remote -v | grep $remote
    fi
    return $status
}
alias git-add-remote='git_add_remote'
alias git_remote_add='git-add-remote'
alias git-remote-add='git_add_remote'

alias git-remotes='git remote -v '
alias git_remotes='git remote -v '

git_state ()
{
    echo
    echo "=== Log:"
    git log -1
    echo
    echo "=== Status:"
    git status "$@"
}
alias git-state='git_state '
alias git-st='git_state '

git_get_current_repo_name ()
{
    git remote -v | grep origin | sed 's|.*/||' | sed 's/ .*//' | sort -u
}

git_branch_list ()
{
    gitfuncs_audit "$@"
    local strip=1
    local remote=''
    local OPTSARGS=$(getopt -o r --long strip,nostrip,remote -n 'git-branch-list' -- "$@")
    status=$?
    ((status != 0)) && echo "Exiting." && return $status
    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -r | --remote) remote='-r'; shift;;
            --strip) strip=1; shift;;
            --nostrip) strip=0; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; git-st-strip-usage; return 1 ;;
        esac
    done

    local opts="--list --no-color $remote"
    if ((strip))
    then
        git branch $opts | sed 's/.* //'
    else
        git branch $opts
    fi

}

## Can't use local outside a function.
typeset forlater='

in order to keep my scripts separate from the main repo

git_create_orphan_branch ()
{
ASUD RAHMAN
14:48:14 git checkout --orphan <new branch>
14:48:22 creates a new branch that is disconnected from the other branches
14:48:40 then you can do git checkout -b <work branch> followed by git merge <new branch>
14:49:00 <work branch> will now contain the stuff you normally have plus the stuff you put in <new branch>
MATTHEW PERSICO
14:52:54 I will try that.
- git checkout --orphan myTools
- *write theTools *
- git commit the theTools
Then do as above. If I need to update any of theTools, I think I would
- finish the current branch work, and commit only those file, not theTools
- git checkout myTools
- git commit theTools

I will try this out. Thanks.

--orphan <new_branch>

Create a new orphan branch, named <new_branch>, started from <start_point> and
switch to it. The first commit made on this new branch will have no parents and
it will be the root of a new history totally disconnected from all the other
branches and commits.

The index and the working tree are adjusted as if you had previously run "git
checkout <start_point>". This allows you to start a new history that records a
set of paths similar to <start_point> by easily running "git commit -a" to make
the root commit.

This can be useful when you want to publish the tree from a commit without
exposing its full history. You might want to do this to publish an open source
branch of a project whose current tree is "clean", but whose full history
contains proprietary or otherwise encumbered bits of code.

If you want to start a disconnected history that records a set of paths that is
totally different from the one of <start_point>, then you should clear the
index and the working tree right after creating the orphan branch by running
"git rm -rf ." from the top level of the working tree. Afterwards you will be
ready to prepare your new files, repopulating the working tree, by copying them
from elsewhere, extracting a tarball, etc.
}
export -f git_create_orphan_branch
alias git-create-orphan-branch=''git_create_orphan_branch ''

'
