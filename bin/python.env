#!/usr/bin/env bash
# shellcheck disable=SC2155 #https://github.com/koalaman/shellcheck/wiki/SC2155

# python.env - Even though we have this file in PERSONALBIN, you should invoke
# it from WORKBIN if there is a WORKBIN because you'll need any WORK paths on
# PATH to find where your WORK installs Python.

# We'll check for virtualenv in PS1 ourselves.
export VIRTUAL_ENV_DISABLE_PROMPT=1

##
## We want the latest version of python and all its tools. This is crude, but
## effective.
##

declare verbose=0
declare init=''
while (($#)); do
    [[ $1 =~ '-v' ]] && verbose=1 && shift && continue
    if [[ $1 =~ '-init' ]]; then
        init=$2
        shift;shift;
        continue
    fi
    ## No other arguments are valid
    echo "$1 is an invalid argument"
    return ## This gets dotted in
done

declare pypath="${TILDAE:-$HOME}/personal/bin/python"

## Find the latest python
declare wanted_python_version_max=999.999
declare wanted_python_version=0.0
declare wanted_python_version_file="${pypath}/.python_version"
if [[ -n $init ]]; then
    wanted_python_version_max=$init
elif [[ -r $wanted_python_version_file ]]; then
    wanted_python_version_max=$(cat "$wanted_python_version_file")
fi
wanted_python_version=$wanted_python_version_max
declare disk_python_version=0
if [[ -h "$pypath/python" ]]; then
    disk_python_version=$(basename "$(readlink "$pypath/python")")
    disk_python_version=${disk_python_version##python}
fi

# Using a current python version as the max ensures that we won't automatically
# update until we want to, but we will be notified. When we want to upgrade,
# put the desired version into $out_python_version_file.
declare latest_available_version=$(python-version-verify --max "$wanted_python_version_max" --version-only)
declare latest_available_exe=$(python-version-verify --max "$wanted_python_version_max" --nowarn)

declare upgrade=0
if [[ ! -d "$pypath" ]] || [[ -n $init ]]; then
    upgrade=1
else
    # shellcheck disable=SC2154 #https://github.com/koalaman/shellcheck/wiki/SC2154
    # Perl #line directive is current line # -1
    upgrade=$(perl -e "#line 59
sub vcomp { (\$lmaj, \$lmin, \$rmaj, \$rmin) = map{split(/\./,\$_)}(@_); return (\$lmaj <=> \$rmaj || \$lmin <=> \$rmin); }

#if on disk is less than    what we want, upgrade
#if on disk is greater than what we want, that should never be
#if on disk is equal to     what we want
#    if on disk is less than    max available, warn to upgrade
#    if on disk is greater than max available, that should never be
#    if on disk is equal to     max available, then we are good

if ( vcomp( q($disk_python_version), q($wanted_python_version) ) == -1 ) {
    warn qq(Have Python $disk_python_version, want Python $wanted_python_version. Upgrading...\n);
    print(q(1)); exit 0;
}
if ( vcomp( q($disk_python_version), q($wanted_python_version) ) == 1 ) {
    warn qq(Have Python $disk_python_version, want Python $wanted_python_version. That should not be. Please review.\n);
    print(q(0)); exit 1;
}
#if on disk is equal to     what we want...
if ( vcomp(q($disk_python_version),q($latest_available_version)) == -1) {
    warn qq(Have Python $disk_python_version, but $latest_available_version is available. We do not do automatic upgrades. Run $0 --init to upgrade.\n);
    print(q(0)); exit 1;
}
if ( vcomp(q($disk_python_version),q($latest_available_version)) == 1) {
    warn qq(Have Python $disk_python_version, but $latest_available_version is available. That should not be. Please review.\n);
    print(q(0)); exit 1;
}
# If we are here, we want and have the latest
print(q(0)); exit 0;
")
fi

if ((upgrade == 0)); then
    ((verbose)) && echo "Our python is up to date."
else
    ## Bury all the python links in a python subdir
    mkdir -p "$pypath"

    ## Find all the python exes and link them locally, hoping that there are no
    ## programs not related to python that end in the same number.
    ## combo. :facepalm:
    declare link
    declare -a candidates
    mapfile -t candidates < <(ls "$(dirname "$latest_available_exe")"/*"$latest_available_version")
    for exe in "${candidates[@]}"; do
        ## Execption - there are three forms of this one. Why? WTFK.
        if [[ $exe =~ coverage ]] && [[ ! $exe =~ coverage${latest_available_version} ]]
        then
            continue
        fi
        ## If we don't do this twice, we will end up with some local commands like
        ## '2to3-' instead of '2to3'.
        link="$pypath"/$(basename "$exe" -"$latest_available_version")
        link="$pypath"/$(basename "$link" "$latest_available_version")
        if [[ $(readlink "$link") != "$exe" ]]
        then
            ## There's a higher version of python out there. Grab it.
            rm -fv "$link"
            ln -sv "$exe" "$link"
        fi
    done
    echo -n "$latest_available_version" > "$wanted_python_version_file"
fi

[[ -r $pypath ]] && addpath -fx PATH "$pypath"
addpath -fx PATH "$pypath"

PYTHONENV_LOADED=1
export PYTHONENV_LOADED
