#!/usr/bin/env perl
use strict;
use warnings;

use Getopt::Long qw(:config auto_abbrev);
my %opt;
my %flags;
GetOptions(\%opt,
           qw( staged
               unstaged
               untracked
               deleted
               all-modified
               unmodified
               verbose)
       ) or die;
die "Need at least one of --staged --unstaged --untracked --all-modified --unmodified"
  if(! %opt );
%flags = %opt;

if( $opt{'all-modified'} || $opt{unmodified} || $opt{deleted}) {
    $flags{$_} = 1
      for ( qw (staged unstaged untracked) );
}
$flags{$_} //= 0
    for ( qw (staged unstaged deleted untracked all unmodified) );

my @input = qx(git status; echo GSE);
my %files;
INPUT:for (@input) {
    chomp;s/^\s+//;s/\s+$//;
    length($_) == 0 && next INPUT;

    if($flags{staged} ## quick shortcut
       && /^Changes to be committed/ .. /^Changes not staged for commit/) {
        /^Changes to be committed/ && next INPUT;
        /use "git reset HEAD <file>..." to unstage/ && next INPUT;
        if( /^Changes not staged for commit/ ) {
            $flags{staged} = 0;
        } elsif( /^GSE/ ) {
            last INPUT; ## S
        } else {
            store_filename('staged',$_);
        }
    }

    if($flags{unstaged} ## quick shortcut
       && /^Changes not staged for commit/ .. /^Untracked files/) {
        /^Changes not staged for commit/ && next INPUT;
        /use "git add <file>..." to update what will be committed/ && next INPUT;
        /use "git checkout -- <file>..." to discard changes in working directory/ && next INPUT;
        if( /^Untracked files/ ) {
            $flags{unstaged} = 0;
        } elsif( /^GSE/ ) {
            last INPUT;
        } else {
            store_filename('unstaged', $_);
        }
    }

    if($flags{untracked} ## quick shortcut
       && /^Untracked files/ .. /^GSE$/) {
        /^Untracked files/ && next INPUT;
        /use "git add <file>..." to include in what will be committed/ && next INPUT;
        if( /^GSE/ ) {
            last INPUT;
        } else {
            store_filename('untracked', $_);
        }
    }
}

if( $flags{unmodified} ) {
    print join("\n", sort
                 grep { ! defined $files{affected}{$_} }
                 map {chomp;$_}
                 qx(git ls-files));
} elsif( $flags{deleted} ) {
    print join("\n", sort keys %{$files{deleted}});
} elsif($opt{verbose}) {
    print join("\n", map { "$_ - " . join(', ', @{$files{affected}{$_}}) } sort keys %{$files{affected}});
} else {
    print join("\n", sort keys %{$files{affected}});
}

sub store_filename {
    my $type = $_[0];
    my ($subtype, $name);
    if( $type eq 'untracked') {
        $name = $_[1];
        $subtype = $type;
    } else {
        ($subtype, $name) = (map { s/\s+//; $_} (split(/:/, $_[1])));
    }
    return if (not defined $name
                 or
                 ( $subtype ne 'deleted'
                   and
                   (! -f $name and ! -d $name and ! -l $name) ) );
    $files{$type}{$name} = $subtype;
    $files{$subtype}{$name} = 1;
    if($files{affected}{$name}) {
        push @{$files{affected}{$name}}, $subtype;
    } else {
        $files{affected}{$name} = [$subtype];
    }
}
