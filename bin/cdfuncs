# -*- sh -*-

# cdfuncs

## I chose to use 'local' because it is more semantically correct for what we
## are doing than 'declare' is, and 'typeset' is deprecated except for ksh
## compatibility.

CDFUNCS_FILE=${BASH_SOURCE[0]}
DIRLIST_FILE=~/.dirlist
DIRLIST_LOCK=~/.dirlist.lck
DIRLIST_CONTEXT=''
DIRLIST_PWD_INDIC='==>'

cdfuncs_edit ()
{
    xo $CDFUNCS_FILE
}
export -f cdfuncs_edit
alias cdfuncs-edit=cdfuncs_edit

cdfuncs_reload ()
{
    . $CDFUNCS_FILE
}
export -f cdfuncs_reload
alias cdfuncs-reload=cdfuncs_reload

## Remove the current dir marker
cleandirlist ()
{
	DIRLIST=$(echo "${DIRLIST}" | sed "s|$DIRLIST_PWD_INDIC||g")
}
export -f cleandirlist

stderrcho ()
{
    echo $* >&2
}
export -f stderrcho

eddirlist ()
{
    writedirlist --edit
}
export -f eddirlist

## Remove all the intermediate directories
prunedirlist ()
{
	cleandirlist
    local tmplist=$(echo ${DIRLIST} | tr ' ' '\n' | sort -ur)
    local lastdir
    local newlist
    local i
    for i in $tmplist
    do
        if [[ "${lastdir}" != "${i}"* ]]
        then
            newlist="$newlist $i"
        fi
        lastdir=$i
    done
    DIRLIST="$newlist"
    setdirlist
}
export -f prunedirlist

# Maintain the list of visited directories
setdirlist ()
{
    cleandirlist
    local p=$(pwd)
    if [ "$1" = '--nopwd' ]
    then
        p=''
    fi

    ## Pull out ~...
	DIRLISTTMP=$(echo $p ${DIRLIST} | sed "s|\~|$HOME|g" | tr ' ' '\n' | sort -u | grep -v "^${HOME}$")
    local d
    DIRLIST=''
    ## ...so we can always make it #1
    for d in $HOME $DIRLISTTMP
    do
        if [ -d $d ]
        then
            if [ $d == "$p" ]
            then
                d="${DIRLIST_PWD_INDIC}$d"
            fi
            DIRLIST="$DIRLIST $d"
        ## verbose else
            ## verbose stderrcho Pruned non-existant $d from DIRLIST
        fi
    done
	DIRLIST=$(echo ${DIRLIST} | sed "s|$HOME|\~|g" )
}
export -f setdirlist

# Read list of dirs off the disk. You can have different lists if you use the
# context arg.
readdirlist ()
{
    local context=$1
    local dirlistfile=$DIRLIST_FILE
    local lockfile=$DIRLIST_LOCK
    local tmpfile=/tmp/cdfuncs.$$
    if [ -z "$context" ]
    then
        context=$DIRLIST_CONTEXT
    else
        DIRLIST_CONTEXT=$context
    fi
    if [ -n "$context" ]
    then
        dirlistfile="${dirlistfile}.${context}"
        lockfile="${lockfile}.${context}"
    fi
    (
        ## lock, exclusive, 60 second timeout, file descriptor 200 (0 is stdin,
        ## 1 is stout, 2 is stderr)
        flock -e -w 60 200
        if [ -e $dirlistfile ]
        then
            cat $dirlistfile
        else
            stderrcho "[readdirlist] WARNING: $dirlistfile not found."
        fi
    ) 200>$DIRLIST_LOCK 1>$tmpfile
    DIRLIST=$(cat $tmpfile)
    \rm $tmpfile
    setdirlist
}
export -f readdirlist

# Write the list of dirs to the disk. You can have different lists if you use
# the context arg.
writedirlist ()
{
    local edit=0
    local context=$DIRLIST_CONTEXT
    local dirlistfile=$DIRLIST_FILE
    local lockfile=$DIRLIST_LOCK
    if [ "$1" = '--edit' ]
    then
        edit=1
        shift
    fi
    if [ -z "$1" ]
    then
        context=$DIRLIST_CONTEXT
    else
        DIRLIST_CONTEXT=$1
        context=$1
    fi
    if [ -n "$context" ]
    then
        dirlistfile="${dirlistfile}.${context}"
        lockfile="${lockfile}.${context}"
    fi
    cleandirlist
    (
        ## lock, exclusive, 60 second timeout, file descriptor 200 (0 is stdin,
        ## 1 is stout, 2 is stderr)
        flock -e -w 60 200
        if [ "$edit" = 0 ]
        then
            echo $DIRLIST > $dirlistfile
        else
            echo > $dirlistfile
            for i in $DIRLIST
            do
                echo $i >> $dirlistfile
            done
            $EDITOR vi $DIRLIST_FILE
        fi
    ) 200>$DIRLIST_LOCK
    readdirlist
}
export -f writedirlist

_dirlist_select ()
{
    local PS3="Choose by number, - for prior, q to quit: "
    local d
    select d in $*
    do
        if [ -n "$d" ]
        then
            d=$(echo $d | sed "s|$DIRLIST_PWD_INDIC||" | sed "s|\~|$HOME|")
            if [ -d "$d" ]
            then
                builtin cd $d
                break
            else
                stderrcho "$d no longer exists"
            fi
        else
            local reply=$(echo $REPLY | tr '[A-Z]' '[a-z]')
            if [ "$reply" = 'q' ]
            then
                return
            elif [ "$reply" = '-' ]
            then
                builtin cd -
                return
            else
                echo "'$REPLY' is an invalid choice"
            fi
        fi
    done
}
export -f _dirlist_select

pwdswap ()
{
    echo $(pwd | sed "s|$1|$2|")
}
export -f pwdswap

dirlist_usage ()
{
    echo Usage: dirlist TBD
}

dirlist ()
{
    ## The major input handling points are noted with ## ------

    ## The nosave* options are in support of the dirlist -5 foo/bar case. We
    ## call dirlist on the -5 to go up and on foo./bar to go down. In the first
    ## call, we do not want the setdirlist at the END of this call to save the
    ## current directory (the result of the up) on the stack, so we specify
    ## nosavetarget.  When we make the second call we don't want the current
    ## directory added to the list in the call to setdirlist at the START of
    ## the call - that's nosavecurrent.

    local target
    local current

    ## Have to pull off any negative numbers first so as not to confuse getopt
    local negs
    local args
    while [ -n "$1" ]
    do
        is_neg $1
        if (( $? == 0 ))
        then
            negs="$negs $1"
        else
            args="$args $1"
        fi
        shift
    done

    ## Put back args
    eval set -- "$args"

    local OPTSARGS=$(getopt -o h --long nosavetarget,nosavecurrent -n 'dirlist' -- "$@")
    status=$?
    ((status != 0)) && echo "Exiting." && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            -h|--help) dirlist_usage; return 0 ;;
            --nosavetarget) target='--nopwd'; shift;;
            --nosavecurrent) current='--nopwd'; shift ;;

            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; dirlist_usage; return 1 ;;
        esac
    done

    if [ -n "$negs" ]
    then
        eval set -- "$negs $@"
    fi

    setdirlist $current

    if [ -z "$1" ]
    then
        ## ----
        ## Menu
        ## ----
        ## No args given; present the menu and read choice.
        ## Note: If you
        ##    alias cd=dirlist
        ## you lose cd == cd ~. Oh well. As a consolation, we always make '~'
        ## the 1) entry in the menu so 'cd 1' has the same effect.
        _dirlist_select $DIRLIST
    else
        ## --------------
        ## Parse the args
        ## --------------
        if (($#==2))
        then
            is_neg $1
            if (( $? == 0 ))
            then
                ## We're doing cd -4 a/c, i.e; cd up then down.  The oldpwd
                ## save and the --nosave* args prevent saving the intermediate
                ## dir in the list.
                local oldpwd=$(pwd)
                dirlist --nosavetarget $1
                dirlist --nosavecurrent $2

                ## This will undo the effect of the intermediate builtin cd call.
                export OLDPWD=$oldpwd
            else
                ## ---------
                ## Text swap
                ## ---------
                ## 'dirlist x y' changes /a/b/x/f to /a/b/y/f and cd's to the later.
                ## Some 'cd' commands support this intrinsically (cd x y). However,
                ## we're not going to bother trying to figure out if this
                ## version does or not.
                builtin cd $(pwdswap "$1" "$2")
            fi
        else
            local tgt=$1;shift
            ## Simplest case - the arg is a directory we can reach or prior
            ## directory syntax.
            if [ -d $tgt ] || [ "$tgt" = '-' ]
            then
                builtin cd $tgt
            else
                is_int $tgt
	            if (( $? == 0 ))
	            then
	                is_neg $tgt
	                if (( $? == 0 ))
	                then
                        ## --------------------
                        ## Negative integer arg
                        ## --------------------
                        ## Argument was a negative number. If you are in /a/b/c/d/e and
                        ## you cd -2, you end up in /a/b/c.
		                local i=$tgt
                        local tgtdir=$(pwd)
		                while (( i < 0 ))
		                do
		                    tgtdir=$(dirname $tgtdir)
		                    (( i=i+1 ))
		                done
		                builtin cd $tgtdir
                    else
                        ## --------------------
                        ## Positive integer arg
                        ## --------------------
                        ## Argument was a positive number. If you haven't changed your
                        ## stack and you remember your number from the select menu,
                        ## just go there.
	                    local DIRLISTA=($DIRLIST)
                        if ((tgt>${#DIRLISTA[@]})) || ((tgt==0))
                        then
                            stderrcho $tgt is not a valid choice
                        else
                            local d=$(echo ${DIRLISTA[(tgt-1)]} |
                                             sed "s|$DIRLIST_PWD_INDIC||" |
                                             sed "s|~|${HOME}|")
                            builtin cd $d
	                    fi
	                fi
                else
                    ## Arg is a partial completion. Filter the list. If your
                    ## filter matches a reachable directory, it will be handled
                    ## above. If that's not what you want, too bad; you'll have
                    ## to use a plain dirlist call and hunt.
                    local FILTERED_DIRLIST=$(echo $DIRLIST | tr ' ' '\n' | grep $tgt )
                    if [ -n "$FILTERED_DIRLIST" ]
                    then
                        _dirlist_select $FILTERED_DIRLIST
                    else
                        echo "$tgt not found"
                    fi
                fi
            fi
        fi
    fi

    setdirlist $target
}
export -f dirlist

alias go='dirlist '

up ()
{
    local tgt=$1
    if [ -z "$tgt" ]
    then
        tgt=1
    fi
	is_int $tgt
	if (( $? == 0 ))
	then
	    is_neg $tgt
	    if (( $? != 0 ))
	    then
            stderrcho 'up takes positive numbers. We will convert for you.'
        else
            ((tgt=tgt*-1))
        fi
        dirlist $tgt
    else
        stderrcho 'up takes positive numbers.'
    fi
}
export -f up
