# -*- sh -*-

# git-process-changelog

##@@ 0001||group||git-process-changelog||'Guts' function for *-with-changelog functions

source $BASH_INC_DIR/on_exit.binc

declare usage_func="${FUNCNAME}-usage"

## All of the *-changelog functions work best in the git-root, which is
## where the $GITFUNCS_CHANGELOG_NAME is anyway
declare pwd=$(pwd)
declare gr=$(git-root)
if [ ! "$pwd" = "$gr" ]
then
    _git-cd-to $gr  || exit $?
else
    gr=''
fi

declare action='read'
declare parse_flag=''
declare diff=''
declare opt_v='' ## passed to commit
declare status=0
declare parsed_cl=$(mktemp --suffix=.git-process-changelog)
rm_on_exit $parsed_cl
declare pcl=$(which parse-changelog)
declare pcl_flags=''
declare noless=''
declare git_editor
declare skip_no_changelog

## Options first
OPTSARGS=$(getoptp -o hv --long commit,withstatus,diff,noless,help,editor:,skip-no-changelog -n $FUNCNAME -- "$@")
status=$?
((status != 0)) && $usage_func && exit $status

eval set -- "$OPTSARGS"
while true
do
    case "$1" in
        -v) opt_v=$1
            shift;;
        --commit)
            action=commit;
            pcl_flags="$pcl_flags --write --ncl $parsed_cl"
            shift ;;
        --withstatus)
            action=withstatus;
            pcl_flags="$pcl_flags --withstatus";
            shift ;;
        --diff)
            pcl_flags="$pcl_flags --diff"
            shift ;;
        --noless)
            noless=1
            shift ;;
        --skip-no-changelog)
            skip_no_changelog='--skipmissing'
            shift ;;
        --editor)
            git_editor=$2
            shift; shift;;
        -h|--help) $usage_func; exit $OK ;;
        --) shift; break ;; ## end of opts, remaining $*, if any, are args
        *) echo "Internal error!"; $usage_func; exit $NOT_OK ;;
    esac
done

## Everything else is a file
if [ -z $1 ]
then
    echo "No files specified."
    [ -n "$gr" ] && _git-cd-exit
    exit $NOT_OK
fi
declare filelist
for i in "$@"
do
    filelist="$filelist $(realpath $i)"
done

## Find the changelog
declare changelogdir=$(git-root)
if ((status != 0))
then
    $usage_func
    [ -n "$gr" ] && _git-cd-exit
    exit $status
fi

declare changelog="${changelogdir}/$GITFUNCS_CHANGELOG_NAME"
if [ ! -r $changelog ]
then
    echo "$changelog not readable"
    [ -n "$gr" ] && _git-cd-exit
    exit $NOT_OK
fi
if [ "$action" = 'commit' ] && [ ! -w $changelog ]
then
    echo "$changelog not writable"
    [ -n "$gr" ] && _git-cd-exit
    exit $NOT_OK
fi

declare changelogbkp="${changelog}.bkp"

declare others=$(find $changelogdir -name $GITFUNCS_CHANGELOG_NAME | grep -v "$changelog")
if [ -n "$others" ]
then
    echo "Found $others. No other $GITFUNCS_CHANGELOG_NAME allowed under $changelogdir."
    [ -n "$gr" ] && _git-cd-exit
    exit $NOT_OK
fi

## Backup
cp -f $changelog $changelogbkp
$DEBUG_PROCESS_CHANGELOG $pcl --cl $changelog $pcl_flags $skip_no_changelog $filelist
status=$?
if ((status!=0))
then
    [ -n "$gr" ] && _git-cd-exit
    exit $status
fi

if [ "$action" = 'commit' ]
then
    ## We rebuild the filelist from the commit message file so that we can
    ## account for having skipped files because they do not have a
    ## changelog entry.
    filelist=$(perl -ne 'next if $_ =~ m/^(SUMMARY LINE HERE|o | |[a-zA-Z0-9_-]+\(\):|\n)/;print $_' $parsed_cl)
    if [ -z "$git_editor" ]
    then
        git commit -F $parsed_cl --edit $opt_v $filelist
    else
        GIT_EDITOR=$git_editor git commit -F $parsed_cl --edit $opt_v $filelist
    fi
    status=$?
    if((status!=0))
    then
        ## Restore
        echo "Rolling back $changelog"
        cp -f $changelogbkp $changelog
        [ -n "$gr" ] && _git-cd-exit
        exit $status
    fi
fi
[ -f $changelogbkp ] && \rm -f $changelogbkp
[ -n "$gr" ] && _git-cd-exit
