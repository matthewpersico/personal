#!/opt/bb/bin/bash
##^Hardcoded bash location in case env not set up in cron.

## Control when cron jobs mail output

mailtype=''
mailto=$MAILTO
mailsubject=''
checkkinit=0
setx=0
setv=0
keeplog=0
endofopts=0
while [[ "$1" =~ ^- ]] && ((!endofopts))
do
    ## Strip all leading dashes here so that -foo and --foo can both
    ## be processed as 'foo'.
    original="$1"
    option="$1"
    declare new=''
    while [ ! "$new" = "$option" ] && [ ! "$option" = '--' ]
    do
        new=$option
        option=${option##-}
    done
    shift ## That way you avoid endless loops on invalid options.

    case $option in
        x)
            setx=1
            ;;
        v)
            setv=1
            ;;
        mailtype)
            mailtype=$(echo "$1" | tr '[:upper:]' '[:lower:]')
            shift
            ;;
        to)
            mailto="$1"
            MAILTO=$mailto; export MAILTO
            shift
            ;;
        keeplog)
            keeplog=1
            ;;
        subject)
            mailsubject="$1"
            shift
            ;;
        checkkinit)
            checkkinit=1
            ;;
        id )
            shift ## Specified so that there is something unique on the command
                  ## line for cron email subjects if there's a hard die. Not
                  ## used in the script anywhere.
             ;;
        help )
            echo "No documentation yet. Look at the code:"
            cat "$0"
            exit 0
            ;;
        --)
            endofopts=1 ## end of opts, remaining $*, if any, are args
            ;;
        *)
            echo "$original is an invalid option. See $0 --help"
            exit 1
            ;;
    esac


done

[ -z "$mailtype" ] && echo "Mail type required" && exit 1

dayofweek=$(date +%a | tr '[:upper:]' '[:lower:]')
args_ok=0
while ((!args_ok))
do
    case $mailtype in
        never )
            args_ok=1
            break
            ;;
        non-zero | if-output | if-no-output | today | always )
            [ -z "$mailto" ] && echo "Need valid email" && exit 1
            [ -z "$mailsubject" ] && echo "Need valid email subject" && exit 1
            args_ok=1
            break
            ;;
        $dayofweek )
            mailtype=today
            break
            ;;
        sun | mon | tue | wed | thu | fri | sat )
            ## We get here if the day in the mail type does not match today in
            ## the $dayoaweek case above
            mailtype=non-zero
            break
            ;;
        * )
            echo "Invalid mail type $mailtype"
            exit 1
            break
            ;;
    esac
done

temproot=$(mktemp -t cron_wrapper.XXXXXXXXXX)
alllog=${temproot}.alllog
profilelog=${temproot}.profilelog
did_profile=0

for p in ${TILDAE:-$HOME}/.bash_profile.${USER} \
                         ${TILDAE:-$HOME}/.bash_profile \
                         ${TILDAE:-$HOME}/.profile.${USER} \
                         ${TILDAE:-$HOME}/.profile
do
    if [ -r "$p" ] && ((!did_profile))
    then
        # Environment setup here.
        # shellcheck disable=SC1090 ## cannot find sourced file at shellcheck time
        . "$p" > "$profilelog"
        did_profile=1
    fi
done

if ((!did_profile))
then
    echo 'ERROR - No profiles found before trying to run'
    echo "$@"
    echo
    cat "$profilelog"
    exit 42
fi

# shellcheck disable=SC1090 ## cannot find sourced file at shellcheck time
source "$BASH_INC_DIR/on_exit.binc"
rm_on_exit "$temproot" "$alllog" "$profilelog"

if((checkkinit))
then
    klist -s
    status=$?
    if((status))
    then
        backoff="$(dirname "$(realpath "$0")")/../data/cron_wrapper.kinit.${mailsubject// /_})"
        if [ -e "$backoff" ]
        then
            was=$(cat "$backoff")
            now=$(date +%s)
            if ((now-was<86399))
            then
                exit 0 ## Once a day email on a kerberos expiration
            fi
        fi
        echo 'ERROR - kerberos ticket has expired before trying to run'
        echo "$@"
        echo
        echo 'Expiration(s):'
        klist | cut -d ' ' -f4,5 | sort -u | grep '/'
        date +%s > "$backoff"
        echo 'Now:'
        date '+%m/%d/%y %H:%M:%S'
        echo
        echo 'This is a ONCE-A-DAY notification, regardless of cron schedule.'
        exit $status
    fi
fi

holdstdout=$(get-next-descriptor)
eval "exec $holdstdout>&1"  # Link file descriptor with stdout, which saves stdout.
exec 1>> "$alllog"  # Re-point stdout to the log.

holdstderr=$(get-next-descriptor)
eval "exec $holdstderr>&2"  # Link file descriptor with stderr, which saves stderr.
exec 2>> "$alllog"  # Re-point stderr to the log.

##
## Here is where the command gets executed
##
status=0

## We set up a trap here to make sure that if the command dies so hard that the
## rest of this script does not run, we get something from the shunted output.
# shellcheck disable=SC1078
# shellcheck disable=SC1079
trap "eval ""exec 1>&$holdstdout $holdstdout>&-""      # Restore stdout and close file descriptor.
      eval ""exec 2>&$holdstderr $holdstderr>&-""      # Restore stderr and close file descriptor.
      [ -f $profilelog ] && cat $profilelog
      [ -f $alllog ]     && cat $alllog
     " SIGTERM SIGINT SIGFPE SIGBUS

((setx)) && set -x
((setv)) && set -v
"$@" ## This is where we execute the command with arguments. Everything else
     ## above and below is boilerplate. Sheeesh.
status=$?
((setv)) && set +v
((setx)) && set +x

# The restorations will cause any mail errors to be sent to you via the regular
# cron error channels.
eval "exec 1>&$holdstdout $holdstdout>&-"      # Restore stdout and close file descriptor.
eval "exec 2>&$holdstderr $holdstderr>&-"      # Restore stderr and close file descriptor.

subsubject=''
mailthelog=0
if ((status))
then
    if [ "$mailtype" = 'non-zero' ]
    then
        mailthelog=1
        subsubject="Non-zero exit ($status)"
    elif [ ! "$mailtype" = 'never' ]
    then
        mailthelog=1 ## We always grab the log if there is an issue.
        subsubject="Issue - Exit status: $status"
    fi
else
    subsubject="Success"
    if [ "$mailtype" = 'if-no-output' ]
    then
        mailthelog=$(wc -c < "$alllog")
        if ((mailthelog==0))
        then
            mailthelog=1
            subsubject='Issue - No output'
        fi
    elif [ "$mailtype" = 'if-output' ]
    then
        mailthelog=$(wc -c < "$alllog")
    elif [ "$mailtype" = 'today' ]
    then
        mailthelog=1
        subsubject="Success, $(date +%A) check"
    elif [ "$mailtype" = 'never' ] || [ "$mailtype" = 'non-zero' ]
    then
        mailthelog=0
    elif [ "$mailtype" = 'always' ]
    then
        mailthelog=1
    else
        subsubject="Success, but unknown mailtype $mailtype. Mailing the log."
        mailthelog=1
    fi
fi

exitstatus=0

if ((mailthelog))
then
    if [ -n "$mailto" ]
    then
        mailx -s "$subsubject - $mailsubject" \
              "$mailto" \
              <<EOM
$subsubject
$( ((status)) && cat "$profilelog";cat "$alllog")
EOM
        exitstatus=0 ## we mailed off the error, if any
        exit 0
    else
        cat <<EOM
$subsubject
$( ((status)) && cat "$profilelog";cat "$alllog")
EOM
        exitstatus=$status ## we need to force the mail of the log, to at least
                           ## the cron owner.
    fi
fi

if ((keeplog))
then
    ## Writing anything to stdout or stderr forces what is written to be
    ## mailed. This will happen despite any settings to the contrary above. It
    ## will also use the default MAILTO, unless you have specified --to, in
    ## which case we override MAILTO with the argument of --to.
    echo "--keeplog specified. Logs are"
    echo "alllog - $alllog"
    echo "profilelog - $profilelog"
else
    \rm -f "$temproot" "$alllog" "$profilelog"
fi

exit $exitstatus
