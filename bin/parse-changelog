#!/usr/bin/env perl

use strict;
use warnings;

use Cwd;
use Data::Dumper; ## for debugging.
use File::Basename;
use File::Spec::Functions qw(abs2rel catfile rel2abs);
use Getopt::Long;
use IO::File;

my @oldput;

my $file;
my $function;
my $text;
my %current = ();
my %output = ();
my %opt = (
    cl => undef,
    ncl => undef,
    diff => 0,
    write => 0,
    withstatus => 0,
    missingok => 0,
);
my $exit = 0;

GetOptions(\%opt,
           'cl=s',
           'ncl=s',
           'diff',
           'write',
           'withstatus',
           'missingok' ) or die "Bad options";

die "-cl ChangeLog option required"
  if( !$opt{cl} );
$opt{cl} = rel2abs($opt{cl});
my $cldir = dirname($opt{cl});

if( $opt{write} ) {
    die "Cannot set --write when one or more of --withstatus, --missingok, --diff are specified"
        if ( $opt{withstatus}
             or $opt{missingok}
             or $opt{diff});

    if( !$opt{ncl} ) {
        die "-ncl ChangeLog option required with --write";
    } else {
        $opt{ncl} = rel2abs($opt{ncl});
    }
} elsif( $opt{ncl} ) {
    warn "parse-changelog: -ncl ChangeLog option ignores without --write\n";
}

## You must specify all the files for which you want to grab a changelog
## entry. If you want to infer the list from the state of repo where the
## changelog lives, that's an issue for the caller of this program.
for (@ARGV) {
    if (substr($_, 0, 1) ne '/') {
        warn "parse-changelog: $_ is not a fully qualified filename (does not start with '/'. Fatal.\n";
        $exit++;
    } elsif ( ! -e $_ ) {
        warn "parse-changelog: $_ not found." . ($opt{write} ? ' Fatal.' : '') . "\n";
        $exit++ if $opt{write};
    } elsif ( -d $_ ) {
        warn "parse-changelog: $_ is a directory." . ($opt{write} ? ' Fatal.' : '') . "\n";
        $exit++ if $opt{write};
    }
}
if ($exit) {
    print STDERR "Aborting...\n";
    exit 1;
}

my $cwd = cwd();
my %files = map { $_ =>
                    {
                        cl_entry_found => 0,
                        local_name => abs2rel($_, $cwd),
                        abs_name => $_,
                        cl_name => abs2rel($_, $cldir)
                    }
                } @ARGV;

my @status;
my %diff;
if($opt{withstatus}) {
    $opt{missingok}=1;
    @status = qx(git -c color.status=always status @ARGV);
}

if($opt{diff}) {
    $opt{missingok}=1;
    my @diff = qx(git -c color.diff=always diff @ARGV);
    my $entry;
    for my $line (@diff) {
        if ($line =~ m/^....diff --git a/) {
            $entry = $line;
            chomp $entry;
            $entry =~ s|.*b/||;
            $entry =~ s|([/a-zA-Z0-9_.-]+).*|$1|; ## really need this?
            $entry = rel2abs($entry, $cwd); ## because diff outputs relative
                                            ## path, even if FQP is provided.
            $diff{$entry} = [];
        }
        push @{$diff{$entry}}, $line;
    }
}

my $clih = IO::File->new($opt{cl}, "r")
  or die "Cannot open $opt{cl} for read:$!";

my $filetag_re = qr(^\s+\* ([a-zA-Z0-9_./-]+));
my $functag_re = qr([(]([a-zA-Z0-9_.-]+)[)]);

## Parse the changelog.
LINE: while (<$clih>) {
    chomp;

    if ( /^\d{4,4}-\d{2,2}-\d{2,2}/ ) {
        ## date and user header line
        push @oldput, [];
        push @{$oldput[-1]}, $_;
    } elsif (length($_) == 0 ) {
        ## blank
        push @{$oldput[-1]}, $_;
        %current=();
    } elsif ( /^\s+$/) {
        ## technically blank, so let's make it so
        push @{$oldput[-1]}, '';
        %current=();
    } else {
        ## Parsing assumptions:

        ## 1) One ChangeLog in git-root for whole project

        ## 2) No Esc-Q to wrap text. Otherwise, we cannot tell the difference
        ## between

        ## * (func): this is a very very very long
        ##   wrapped func text

        ## * file (func): this is a very short text
        ##   this is non-func-based text

        ## Unless at some point, we hijack ESC-Q to put in \ continuation
        ## characters when we wrap or always add the file when adding
        ## non-func-based text.

        if( m|${filetag_re} ${functag_re}: (.*)|) {
            ## * file (function): text
            $file = catfile($cldir, $1);
            $function = $2;
            ($text = $3) =~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif( m|${filetag_re}: (.*)|) {
            ## * file: text
            $file = catfile($cldir, $1);
            $function = '<generic>';
            ($text = $2) =~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif ( m|${functag_re}: (.*)|) {
            ## (function): text
            $file = $current{'file'};
            $function = $1;
            ($text = $2)=~ s/^\s+//;
            $text =~ s/\s+$//;
        } else {
            ## text
            $file = $current{file};
            $function = '<generic>';
            ($text = $_) =~ s/^\s+//;
            $text =~ s/\s+$//;
        }

        @current{qw(file function)} = ($file, $function);

        if( defined $files{$file} ) {
            ## The current entry corresponds to a file we are processing.

            ## Mark that a changelog entry has been found.
            $files{$file}->{cl_entry_found} = 1;

            ## Init the output if needed.
            $output{$file}->{$function} = []
              if not defined $output{$file}->{$function};

            ## Save the text.
            push @{$output{$file}->{$function}}, $text;
        } else {
            ## Not wanted. Store for push back to changelog.
            push @{$oldput[-1]}, $_;
        }
    }
}
$clih->close();

## See about files with no changelog entries.
my %nocl;
for (keys %files) {
    if( $files{$_}->{cl_entry_found} == 0 ) {
        if ($opt{missingok}) {
            $nocl{$_} = $opt{cl};
        } else {
            print STDERR "$_ has no entry in $opt{cl}.\n";
            $exit++;
        }
    }
}
if ($exit) {
    print STDERR "Aborting...\n";
    exit 1;
}

## Where to write the entries that matched.
my $clnew;
my $clnewh;
if( $opt{write} ) {
    $clnew = $opt{ncl};
    $clnewh =  IO::File->new($clnew, "w")
      or die "Cannot open $clnew for write:$!";
} else {
    $clnewh = *STDOUT;
}

my $tracked_re_string  = q(\x{1b}\[\(\d+;\){0,1}\d{2,2};\d{2,2}m[a-z]+:\s+<PLACEHOLDER>\x{1b}\[m);
my $untracked_re_string = q(\x{1b}\[\(\d+;\){0,1}\d{2,2};\d{2,2}m<PLACEHOLDER>\x{1b}\[m);
if (@status) {
    ## Mixing in the changelog entries with git status output.
    my @files = keys %output;
  STATUS: for my $sline (@status) {
        $clnewh->print($sline);
        chomp $sline;
        next STATUS if $sline eq '';
      FILE: for my $file (@files) {
            if (not defined $files{$file}->{re}) {
                my $comp = $files{$file}->{local_name};
                ($files{$file}->{re}->{tracked} = $tracked_re_string) =~ s/<PLACEHOLDER>/$comp/;
                $files{$file}->{re}->{tracked} = qr($files{$file}->{re}->{tracked});
                ($files{$file}->{re}->{untracked} = $untracked_re_string) =~ s/<PLACEHOLDER>/$comp/;
                $files{$file}->{re}->{untracked} = qr($files{$file}->{re}->{untracked});
            }
            if( $sline =~ m|$files{$file}->{re}->{tracked}|
                  or
                  $sline =~ m|$files{$file}->{re}->{untracked}|) {
                my $filedata = $output{$file};
                for $function (sort keys %{$filedata}) {
                    $clnewh->print(
                        ' ' x 20,
                        $function ne '<generic>'
                          ? "($function): " : '',
                        "@{$filedata->{$function}}\n");
                }
                if(exists($diff{$file})) {
                    $clnewh->print(@{$diff{$file}});
                }
                next STATUS;
            }
        }
        (my $file_from_sline = $sline ) =~ s/.*:\s+([a-zA-Z0-9_.-]+)/$1/;
        $clnewh->print(' ' x 21, "*** No entry in $nocl{$file_from_sline}. ***\n")
          if (exists ($nocl{$file_from_sline}));
    }
} else {
    ## Just write the output.
    for $file (sort keys %output) {
        my $filedata = $output{$file};
        my $printfile = $files{$file}->{cl_name};
        for $function (sort keys %{$filedata}) {
            $clnewh->print("$printfile",
                           $function ne '<generic>' ? " ($function)" : '',
                           ": @{$filedata->{$function}}\n");
            $printfile =~ s/./ /g; ## All chars to spaces to not repeat the
                                   ## file name.
        }
        if(exists($diff{$file})) {
            $clnewh->print(@{$diff{$file}});
        }
    }
}

if( $opt{write} ) {
    ## Now store the unused entries back in the changelog.

    ## Close the new entries file.
    $clnewh->close();

    if (@oldput) {
        ## Reopen the changelog.
        my $cloldh =  IO::File->new($opt{cl}, "w")
          or die "Cannot open $opt{cl} for re-write:$!";

        my @tmpout;
        my @newout;
        for my $group (@oldput) {
            my $non_blank_non_date_count=0;
            my $prev='';
          LINE: for my $line (@{$group}) {
                if ($line =~ m/^\d{4,4}-\d{2,2}-\d{2,2}/) {
                    push @newout, @tmpout
                      if( @tmpout > 2);
                    @tmpout = ($line);
                    next LINE;
                }

                push @tmpout, $line
                  if( $tmpout[-1] ne $line );
            }

            ## Last one
            push @newout, @tmpout
              if( @tmpout > 2);
        }
        $cloldh->print(@newout);
        $cloldh->close();
    }
}

exit 0;
