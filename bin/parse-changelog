#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use File::Basename;
use File::Spec::Functions;
use Getopt::Long;
use IO::File;
use List::MoreUtils qw{uniq};

my @oldput;

my $file;
my $function;
my $text;
my %current = ();
my %output = ();
my %opt = (
    diff => 0,
    write => 0,
    withstatus => 0,
    missingok => 0,
);
my $exit = 0;

GetOptions(\%opt,
           'diff',
           'write',
           'withstatus',
           'missingok' ) or die "Bad options";

die "Cannot set --write when one or more of --withstatus, --missingok, --diff are specified"
  if( $opt{write}
        and ( $opt{withstatus}
              or $opt{missingok}
              or $opt{diff}) );

my $changelog = shift;
my $commondir=dirname($changelog);

## You must specify all the files for which you want to grab a changelog
## entry. If you want to infer that from the state of wherever the changelog
## lives, that's an issue for the caller of this program.
for (@ARGV) {
    if ( ! -f $_ ) {
        print STDERR "$_ not found\n";
        $exit++;
    }
}
if ($exit) {
    print STDERR "Aborting...\n";
    exit 1;
}

## Because even if @ARGV is relative to some other directory where we started
## from, we match it up here to the directory of the ChangeLog that references
## it.
my %files = map { catfile(dirname($_), basename($_)) => 0 } grep { -f $_ } @ARGV;

my @status;
my %diff;
if($opt{withstatus}) {
    $opt{missingok}=1;
    @status = qx(git -c color.status=always status @ARGV);
}

if($opt{diff}) {
    $opt{missingok}=1;
    my @diff = qx(git -c color.diff=always diff @ARGV);
    my $entry;
    for my $line (@diff) {
        if ($line =~ m/^....diff --git a/) {
            $entry = $line;
            $entry =~ s|.*b/||;
            $entry =~ s|([/a-zA-Z0-9_.-]+).*|$1|;
            chomp $entry;
            $entry = catfile($commondir,$entry)
              if ($commondir eq '.');
            $diff{$entry} = [];
        }
        push @{$diff{$entry}}, $line;
    }
}

my $clih = IO::File->new($changelog, "r")
  or die "Cannot open $changelog for read:$!";

## Parse the changelog.
LINE: while (<$clih>) {
    chomp;

    if ( /^\d{4,4}-\d{2,2}-\d{2,2}/ ) {
        ## date and user header line
        push @oldput, [];
        push @{$oldput[-1]}, $_;
    } elsif (length($_) == 0 ) {
        ## blank
        push @{$oldput[-1]}, $_;
        %current=();
    } elsif ( /^\s+$/) {
        ## technically blank, so let's make it so
        push @{$oldput[-1]}, '';
        %current=();
    } else {
        if( /^\s+\* ([a-zA-Z0-9_.-]+) \(([a-zA-Z0-9_.-]+)\): (.*)/) {
            ## * file (function): text
            $file = catfile($commondir,$1);
            $function = $2;
            ($text = $3) =~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif( /^\s+\* ([a-zA-Z0-9_.-]+): (.*)/) {
            ## * file: text
            $file = catfile($commondir,$1);
            $function = '<generic>';
            ($text = $2) =~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif (/^\s+\(([a-zA-Z0-9_.-]+)\): (.*)/) {
            ## (function): text
            $file = $current{'file'};
            $function = $1;
            ($text = $2)=~ s/^\s+//;
            $text =~ s/\s+$//;
        } else {
            ## text
            $file = $current{file};
            $function = $current{function};
            ($text = $_) =~ s/^\s+//;
            $text =~ s/\s+$//;
        }

        @current{qw(file function)} = ($file, $function);

        if( defined $files{$file} ) {
            ## The current entry corresponds to a file we are processing.

            ## Mark that a changelog entry has been found.
            $files{$file} = 1;

            ## Init the output if needed.
            $output{$file}->{$function} = []
              if not defined $output{$file}->{$function};

            ## Save the text.
            push @{$output{$file}->{$function}}, $text;
        } else {
            ## Not wanted. Store for push back to changelog.
            push @{$oldput[-1]}, $_;
        }
    }
}
$clih->close();

## See about files with no changelog entries.
my %nocl;
while ( my ($k, $v) = each (%files)) {
    if( $v == 0 ) {
        if ($opt{missingok}) {
            $nocl{$k} = $changelog;
        } else {
            print STDERR "$k has no entry in $changelog.\n";
            $exit++;
        }
    }
}
if ($exit) {
    print STDERR "Aborting...\n";
    exit 1;
}

## Where to write the entries that matched.
my $clnew;
my $clnewh;
if( $opt{write} ) {
    $clnew = $changelog . ".new";
    $clnewh =  IO::File->new($clnew, "w")
      or die "Cannot open $clnew for write:$!";
} else {
    $clnewh = *STDOUT;
}

if (@status) {
    ## Mixing in the changelog entries with git status output.
    $clnewh->print(join("\n",
                        '*'x(10 + length($changelog)),
                        "**** $changelog ****",
                        '*'x(10 + length($changelog)),
                        ''));
    my @files = keys %output;
  STATUS: for my $sline (@status) {
        $clnewh->print($sline);
        chomp $sline;
        next STATUS if $sline eq '';
      FILE: for my $file (@files) {
            my $comp = $file;
            ## Special case where file is './x' and entry in status is 'x'.
            $comp =~ s|^\./||;
            if( $sline =~ m/$comp/) {
                my $filedata = $output{$file};
                for $function (sort keys %{$filedata}) {
                    $clnewh->print(
                        ' ' x 20,
                        $function ne '<generic>'
                          ? "($function): " : '',
                        "@{$filedata->{$function}}\n");
                }
                if(exists($diff{$file})) {
                    $clnewh->print(@{$diff{$file}});
                }
                next STATUS;
            }
        }
        (my $file_from_sline = $sline ) =~ s/.*:\s+([a-zA-Z0-9_.-]+)/$1/;
        $clnewh->print(' ' x 21, "*** No entry in $nocl{$file_from_sline}. ***\n")
          if (exists ($nocl{$file_from_sline}));
    }
} else {
    ## Just write the output.
    for $file (sort keys %output) {
        my $filedata = $output{$file};
        my $printfile = $file;
        for $function (sort keys %{$filedata}) {
            $clnewh->print("$printfile",
                           $function ne '<generic>' ? " ($function)" : '',
                           ": @{$filedata->{$function}}\n");
            $printfile =~ s/./ /g;
        }
        if(exists($diff{$file})) {
            $clnewh->print(@{$diff{$file}});
        }
    }
}

if( $opt{write} ) {
    ## Now store the unused entries back in the changelog.

    ## Close the new entries file.
    $clnewh->close();

    if (@oldput) {
        ## Reopen the changelog.
        my $cloldh =  IO::File->new($changelog, "w")
          or die "Cannot open $changelog for re-write:$!";

        my @tmpout;
        my @newout;
        for my $group (@oldput) {
            my $non_blank_non_date_count=0;
            my $prev='';
          LINE: for my $line (@{$group}) {
                if ($line !~ m/^\d{4,4}-\d{2,2}-\d{2,2}/) {
                    push @newout, @tmpout
                      if( @tmpout > 2);
                    @tmpout = ($line);
                    next LINE;
                }

                push @tmpout, $line
                  if( $tmpout[-1] ne $line );
            }

            ## Last one
            push @newout, @tmpout
              if( @tmpout > 2);
        }
        $cloldh->print(@newout);
        $cloldh->close();
    }
}

exit 0;
