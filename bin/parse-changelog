#!/usr/bin/env perl

## DEBUG: #!/opt/bb/bin/perl -d:ptkdb

use strict;
use warnings;

use Cwd;
use Data::Dumper; ## for debugging.
use File::Basename;
use File::Spec::Functions qw(abs2rel canonpath catfile rel2abs);
use Getopt::Long;
use IO::File;
use Text::Wrap qw(wrap);
$Text::Wrap::columns = 72;

use constant NOFUNC => '!File Scope'; ## the ! will sort this before all function names.
use constant NOCLENTRY => 'NOCLENTRY';

## This script works best in the git root, which is where the Changelog is anyway
my $cwd = cwd();
#my $gr = qx(git rev-parse --show-toplevel);
#die "Current directory ($cwd) is not the git root ($gr)"
#  if( $cwd ne $gr);

my @oldput;

my $file;
my $function;
my $text;
my %current = ();
my %output = ();
my %opt = (
    cl => undef,
    newcl => undef,
    diff => 0,
    cached => 0,
    noclonly => 0,
    write => 0,
    withstatus => 0,
    missingok => 0,
    skipmissing => 0,
    skipgcs => 0,
    confirm => 0,
);
my $exit = 0;
my %deleted;
my %format_seen;
my $marker = join('', qw( < G C S > ));
my $excl_marker = join('', qw( < G C S L I T E R A L > ));

select((select(STDOUT), $| = 1)[0]);
select((select(STDERR), $| = 1)[0]);

GetOptions(\%opt,
           'cl=s',
           'newcl|ncl=s',
           'diff',
           'cached',
           'noclonly',
           'write',
           'withstatus',
           'missingok',
           'skipmissing',
           'skipgcs',
           'relok',
       ) or die "Bad options";

die "-cl ChangeLog option required"
  if( !$opt{cl} );
$opt{cl} = rel2abs($opt{cl});
my $cldir = dirname($opt{cl});

if( $opt{write} ) {
    die "Cannot set --write when one or more of --withstatus, --missingok, --diff, --cached are specified"
        if ( $opt{withstatus}
             or $opt{missingok}
             or $opt{diff}
             or $opt{cached});

    if( !$opt{newcl} ) {
        die "-newcl ChangeLog option required with --write";
    } else {
        $opt{newcl} = rel2abs($opt{newcl});
    }
} elsif( $opt{newcl} ) {
    warn "parse-changelog: -newcl ChangeLog option ignored without --write\n";
}

## You must specify all the files for which you want to grab a changelog
## entry. If you want to infer the list from the state of repo where the
## changelog lives, that's an issue for the caller of this program.
for (@ARGV) {
    if (substr($_, 0, 1) ne '/') {
        if( $opt{relok} ) {
            $_ = rel2abs($_);
        } else {
            warn "parse-changelog: $_ is not a fully qualified filename (does not start with '/'. Fatal.\n";
            $exit++;
            next;
        }
    }
    if ( ! -e $_ ) {
        my @ok=qx(git status $_ | grep deleted:);
        if(scalar(@ok) != 1 ) {
            warn "parse-changelog: $_ not found." . ($opt{write} ? ' Fatal.' : '') . "\n";
            $exit++ if $opt{write};
        } else {
            $deleted{$_}=1;
        }
    } elsif ( -d $_ ) {
        if ( $opt{write} ) {
            warn "parse-changelog: $_ is a directory." . ($opt{write} ? ' Fatal.' : '') . "\n";
            $exit++ ;
        }
    }
}
if ($exit) {
    print STDERR "Aborting...\n";
    exit 1;
}

my %files = map { $_ => init_file_info ($_)
                } @ARGV;
my @file_list = map { $_->{cl_name} } values %files;

my @status;
my %diff;
if($opt{withstatus}) {
    $opt{missingok}=1;
    @status = qx(git -c color.status=always status @file_list);
}

################################
## Grab diffs if so requested ##
################################
if($opt{diff}) {
    $opt{missingok}=1;
    my $cached='';
    $cached = '--cached' if $opt{cached};
    ## Remove any deleted or moved files
    my @diff_list = ( map {chomp; substr($_,3)}
                        grep { ! m/^RM/ }
                        grep { ! m/^[D ]{2,2}/ }
                        qx(git status --porcelain @file_list));
    my @diff = map {chomp; $_} qx(git -c color.diff=always diff $cached @diff_list);
    my $entry;
    for my $line (@diff) {
        if ($line =~ m/^....diff --git a/) {
            $entry = $line;
            $entry =~ s|.*b/||;
            $entry =~ s|([/a-zA-Z0-9_.-]+).*|$1|; ## really need this?
            $entry = rel2abs($entry, $cwd); ## because diff outputs relative
                                            ## path, even if FQP is provided.
            $diff{$entry} = [];
        }
        push @{$diff{$entry}}, $line;
    }
}

my $clih = IO::File->new($opt{cl}, "r")
  or die "Cannot open $opt{cl} for read:$!";

my $filetag_re = qr(^\s+\* ([a-zA-Z0-9_./-]+));
my $functag_re = qr([(]([a-zA-Z0-9_.*\<\>\[\]\|/,: -]+)[)]);

my $entry_id = 0; ## A serial number, monotonically increasing. We assign one
                  ## to each new entry because 1) we are getting a new entry
                  ## for each comment 2) the entries are entered at the top of
                  ## the changelog. So to get the right chronological flow to
                  ## the output, we have to reverse the entries.

#########################
## Parse the changelog ##
#########################
LINE: while (<$clih>) {
    chomp;

    if ( /^\d{4,4}-\d{2,2}-\d{2,2}/ ) {
        ## date and user header line
        $entry_id++;
        push @oldput, [];
        push @{$oldput[-1]}, $_;
    } elsif (length($_) == 0 ) {
        if($entry_id) {
            ## blank
            push @{$oldput[-1]}, $_;
            %current=();
        } ## else it's a blank line before first entry - ignore fat fingered
          ## typing
    } elsif ( /^\s+$/) {
        ## technically blank, so let's make it so
        push @{$oldput[-1]}, '';
        %current=();
    } else {
        ## Parsing assumptions:
        ## 1) One ChangeLog in git root for whole project.
        ## 2) Emacs variable add-log-always-start-new-record is set to 't'.
        ## 3) With #2, we can use Esc-Q to wrap text.

        if( m|${filetag_re}\s*${functag_re}:\s*(.*)|) {
            ## * file\s*(function):\s*text
            $file = catfile($cldir, $1);
            $function = $2;
            ($text = $3) =~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif( m|${filetag_re}:\s*(.*)|) {
            ## * file:\s*text
            $file = catfile($cldir, $1);
            $function = NOFUNC;
            ($text = $2) =~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif ( m|${functag_re}:\s*(.*)|) {
            ## (function):\s*text
            $file = $current{'file'};
            $function = $1;
            ($text = $2)=~ s/^\s+//;
            $text =~ s/\s+$//;
        } elsif ( m|${filetag_re}$|) {
            ## * file
            $current{file} = catfile($cldir, $1);
            next LINE; ## No function or text to be found
        } else {
            ## text
            $file = $current{file};
            $function = $current{function};
            ($text = $_) =~ s/^\s+//;
            $text =~ s/\s*$//;
        }

        @current{qw(file function)} = ($file, $function);

        if (not defined $file) {
            my $dummy = 6;
        }

        if( defined $files{$file} ) {
            ## The current entry corresponds to a file we are processing.

            ## Mark that a changelog entry has been found.
            $files{$file}->{cl_entry_found} = 1;

            ## Init the output if needed.
            $output{$file}->{$function}->{$entry_id} = []
              if not defined $output{$file}->{$function}->{$entry_id};

            ## Save the text.
            push @{$output{$file}->{$function}->{$entry_id}}, $text;
        } else {
            ## Not wanted. Store for push back to changelog.
            push @{$oldput[-1]}, $_;
        }
    }
}
$clih->close();

## See about files with no changelog entries.
my %nocl;
for (keys %files) {
    if( $files{$_}->{cl_entry_found} == 0 ) {
        if ($opt{missingok} || $opt{skipmissing}) {
            $nocl{$_} = $opt{cl};
        } else {
            print STDERR "$_ has no entry in $opt{cl}.\n";
            $exit++;
        }
    }
}
if ($exit) {
    print STDERR "Aborting...\n";
    exit 1;
}
if ( %nocl and $opt{skipmissing}) {
    delete @files{keys %nocl};
}

#############################################
## Where to write the entries that matched ##
#############################################
my $clnew;
my $clnewh;
if( $opt{write} ) {
    $clnew = $opt{newcl};
    $clnewh =  IO::File->new($clnew, "w")
      or die "Cannot open $clnew for write:$!";
} else {
    $clnewh = *STDOUT;
}

###################
## Create output ##
###################
my $renamed_re_string  = q(\x{1b}\[\(\d+;\){0,1}\d{2,2};\d{2,2}m[a-z ]+:\s+<PLACEHOLDER>\s->.*\x{1b}\[m);
my $tracked_re_string  = q(\x{1b}\[\(\d+;\){0,1}\d{2,2};\d{2,2}m[a-z ]+:\s+<PLACEHOLDER>\x{1b}\[m);
my $untracked_re_string = q(\x{1b}\[\(\d+;\){0,1}\d{2,2};\d{2,2}m<PLACEHOLDER>\x{1b}\[m);
my @output;
my $format_over;
if (@status) {
    ##
    ## Mixing in the changelog entries with git status output.
    ##
    my @files = keys %output;
    $format_over = ' ' x 8;
  STATUS: for my $sline (@status) {
        chomp $sline;
        push @output, $sline;
        next STATUS if $sline eq '';
      FILE: for my $file (@files) {
            if (not defined $files{$file}->{re}) {
                my $comp = $files{$file}->{local_name};
                ($files{$file}->{re}->{renamed} = $renamed_re_string) =~ s/<PLACEHOLDER>/$comp/;
                $files{$file}->{re}->{renamed} = qr($files{$file}->{re}->{renamed});
                ($files{$file}->{re}->{tracked} = $tracked_re_string) =~ s/<PLACEHOLDER>/$comp/;
                $files{$file}->{re}->{tracked} = qr($files{$file}->{re}->{tracked});
                ($files{$file}->{re}->{untracked} = $untracked_re_string) =~ s/<PLACEHOLDER>/$comp/;
                $files{$file}->{re}->{untracked} = qr($files{$file}->{re}->{untracked});
            }
            if( $sline =~ m|$files{$file}->{re}->{renamed}|
                  or
                  $sline =~ m|$files{$file}->{re}->{tracked}|
                  or
                  $sline =~ m|$files{$file}->{re}->{untracked}|) {
                push_to_output($file);
                next STATUS;
            }
        }

        (my $local_name_from_sline = $sline ) =~ s|.*:\s+([a-zA-Z0-9_./-]+).*|$1|;
        my $abs_name_from_sline = canonpath(catfile(cwd(), $local_name_from_sline) );
        my $cl_name_from_sline = abs2rel($abs_name_from_sline, $cldir);
        if (exists ($nocl{$abs_name_from_sline})) {
            my $function = NOCLENTRY;
            $output{$abs_name_from_sline}->{$function}->{$entry_id++} = [ 'NE' ];
###              [ "*** No Changelog entry in $nocl{$abs_name_from_sline} for $cl_name_from_sline. ***"];
            push_to_output($abs_name_from_sline);
        }
    }
} else {
    ##
    ## Just write the changelog output.
    ##
    $format_over = '';
    my $morethan1=-1;
    for $file (sort keys %output) {
        $morethan1++;
        push_to_output($file, $files{$file}->{cl_name});
    }
    unshift @output, "SUMMARY LINE HERE"
      if ($morethan1);
}

$clnewh->print(join("\n", @output))
  if(@output);

#####################
## Post processing ##
#####################
if( $opt{write} ) {
    ## Now store the unused entries back in the changelog.

    ## Close the new entries file.
    $clnewh->close();

    if (@oldput) {
        ## Reopen the changelog.
        my $cloldh =  IO::File->new($opt{cl}, "w")
          or die "Cannot open $opt{cl} for re-write:$!";

        my @tmpout;
        my @newout;
        for my $group (@oldput) {
            my $non_blank_non_date_count=0;
            my $prev='';
          LINE: for my $line (@{$group}) {
                if ($line =~ m/^\d{4,4}-\d{2,2}-\d{2,2}/) {
                    push @newout, @tmpout
                      if( @tmpout > 2);
                    @tmpout = ($line);
                    next LINE;
                }

                push @tmpout, $line
                  if( $tmpout[-1] ne $line );
            }

            ## Last one
            push @newout, @tmpout
              if( @tmpout > 2);
            @tmpout=();
        }
        if(!@newout) {
            ## Then we have eaten all the data, no lines to write back, but we
            ## have to write SOMETHING to get an empty file.
            push @newout, '';
        }
        $cloldh->print(join(qq(\n),@newout));
        $cloldh->close();
    }
}

sub set_indent_from_lead {
    return ' ' x length($_[0]);
}

sub push_to_output {
    my ($file, $header) = @_;
    my $filedata = $output{$file};
    my $functions_pushed = 0;

    if ($opt{noclonly} && $files{$file}->{cl_entry_found}) {
        pop @output; ## Remove the filename from the output
        return;
    }

    if(exists ($format_seen{$file})) {
        ## then we probably have one file in multiple sections. Print a
        ## reference here and move on.
        push @output,
          join('', $format_over, "Duplicate entry. See above."),
          '' ;
        return;
    }
    ## We compose the markers this way so that the grep does not
    ## falsely find this code.
    my @gcs;
    @gcs = `grep -i '$marker' $file | grep -v '$excl_marker'`
      if not exists $deleted{$file};
    if (@gcs) {
        if ( $opt{write} ) {
            if( $opt{skipgcs} ) {
                print STDERR join('',
                                  "Skipping $file, GCS Entries:\n",
                                  @gcs);
                return;
            } else {
                die join('',
                         "Cannot process commit with $file, GCS Entries:\n",
                         @gcs);
            }
        } else {
            push @output, map{"${format_over}$_"} ('GCS Entries:', map{chomp;$_} @gcs), '';
        }
    }

    my $space_files = 0;
    for $function (sort keys %{$filedata}) {
        my $lead = '  o '; ## Assume indent under a function entry.
        my $indent = set_indent_from_lead($lead);
        if ( not exists ($format_seen{$file})
               and
               defined($header) ) {
            push @output, join('', $format_over, $header);
        }
        if ( not exists ($format_seen{$file}->{$function}) ) {
            push @output, ''
              if ($functions_pushed);

            $format_seen{$file}->{$function} = 1;
            $functions_pushed++;
            if ( $function ne NOCLENTRY) {
                push @output, join('', $format_over, $function)
                  if( $function ne NOFUNC);
                if ($function =~ m|(.*)/$|) {
                    substr($output[-1], length($output[-1])-1, 1) = '(env)';
                } elsif( $function ne NOFUNC ) {
                    $output[-1] =~ s/,/(),/g;
                    $output[-1] .= '():'
                }
            }
        }
        for my $order (sort {$b <=> $a} keys %{$filedata->{$function}} ) {
            if( $function eq NOCLENTRY) {
                push @output, join('', $format_over, shift @{$filedata->{$function}->{$order}});
                $space_files = 1;
                if ($output[-1] eq "${format_over}NE") {
                    pop @output;
                    if(not @gcs) {
                        ## TO DO - work backwards in $output[-1] until you
                        ## reach the first non-control character and insert the
                        ## no entry found string. In this way, the string will
                        ## also be highlighted if the entry is highlighted
                        ## (highly likely as a git status output).
                        $output[-1] .= ': No Changelog entry found.';
                        $space_files = 0;
                    } else {
                        push @output, "${format_over}No Changelog entry found.";
                    }
                    @gcs=();
                }
            } else {
                my @wrapped = split(/\n/,wrap('','',@{$filedata->{$function}->{$order}}));
                my $line1 = shift(@wrapped);
                $line1 =~ s/^\s+//; ## If the file/function line is so long
                                    ## that the text is pushed to the next
                                    ## line, we get spurious space between the
                                    ## lead and the first word.
                if ( $function eq NOFUNC ) {
                    $lead = 'o '; ## Indent at file level; no func.
                    $indent = set_indent_from_lead($lead);
                }
                $line1 = join('', $format_over, $lead, $line1 );
                push @output,
                  $line1,
                  ## Line 2+
                  map { join( '', $format_over, $indent, $_ ) } @wrapped;
                $space_files = 1;
            }
        }
    }
    push @output, '' if($space_files);

    if (exists($diff{$file})) {
        push @output, (map { join( '', $format_over, $_ ) } @{$diff{$file}}), '';
    }
}

sub init_file_info {
    return  {
        cl_entry_found => 0,
        local_name => abs2rel($_[0], $cwd),
        abs_name => $_[0],
        cl_name => abs2rel($_[0], $cldir)
    };
}

exit 0;
