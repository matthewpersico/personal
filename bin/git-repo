#!/usr/bin/env bash

# git-repo - no .gitaudit, called on every prompt

if ! git-version-verify 'git-repo'
then
    exit 1
fi

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

## Global used to control 'cd'ing around
doandcdfile=''

git-repo-is ()
{
    declare verbose=0
    if [[ "$1" =~ -v ]]
    then
        verbose=1
        shift
    fi
    [[ "$1" ]] && [[ $1 != . ]] && (cd "$1" || return 1)
    git rev-parse --show-toplevel 2>/dev/null 1>&2
    status=$?
    [[ "$1" ]] && [[ $1 != . ]] && (cd - || return 1)
    (( verbose )) && ( (( status )) && echo false || echo true )
    return $status
}

git-repo-isa () { git-repo-is "$@"; }
git-repo-ina () { git-repo-is; }
git-repo-is_a () { git-repo-is "$@"; }
git-repo-in_a () { git-repo-is; }

git-repo-is_clean ()
{
    (( $(git st --porcelain | grep -cv '??') == 0 ))
}

git-repo-is_pristine ()
{
    (( $(git st --porcelain | wc -l) == 0 )) \
        && ( git worktree ina || (( $(git worktree list | wc -l) == 1 )) ) \
        && return 0
    if [[ $1 == '-v' ]]
    then
        (( $(git st --porcelain | wc -l) != 0 )) && git status
        if ! git worktree ina && (( $(git worktree list | wc -l) != 1 ))
        then
            echo Found worktrees:
            git worktree list
        fi
    fi
    return 1
}

git-repo-is_a_fork ()
{
    declare print=0
    if [[ $1 == '--print' ]]
    then
        shift
        print=1
    fi
    (
        # shellcheck disable=SC2164 #https://github.com/koalaman/shellcheck/wiki/SC2164
        cd "${1:-.}" # so that the git remote works on the current dir as well
                     # as a specified repo dir
        declare origin
        declare fork_of=''
        origin=$(git remote get-url origin)
        if [[ -n $origin ]]
        then
            declare server=${origin%%:*}
            declare repo_path=${origin##*:}
            fork_of=$(perl -e'
   use JSON::PP::Boolean;
our $VAR1;
eval "@ARGV";
$VAR1->{fork} && print $VAR1->{parent}{full_name};
' "$( github-api --silent --server "$server" --perl-data url repos/"$repo_path")")
        fi
        ((print)) && [[ -n "$fork_of" ]] && echo "$fork_of"
        [[ -n "$fork_of" ]] ## return value
    )
}

git-repo-is_a_fork_of ()
{
    git-repo-is_a_fork --print "$@"
}

git-repo-is_fork ()
{
    git-repo-is_a_fork "$@"
}

git-repo-is_fork_of ()
{
    git-repo-is_a_fork_of "$@"
}

git-repo-name ()
{
    [[ "$1" ]] && [[ $1 != . ]] && (cd "$1" || return 1)
    name=$(git remote -v 2>/dev/null | grep origin | sed 's|.*/||' | sed 's/ .*//' | sort -u)
    [[ "$1" ]] && [[ $1 != . ]] && (cd - || return 1)
    [ -z "$name" ] && return 1
    echo "$name"
    return 0
}

git-repo-diff ()
{
    declare moreopts=1
    declare nocolor=0
    declare name_only=0
    declare exclude=''
    declare side_by_side='-u'
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        ## but only deal with it if we really have an option. Otherwise you
        ## misinterpret items like this git clone option: --config
        ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
        if [[ $option =~ ^- ]]
        then
            if [[ "$option" =~ = ]]
            then
                okey=${option%%=*}
                ovalue=${option#*=}
                option="$okey"
            fi
        fi

        case $option in
            nocolor)
                nocolor=1 ;;
            exclude)
                exclude=${ovalue:-$1}; [ -z "$ovalue" ] && shift ;;
            side-by-side)
                side_by_side='-y --suppress-common-lines';;
            name-only | \
                names-only)
                name_only=1;;
            --)
                moreopts=0
                ;;
            * )
                cmd-echo -- "$original is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    declare -A repo
    if [ -n "$2" ]
    then
        repo[left]=$(realpath "$1")
        repo[right]=$(realpath "$2")
    elif [ -n "$1" ]
    then
        repo[left]=${PWD}
        repo[right]=$(realpath "$1")
    else
        cmd-echo -- "Need at least one directory"
        bash-usage "$0"; return 1 ;
    fi

    if [ "${repo[left]}" = "${repo[right]}" ]
    then
        cmd-echo -- "Other dir is this dir. Whoops! Bye."
        return 1
    fi

    declare -A list
    list[left]=$(mktemp -t tmp.git-diff-two-repos-on-disk.left.XXXXXXXXXX)
    list[right]=$(mktemp -t tmp.git-diff-two-repos-on-disk.right.XXXXXXXXXX)
    rm-on-exit "${list[left]}" "${list[right]}"

    # Get lists of files from each repo
    declare which
    declare -A leftfiles
    declare -A rightfiles
    for which in left right
    do
        perl -e 'chdir $ARGV[0];
             print qx(git ls-files)' "${repo[$which]}" > "${list[$which]}"
        if [ -n "$exclude" ]
        then
            grep -v "$exclude" "${list[$which]}" > "${list[$which]}.filt"
            mv "${list[$which]}.filt" "${list[$which]}"
        fi
        declare line
        declare key
        while IFS='' read -r line || [[ -n "$line" ]]
        do
            ## Because for some unknown reason a directory spec with a '/' in it
            ## was giving me some weird error.
            key=${line//\//%2F}

            ## Yes, there's some indirect referencing here. Not my fault there are
            ## no multi-level arrays/hashes in bash.
            eval "${which}files[$key]=${repo[$which]}/$line"
        done < "${list[$which]}"
    done

    declare -A missingright
    for key in "${!leftfiles[@]}"
    do
        if [ -z "${rightfiles[$key]}" ]
        then
            missingright[$key]=${key//%2F/\/}
            unset leftfiles["$key"]
        fi
    done
    if [ "${#missingright[@]}" != '0' ]
    then
        if ((name_only))
        then
            cmd-echo -- "These files do not exist in ${repo[right]}" "${missingright[@]}" >&2
        else
            cmd-echo -- "These files do not exist in ${repo[right]}" "${missingright[@]}"
        fi
    fi

    declare -A missingleft
    for key in "${!rightfiles[@]}"
    do
        if [ -z "${leftfiles[$key]}" ]
        then
            missingleft[$key]=${key//%2F/\/}
            unset rightfiles["$key"]
        fi
    done
    if [ "${#missingleft[@]}" != '0' ]
    then
        if ((name_only))
        then
            cmd-echo -- "These files do not exist in ${repo[left]}" "${missingleft[@]}" >&2
        else
            cmd-echo -- "These files do not exist in ${repo[left]}" "${missingleft[@]}"
        fi
    fi

    for key in "${!leftfiles[@]}"
    do
        declare output
        declare leftf
        leftf=${leftfiles["$key"]}
        declare rightf=${rightfiles["$key"]}
        output=$(diff -q "$leftf" "$rightf" 2>&1 | grep -v 'Common subdirectories')
        if [ -n "$output" ]
        then
            if ((name_only))
            then
                echo "$leftf" "$rightf"
            else
                cmd-echo -- '-----'
                declare diffcmd
                # shellcheck disable=SC2230
                diffcmd=$(which colordiff 2>/dev/null)
                # shellcheck disable=SC2209 # We don't want to run diff, just
                # prepare the command
                ( [ -z "$diffcmd" ] || ((nocolor)) ) && diffcmd=diff
                $diffcmd "$side_by_side" "${leftf}" "${rightf}"
                echo
            fi
        fi
    done

    return 0
}

git-repo-del ()
{
    git-repo-delete "$@"
}

git-repo-delete ()
{
    declare current=0
    declare dirmode=''
    [[ -z $1 ]] && bash-usage "$0" && return 1
    if [[ $1 = '--pwdmode' ]] \
           || [[ $1 == '--current' ]] \
           || [[ $1 == '-c' ]] \
           || [[ $1 == '.' ]]
    then
        current=1
        shift
    elif [[ $1 = '--dirmode' ]]
    then
        dirmode=$2
        shift
        shift
    elif [[ -n $1 ]]
    then
        dirmode=$1
        shift
    fi

    # If we were given '.', then we are really doing --current.
    if [[ -n $dirmode ]] && [[ ${PWD} = $(realpath "$dirmode") ]]
    then
        current=1
        dirmode=''
    fi

    declare repo
    declare returnpath
    returnpath=$(realpath "${PWD}")

    if [ -n "$dirmode" ]
    then
        ## We were given the directory containing the repo
        builtin cd "$dirmode" || ( cmd-echo "Cannot cd $dirmode" && return 1 )
        declare root_or_err
        root_or_err="$(git root 2>&1)"
        declare status=$?
        if ((status))
        then
            cmd-echo -- "$root_or_err"
            builtin cd "$returnpath" || ( cmd-echo "Cannot cd $returnpath" && return 1)
            return $status
        else
            builtin cd "$root_or_err" || ( cmd-echo "Cannot cd $root_or_err" && return 1)
        fi
    elif ((!current))
    then
        ## Then we were given a local repo URL; find it and go there
        declare githost=$1;shift
        declare namespace=$1;shift
        repo=$1;shift

        declare githost_url
        githost_url=$(git kv --get "svcs.$githost")
        if [ -z "$githost_url" ]
        then
            cmd-echo -- "$githost is unknown. Valid githosts are:$(git kv --key-only --section svcs)"
            return 1
        fi

        ## Go to what we want to whack, to make sure it's there.
        git go "$githost/$namespace/$repo"
        status=$?
        ((status != 0)) && return 1; ## If the git go fails, we should
        ## see error messages, no need to
        ## add more.
    ## else - we were told to delete the directory/repo we are currently in
    fi

    ## At this point, we are in the directory we are going to delete. We can
    ## determine the repo.
    repo=$(basename "$(realpath "${PWD}")")

    (
        ## Subshell to allow cding around to be handled gracefully at the end

        ## Make sure it's clean
        if [ -d wt ] && (($(find wt | wc -l) > 1))
        then
            cmd-echo "worktrees found:"
            ls -la wt
            cmd-echo
            cmd-echo "Will not delete repo"
            return 1
        fi

        dirty=$(git status --porcelain)
        if [ -n "$dirty" ]
        then
            git status
            cmd-echo
            cmd-echo "Will not delete current repo"
            return 1
        fi

        builtin cd .. || ( cmd-echo "Cannot cd .." && return 1)
        \rm -rf "$repo"
        status=$?
        ((status != 0)) && return 1; ## If the rm fails, we should see error
                                     ## messages, no need to add more.

        cmd-echo "Done. Not touching remote repo. Resetting git list..."
        ## Remove the just-deleted repo from the list of local git repos.
        git-go-set

        return 0
    )

    status=$?

    ## We were in some dir or the deleted repo. If the latter, then go up the
    ## tree until we find someplace to return to.
    while [ ! -d "$returnpath" ] && [ ! "$returnpath" = '/' ]
    do
        returnpath="$(dirname "$returnpath")"
    done

    ## Go there.
    if [ ! "$returnpath" = '/' ]
    then
        builtin cd "$returnpath" || ( cmd-echo "Cannot cd $returnpath" && return 1)
    else
        builtin cd ~ || ( cmd-echo "Cannot cd ~" && return 1)
    fi

    ## Feed "there" back to the git function to make it stick.
    if [[ -n "$doandcdfile" ]]
    then
        echo "go ${PWD}" > "$doandcdfile"
        cmd-echo -n -- "Done. "
    fi

    return $status
}

git-repo-pr-get ()
{
    declare opt_silent=$1; shift

    declare remote
    for remote in upstream origin
    do
        remote_url=$(git config --get remote.${remote}.url)
        if [ -n "$remote_url" ]
        then
            break
        fi
    done
    if [ -z "$remote_url" ]
    then
        cmd-echo -wc -- "Cannot find a remote upstream or origin to check for pull requests"
        return 1
    fi

    declare remote_svc=${remote_url%:*}
    declare remote_repo=${remote_url#*:}

    declare cb
    cb="$(git branch --show-current)"

    declare perldata
    perldata=$(mktemp -t tmp.git-repo-pr-get.perldata.$$.XXXXXXXXXX)
    rm-on-exit "$perldata"

    github-api --stream-data --perl-data --server "$remote_svc" pulls "$remote_repo" >> "$perldata"

    perl -MData::Dumper -e '
## $ARGV[0] - file with perl data
## $ARGV[1] - org or current repo
## $ARGV[2] - current branch name
## $ARGV[3] - "silent" - 0:print the pull request URL, 1:no print
do $ARGV[0];
for $openpull (@{$VAR1}) {
    if ($openpull->{head}{label} eq "$ARGV[1]:$ARGV[2]") {
        ## debug: print Data::Dumper->Dump([$openpull],[qw(*pull)]);
        print qq($openpull->{html_url}\n) if !$ARGV[3];
        exit 0;
    }
}
exit 1;' "$perldata" "$USER" "$cb" "$opt_silent"
    declare status=$?
    return $status ## Instead of return $? in case we are debugging and need a
                   ## set +x after we get status but before return.
}

git-repo-pr ()
{
    declare OPTSARGS
    declare shortopts='sg'
    declare longopts='silent,get'

    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@") ## "${FUNCNAME[0]}" -- "$@") ## in functions
    declare status=$?
    ((status != 0)) && exit $status ## return $status ## in functions

    eval set -- "$OPTSARGS"

    declare opt_silent=0
    declare opt_get=1 ## default for now, maybe we add create later.
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            get | g) opt_get=1 ;;
            silent | s) opt_silent=1;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -e -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    if ((opt_get))
    then
        git-repo-pr-get $opt_silent
    fi
}

git-repo-sync ()
{
    git-repo-sync-with "$@"
}

git-repo-sync-with ()
{
    if [[ $1 = --master ]]
    then
        shift
        ## clone-and-fork repos need to sync with the master in the canonical
        ## upstream branch.  If there is no 'upstream', then it's probably a
        ## clone only, so sync against the master in origin.
        declare status
        declare upstream
        upstream=$(git remote get-url upstream 2>/dev/null)
        if [ -n "${upstream}" ]
        then
            cmd-echo -- "syncing with master in upstream ${upstream}"
            git-sync-with-remote --remote upstream --branch master "$@"
            status=$?
        else
            declare origin
            origin=$(git remote get-url origin 2>/dev/null)
            if [ -n "${origin}" ]
            then
                cmd-echo -- "syncing with master in origin ${origin}"
                git-sync-with-remote --remote origin --branch master "$@"
                status=$?
            else
                cmd-echo --ec -- "Current repo is not a clone of a remote"
                status=1
            fi
        fi
    else
        git-sync-with-remote "$@"
        status=$?
    fi
    return $status
}

git-repo-check ()
{
    git-repo-check-with "$@"
}

git-repo-check-with ()
{
    if [[ $1 = --master ]]
    then
        shift
        ## clone-and-fork repos need to check with the master in the canonical
        ## upstream branch.  If there is no 'upstream', then it's probably a
        ## clone only, so check against the master in origin.
        declare status
        declare upstream
        upstream=$(git remote get-url upstream 2>/dev/null)
        if [ -n "${upstream}" ]
        then
            cmd-echo -- "checking with master in upstream ${upstream}"
            git-check-with-remote --remote upstream --branch master "$@"
            status=$?
        else
            declare origin
            origin=$(git remote get-url origin 2>/dev/null)
            if [ -n "${origin}" ]
            then
                cmd-echo -- "checking with master in origin ${origin}"
                git-check-with-remote --remote origin --branch master "$@"
                status=$?
            else
                cmd-echo --ec -- "Current repo is not a clone of a remote"
                status=1
            fi
        fi
    else
        git-check-with-remote "$@"
        status=$?
    fi
    return $status
}

git-repo-prune()
{
    git-repo-purge "$@"
}

git-repo-purge()
{
    declare -a repos
    repos=("$@")
    [[ -z ${repos[0]} ]] && readarray -t repos < <(git go --listfull --nowt)
    declare repo
    for repo in "${repos[@]}"
    do
        (
            cd "$repo" || exit 0;
            cmd-echo -- "$repo"
            declare ok_to_purge=1
            # shellcheck disable=SC2012 #https://github.com/koalaman/shellcheck/wiki/SC2012
            if [[ -d wt ]] && (($(ls wt | wc -l)))
            then
                declare wt
                for wt in wt/*
                do
                    declare wtrp
                    wtrp=$(realpath "$wt")
                    git wt purge "$wtrp"
                    [[ -d $wtrp ]] && ok_to_purge=0
                done
            fi
            git repo pr -g && ok_to_purge=0 ## func returns 0 (success) if it
                                            ## finds a PR, in which case we
                                            ## can't purge it.
            ! git repo is pristine -v && ok_to_purge=0
            if ((ok_to_purge))
            then
                resp=$(cmd-yesno -dc "Repo is pristine. Delete it" n)
                [[ $resp == 'y' ]] && git repo del --current --yes
                echo
            fi
        )
    done
}

git-repo-reset ()
{
    git-repo-restore "$@"
}

git-repo-restore ()
{
    git dorealclean
    declare -a files
    readarray -t files < <(git is committable)
    git reset HEAD -- "${files[@]}"
    readarray -t files < <(git is modified)
    git checkout -- "${files[@]}"
}

main()
{
    declare action=$1

    if [[ "$action" =~ --doandcd ]]
    then
        doandcdfile=$2
        shift; shift;
        action=$1
    fi

    if [[ "$action" =~ ^-+h ]]
    then
        bash-usage "$0"
        return  0
    fi

    if [[ $action = 'is' ]]
    then
        [[ "$2" = 'a' ]] && shift
        if [[ -n $2 ]]
        then
            shift
            action="${action}_${1//-/_}"
        fi
    fi

    action_func_name="git-repo-${action}"
    if declare -F "$action_func_name" >/dev/null
    then
        shift ## the $action
        "$action_func_name" "$@"
    else
        case $action in
            * )
                cmd-echo --ec --id git-repo -- "unknown git repo action '$action'"
                return 1
                ;;
        esac
    fi
    return $?
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-repo - act on or interrogate the current repo

=head1 SYNOPSIS

 git-repo delete
 git-repo diff
 git-repo is
 git-repo ina
 git-repo name
 git-repo pr-get
 git-repo reset/restore
 git-repo sync

 git-repo purge/prune [repo-dir [repo-dir]... ]

 DESCRIPTION

A collection of actions and data about the current repository.

=head1 ACTIONS

=over 4

=item delete

 git repo delete [--current | repo-dir]

Mostly used with --current, deletes the repo, checking for worktrees and uncommitted changes first, maintains the 'git go' list...

=item diff

  git repo diff [--nocolor] [--name[s]-only] \
                [--exclude path/to/exclude] \
                [src] tgt

Compare two repos on disk. If only one repo is specified, 'src' is taken as the
current directory, which should be a repo root.

If your intent is to try and copy the differences from one repo to another,
then, in the source repo that has the files you want to copy:

  while read from to
  do
    cp -v $from $to
  done < <(git repo diff --name-only path/to/the/target/repo)

=item is

  git repo is [  a
               | a fork
               | a fork of
               | clean
               | pristine ] [repo-dir]

With no arguments, is the current directory a repo.

With a 'repo-dir' argument, work on that directory. Otherwise work on the current directory.

With 'a', is the current or specified directory a git repo.

With 'a fork', is the current or specified directory repo whose remote origin is, in turn, a fork of a remote repo.

With 'a fork of', if the current or specified directory repo has a remote origin which is, in turn, a fork of a remote repo, print the repo it was forked from.

With 'clean', does the current or specified git repo have no edited tracked files.

With 'pristine', is the current or specified git repo 'clean' with no untracked files. If it is NOT a worktree, it is checked to make sure that it has no outsanding worktrees. '-v' will print why it is not pristine.

=item name

Print the name of the remote repo.

=item pr

  git repo pr --get [--silent]

Deal with pull requests related to the current repo. --get will look for an open pull request for this branch against remotes 'upstream' and then 'origin'. --silent will supress printing the PR reference so that you can just used the return value; 0 if there is an open pull request, 1 if not.

=item restore

Performs a realclean, resets all uncommitted changes.

=item sync

git pull against the remote and branch specified. If --master, then use the
default pull remote and remote branch master.

=item purge/prune

This command is different. It does not work on the current repo. It loops over
a list of repos or, if no list is provided, all the repos. If a repo has
worktrees, it runs 'git worktree delete' on each one. If a repo has no open
pulls, no worktrees and is completely clean (as determined by 'git repo is
pristine'. no) then it prompts to accept deleting the repo.

**NOTE:** This probably belongs in git mono or a git repos command that would
  replace git mono. The git mono default of 'exec all of this for each repo'
  could be the --exec option of git repos.

=back

=cut

__PODUSAGE__
