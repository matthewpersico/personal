#!/usr/bin/env bash
# shellcheck disable=SC1090 #https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck disable=SC2155 #https://github.com/koalaman/shellcheck/wiki/SC2155

# git-repo - no .gitaudit, called on every prompt

if ! git-version-verify 'git-repo'
then
    exit 1
fi

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

## Global used to control 'cd'ing around
doandcdfile=''

git-repo-is ()
{
    declare verbose=0
    if [[ "$1" =~ -v ]]
    then
        verbose=1
        shift
    fi
    [[ "$1" ]] && [[ $1 != . ]] && { cd "$1" || return 1; }
    git rev-parse --show-toplevel 2>/dev/null 1>&2
    status=$?
    [[ "$1" ]] && [[ $1 != . ]] && { cd - || return 1; }
    (( verbose )) && ( (( status )) && echo false || echo true )
    return $status
}

git-repo-isa () { git-repo-is "$@"; }
git-repo-ina () { git-repo-is; }

git-repo-is_clean ()
{
    (( $(git st --porcelain | grep -cv '??') == 0 ))
}

git-repo-is_spotless ()
{
    git-repo-is_pristine "$@"
}

git-repo-is_pristine ()
{
    (( $(git st --porcelain | wc -l) == 0 )) \
        && ( git worktree ina || (( $(git worktree list | wc -l) == 1 )) ) \
        && return 0
    if [[ $1 == '-v' ]]
    then
        (( $(git st --porcelain | wc -l) != 0 )) && git status
        if ! git worktree ina && (( $(git worktree list | wc -l) != 1 ))
        then
            echo Found worktrees:
            git worktree list | tail -n +2 # Do not print the root repo for the
                                           # worktrees, which is always the
                                           # first entry of the wt list
                                           # command.
        fi
    fi
    return 1
}

git-repo-is_up_to_date ()
{
    declare branch_status
    branch_status=$(git status | grep 'Your branch is')
    declare verbose=0
    if [[ "$1" =~ -v ]]
    then
        echo "$branch_status"
    fi
    if [[ -z $branch_status ]] || [[ $branch_status =~ 'Your branch is up to date' ]]
    then
        return 0
    else
        return 1
    fi
}

git-repo-is_fork ()
{
    declare print=0
    if [[ $1 == '--print' ]]
    then
        shift
        print=1
    fi
    (
        # shellcheck disable=SC2164 #https://github.com/koalaman/shellcheck/wiki/SC2164
        cd "${1:-.}" # so that the git remote works on the current dir as well
                     # as a specified repo dir
        declare origin
        declare fork_of=''
        origin=$(git remote get-url origin)
        if [[ -n $origin ]]
        then
            declare server=${origin%%:*}
            declare repo_path=${origin##*:}
            fork_of=$(perl -e'
   use JSON::PP::Boolean;
our $VAR1;
eval "@ARGV";
$VAR1->{fork} && print $VAR1->{parent}{full_name};
' "$( github-api --silent --server "$server" --perl-data url repos/"$repo_path")")
        fi
        ((print)) && [[ -n "$fork_of" ]] && echo "$fork_of"
        [[ -n "$fork_of" ]] ## return value
    )
}

git-repo-is_fork_of ()
{
    git-repo-is_fork --print "$@"
}

git-repo-is_forkof ()
{
    git-repo-is_fork --print "$@"
}

git-repo-is_worktree ()
{
    if [[ -f $(git root)/.git ]]
    then
        if [[ $1 == 'of' ]]
        then
            realpath "$(git root)/$(sed 's/gitdir: \(.*\)\/\.git\/worktrees.*/\1/' < "$(git root)/.git")"
        fi
        return 0
    else
        return 1
    fi
}

git-repo-is_openpr ()
{

    source "$BASH_INC_DIR/mktemp.binc"
    source "$BASH_INC_DIR/on_exit.binc"

    git fetch
    declare server upstream_namespace origin_namespace repo current_branch
    declare -A namespaces

    server=$(git-get-default-remote --server)

    upstream_namespace=$(git repo is a fork-of | sed 's/\/.*//')
    [[ -n $upstream_namespace ]] && namespaces["$upstream_namespace"]=1

    origin_namespace=$(git-get-default-remote --namespace)
    namespaces["$origin_namespace"]=1

    repo=$(git repo name)
    current_branch=$(git-repo-current-branch)

    declare -a output
    for tgt_namespace in "${!namespaces[@]}"
    do
        declare tmpfile; tmpfile=$(mktempfile); rm-on-exit "$tmpfile"

        github-api --server "$server" --perl-data pulls "$tgt_namespace/$repo" > "$tmpfile"
        declare tmpout
        tmpout=$(perl -e '
do $ARGV[0];
for $entry (@$VAR1) {
    if ( $entry->{user}->{login} eq $ENV{USER}
         &&
         $entry->{head}->{ref} eq $ARGV[1] ) {
        print($entry->{_links}->{html}->{href});
    }
}
' "$tmpfile" "$current_branch")
        [[ -n $tmpout ]] && output+=("$tmpout")
    done
    if [[ "${#output[@]}" == '0' ]]
    then
        echo "No open pull requests"
        return 1
    else
        for o in "${output[@]}"
        do
            echo "$o"
        done
        return 0
    fi
}

git-repo-info ()
{
    cmd-echo --title "Configs:"
    git-repo-config
    if [[ $1 != '--no-pulls' ]]
    then
        cmd-echo --title "Pull Requests:"
        git-repo-pr-get --state
    fi
}

git-repo-config ()
{
    declare -a lines
    mapfile -t                 lines < <(git config --get-regexp "$(git-repo-current-branch)" | sort)
    mapfile -t -O ${#lines[@]} lines < <(git config --get-regexp "remote.*.url" | sort)
    declare -a display
    for line in "${lines[@]}"
    do
        read -r key value <<< "$line"
        (( ${#key} > max )) && max=${#key}
        display+=("$key" "$value")
    done
    ((max+=1))
    printf "%-${max}s: %s\n" "${display[@]}"
}

git-repo-name ()
{
    [[ "$1" ]] && [[ $1 != . ]] && { cd "$1" || return 1; }
    name=$(git remote -v 2>/dev/null | grep origin | sed -e 's|.*/||' -e 's/ .*//' | sort -u)
    [[ "$1" ]] && [[ $1 != . ]] && { cd - || return 1; }
    [ -z "$name" ] && return 1
    echo "$name"
    return 0
}

git-repo-org ()
{
    [[ "$1" ]] && [[ $1 != . ]] && { cd "$1" || return 1; }
    name=$(git remote -v 2>/dev/null | grep origin |  sed -e 's/.*://' -e 's/\/.*//' | sort -u)
    [[ "$1" ]] && [[ $1 != . ]] && { cd - || return 1; }
    [ -z "$name" ] && return 1
    echo "$name"
    return 0
}

git-repo-diff ()
{
    declare moreopts=1
    declare nocolor=0
    declare name_only=0
    declare exclude=''
    declare side_by_side='-u'
    declare edit=0
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        ## but only deal with it if we really have an option. Otherwise you
        ## misinterpret items like this git clone option: --config
        ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
        if [[ $option =~ ^- ]]
        then
            if [[ "$option" =~ = ]]
            then
                okey=${option%%=*}
                ovalue=${option#*=}
                option="$okey"
            fi
        fi

        case $option in
            nocolor)
                nocolor=1 ;;
            exclude)
                exclude=${ovalue:-$1}; [ -z "$ovalue" ] && shift ;;
            side-by-side)
                side_by_side='-y --suppress-common-lines';;
            edit)
                edit=1 ;;
            name-only | \
                names-only | \
                l)
                name_only=1;;
            --)
                moreopts=0
                ;;
            * )
                cmd-echo -- "$original is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    declare -A repo
    if [ -n "$2" ]
    then
        repo[left]=$(realpath "$1")
        repo[right]=$(realpath "$2")
    elif [ -n "$1" ]
    then
        repo[left]=${PWD}
        repo[right]=$(realpath "$1")
    else
        cmd-echo -- "Need at least one directory"
        bash-usage "$0"; return 1 ;
    fi

    if [ "${repo[left]}" = "${repo[right]}" ]
    then
        cmd-echo -- "Other dir is this dir. Whoops! Bye."
        return 1
    fi

    declare -A list
    list[left]=$(mktemp -t tmp.git-diff-two-repos-on-disk.left.XXXXXXXXXX)
    list[right]=$(mktemp -t tmp.git-diff-two-repos-on-disk.right.XXXXXXXXXX)
    rm-on-exit "${list[left]}" "${list[right]}"

    # Get lists of files from each repo
    declare which
    declare -A leftfiles
    declare -A rightfiles
    for which in left right
    do
        perl -e 'chdir $ARGV[0];
             print qx(git ls-files)' "${repo[$which]}" > "${list[$which]}"
        if [ -n "$exclude" ]
        then
            grep -v "$exclude" "${list[$which]}" > "${list[$which]}.filt"
            mv "${list[$which]}.filt" "${list[$which]}"
        fi
        declare line
        declare key
        while IFS='' read -r line || [[ -n "$line" ]]
        do
            ## Because for some unknown reason a directory spec with a '/' in it
            ## was giving me some weird error.
            key=${line//\//%2F}

            ## Yes, there's some indirect referencing here. Not my fault there are
            ## no multi-level arrays/hashes in bash.
            eval "${which}files[$key]=${repo[$which]}/$line"
        done < "${list[$which]}"
    done

    declare -A missingright
    for key in "${!leftfiles[@]}"
    do
        if [ -z "${rightfiles[$key]}" ]
        then
            missingright[$key]=${key//%2F/\/}
            unset leftfiles["$key"]
        fi
    done
    if [ "${#missingright[@]}" != '0' ]
    then
        if ((name_only))
        then
            cmd-echo -- "These files do not exist in ${repo[right]}" "${missingright[@]}" >&2
        else
            cmd-echo -- "These files do not exist in ${repo[right]}" "${missingright[@]}"
        fi
    fi

    declare -A missingleft
    for key in "${!rightfiles[@]}"
    do
        if [ -z "${leftfiles[$key]}" ]
        then
            missingleft[$key]=${key//%2F/\/}
            unset rightfiles["$key"]
        fi
    done
    if [ "${#missingleft[@]}" != '0' ]
    then
        if ((name_only))
        then
            cmd-echo -- "These files do not exist in ${repo[left]}" "${missingleft[@]}" >&2
        else
            cmd-echo -- "These files do not exist in ${repo[left]}" "${missingleft[@]}"
        fi
    fi

    declare -a editable
    for key in "${!leftfiles[@]}"
    do
        declare output
        declare leftf
        leftf=${leftfiles["$key"]}
        declare rightf=${rightfiles["$key"]}
        output=$(diff -q "$leftf" "$rightf" 2>&1 | grep -v 'Common subdirectories')
        if [ -n "$output" ]
        then
            if ((name_only))
            then
                echo "$leftf" "$rightf"
            elif ((edit))
            then
                editable+=("$leftf" "$rightf")
            else
                cmd-echo -- '-----'
                declare diffcmd
                # shellcheck disable=SC2230
                diffcmd=$(which colordiff 2>/dev/null)
                # shellcheck disable=SC2209 # We don't want to run diff, just
                # prepare the command
                ( [ -z "$diffcmd" ] || ((nocolor)) ) && diffcmd=diff
                $diffcmd "$side_by_side" "${leftf}" "${rightf}"
                echo
            fi
        fi
    done

    if (( ${#editable[@]} ))
    then
        if [ -z "$EDITOR" ]
        then
            cmd-echo -- "No EDITOR env variable found"
            return 1
        else
            $EDITOR "${editable[@]}"
            return $?
        fi
    fi

    return 0
}

git-repo-del ()
{
    git-repo-delete "$@"
}

git-repo-delete ()
{
    declare current=0
    declare dirmode=''
    [[ -z $1 ]] && bash-usage "$0" && return 1
    if [[ $1 = '--pwdmode' ]] \
           || [[ $1 =~ ^--curr ]] \
           || [[ $1 == '-c' ]] \
           || [[ $1 == '.' ]]
    then
        current=1
        shift
    elif [[ $1 = '--dirmode' ]]
    then
        dirmode=$2
        shift
        shift
    elif [[ -n $1 ]]
    then
        dirmode=$1
        shift
    fi

    # If we were given '.', then we are really doing --current.
    if [[ -n $dirmode ]] && [[ ${PWD} = $(realpath "$dirmode") ]]
    then
        current=1
        dirmode=''
    fi

    declare repo
    declare returnpath
    returnpath=$(realpath "${PWD}")

    if [ -n "$dirmode" ]
    then
        ## We were given the directory containing the repo
        builtin cd "$dirmode" || { cmd-echo "Cannot cd $dirmode" && return 1; }
        declare root_or_err
        root_or_err="$(git root 2>&1)"
        declare status=$?
        if ((status))
        then
            cmd-echo -- "$root_or_err"
            builtin cd "$returnpath" || { cmd-echo "Cannot cd $returnpath" && return 1; }
            return $status
        else
            builtin cd "$root_or_err" || { cmd-echo "Cannot cd $root_or_err" && return 1; }
        fi
    elif ((!current))
    then
        ## Then we were given a local repo URL; find it and go there
        declare githost=$1;shift
        declare namespace=$1;shift
        repo=$1;shift

        declare githost_url
        githost_url=$(git kv --get "svcs.$githost")
        if [ -z "$githost_url" ]
        then
            cmd-echo -- "$githost is unknown. Valid githosts are:$(git kv --key-only --section svcs)"
            return 1
        fi

        ## Go to what we want to whack, to make sure it's there.
        git go "$githost/$namespace/$repo"
        status=$?
        ((status != 0)) && return 1; ## If the git go fails, we should
        ## see error messages, no need to
        ## add more.
    ## else - we were told to delete the directory/repo we are currently in
    fi

    ## At this point, we are in the directory we are going to delete. We can
    ## determine the repo.
    repo=$(basename "$(realpath "${PWD}")")

    (
        ## Subshell to allow cding around to be handled gracefully at the end

        ## Make sure it's clean
        if [ -d wt ] && (($(find wt | wc -l) > 1))
        then
            cmd-echo "worktrees found:"
            ls -la wt
            cmd-echo
            cmd-echo "Will not delete repo"
            return 1
        fi

        dirty=$(git status --porcelain)
        if [ -n "$dirty" ]
        then
            git status
            cmd-echo
            cmd-echo "Will not delete current repo"
            return 1
        fi

        builtin cd .. || { cmd-echo "Cannot cd .." && return 1; }
        \rm -rf "$repo"
        status=$?
        ((status != 0)) && return 1; ## If the rm fails, we should see error
                                     ## messages, no need to add more.

        cmd-echo "Done. Not touching remote repo. Resetting git list..."
        ## Remove the just-deleted repo from the list of local git repos.
        git-go-set

        return 0
    )

    status=$?

    ## We were in some dir or the deleted repo. If the latter, then go up the
    ## tree until we find someplace to return to.
    while [ ! -d "$returnpath" ] && [ ! "$returnpath" = '/' ]
    do
        returnpath="$(dirname "$returnpath")"
    done

    ## Go there.
    if [ ! "$returnpath" = '/' ]
    then
        builtin cd "$returnpath" || { cmd-echo "Cannot cd $returnpath" && return 1; }
    else
        builtin cd ~ || { cmd-echo "Cannot cd ~" && return 1; }
    fi

    ## Feed "there" back to the git function to make it stick.
    if [[ -n "$doandcdfile" ]]
    then
        echo "go ${PWD}" > "$doandcdfile"
        cmd-echo -n -- "Done. "
    fi

    return $status
}

git-repo-pr-get ()
{
    declare OPTSARGS
    declare shortopts=''
    declare longopts='silent,state'

    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    eval set -- "$OPTSARGS"

    declare opt_silent=0
    declare opt_state=0
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            silent ) opt_silent=1;;
            state ) opt_state=1;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -e -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    declare remote
    for remote in upstream origin
    do
        remote_url=$(git config --get remote.${remote}.url)
        if [ -n "$remote_url" ]
        then
            break
        fi
    done
    if [ -z "$remote_url" ]
    then
        cmd-echo -wc -- "Cannot find a remote upstream or origin to check for pull requests"
        return 1
    fi
    declare remote_svc=${remote_url%:*}
    declare remote_repo=${remote_url#*:}

    #
    # See if we have cached it
    #
    declare pr_url
    declare wt=$(git-worktree ina -v)
    declare cb=$(git-repo-current-branch)
    pr_url=$(git config --get "worktree.${wt}.extmeta-pr")
    if [[ -z $pr_url ]]
    then
        pr_url=$(git config --get "branch.${cb}.extmeta-pr")
        if [[ -z $pr_url ]]
        then
            ((!opt_silent)) && echo 'No open pull requests associated with this repo'
            return 0
        fi
    fi
    if [[ -n $pr_url ]]
    then
        if ((!opt_silent))
        then
            if ((opt_state))
            then
                # We don't cache the state.
                declare pullId=${pr_url##*/}
                declare state=$(github-api --stream-data --server "$remote_svc" --pull $pullId pulls "$remote_repo" | jq .state)
                state=${state//\"/}
                state=${state^}
                echo -n "${state}: "
            fi
            echo "$pr_url"
        fi
        return 0
    fi

    #
    # Not cached. Search and record.
    #
    declare perldata=$(mktemp -t tmp.git-repo-pr-get.perldata.$$.XXXXXXXXXX)
    rm-on-exit "$perldata"
    github-api --stream-data --perl-data --server "$remote_svc" pulls "$remote_repo" >> "$perldata"
    pr_url=$(perl -MData::Dumper -e '
## $ARGV[0] - file with perl data
## $ARGV[1] - org or current repo
## $ARGV[2] - current branch name
## $ARGV[3] - "state" - 0:do not add the state of the PR to the output, 1:add the state
do $ARGV[0];
for $openpull (@{$VAR1}) {
    if ($openpull->{head}{label} eq "$ARGV[1]:$ARGV[2]") {
        ## debug: print Data::Dumper->Dump([$openpull],[qw(*pull)]);
        if($ARGV[3]) {
            print ucfirst($openpull->{state}), q(: );
        }
        print $openpull->{html_url}, qq(\n);
        exit 0;
    }
}
exit 1;' "$perldata" "$USER" "$cb" "$opt_state")
    declare status=$?
    if [[ -z $pr_url ]]
    then
        ((!opt_silent)) && echo 'No open pull requests associated with this repo'
    else
        ((!opt_silent)) && echo "$pr_url"
        ((opt_state)) && pr_url=${pr_url#*: }
        # Cache the PR
        [[ -n $wt ]] && git config --replace-all "worktree.${wt}.extmeta-pr" "$pr_url"
        [[ -n $cb ]] && git config --replace-all "branch.${cb}.extmeta-pr" "$pr_url"
    fi
    return $status ## Instead of return $? in case we are debugging and need a
                   ## set +x after we get status but before return.
}

git-repo-pr ()
{
    declare OPTSARGS
    declare shortopts='sg'
    declare longopts='silent,state,get'

    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    eval set -- "$OPTSARGS"

    declare -a passthru
    declare opt_get=1 ## default for now, maybe we add create later.
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            get | g) opt_get=1 ;;
            silent | s) passthru+=('--silent');;
            state ) passthru+=('--state');;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -e -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    if ((opt_get))
    then
        git-repo-pr-get "${passthru[@]}"
    fi
}

git-repo-sync ()
{
    git-repo-sync-with "$@"
}

git-repo-sync-with ()
{
    declare arg1=$1
    if [[ -z $arg1 ]]
    then
        declare deftext='source'
        declare branch_name
        branch_name=$(git-repo-source-branch)
        if [[ -z $branch_name ]]
        then
            deftext="default"
            branch_name=$(git-repo-default-branch)
        fi
        ## clone-and-fork repos need to sync with the default branch in the
        ## canonical upstream branch.  If there is no 'upstream', then it's
        ## probably a clone only, so sync against the default branch in origin.
        declare status
        declare upstream
        upstream=$(git remote get-url upstream 2>/dev/null)
        if [ -n "${upstream}" ]
        then
            cmd-echo -- "syncing with ${deftext}branch '${branch_name}' in upstream '${upstream}'"
            git-sync-with-remote --remote upstream --branch "$branch_name" "$@"
            status=$?
        else
            declare origin
            origin=$(git remote get-url origin 2>/dev/null)
            if [ -n "${origin}" ]
            then
                cmd-echo -- "syncing with ${deftext}branch '${branch_name}' in origin '${origin}'"
                git-sync-with-remote --remote origin --branch "$branch_name" "$@"
                status=$?
            else
                cmd-echo --ec -- "Current repo is not a clone of a remote"
                status=1
            fi
        fi
    else
        git-sync-with-remote "$@"
        status=$?
    fi
    return $status
}

git-repo-check ()
{
    git-repo-check-with "$@"
}

git-repo-check-with ()
{
    declare arg1=$1
    if [[ $arg1 =~ ^--def ]]
    then
        shift
        declare branch_name
        branch_name=$(git-repo-default-branch)
        ## clone-and-fork repos need to check with the default branch in the
        ## canonical upstream branch.  If there is no 'upstream', then it's
        ## probably a clone only, so check against the default branch in
        ## origin.
        declare status
        declare upstream
        upstream=$(git remote get-url upstream 2>/dev/null)
        if [ -n "${upstream}" ]
        then
            cmd-echo -- "checking with branch '${branch_name}' in upstream '${upstream}'"
            git-check-with-remote --remote upstream --branch "$branch_name" "$@"
            status=$?
        else
            declare origin
            origin=$(git remote get-url origin 2>/dev/null)
            if [ -n "${origin}" ]
            then
                cmd-echo -- "checking with branch '${branch_name}' in origin '${origin}'"
                git-check-with-remote --remote origin --branch "$branch_name" "$@"
                status=$?
            else
                cmd-echo --ec -- "Current repo is not a clone of a remote"
                status=1
            fi
        fi
    else
        git-check-with-remote "$@"
        status=$?
    fi
    return $status
}

git-repo-prune()
{
    git-repo-purge "$@"
}

git-repo-purge()
{
    declare -a repos
    repos=("$@")
    [[ -z ${repos[0]} ]] && readarray -t repos < <(git go --listfull --nowt)
    declare repo
    for repo in "${repos[@]}"
    do
        (
            cd "$repo" || exit 0;
            cmd-echo -- "$repo"
            declare ok_to_purge=1
            # shellcheck disable=SC2012 #https://github.com/koalaman/shellcheck/wiki/SC2012
            if [[ -d wt ]] && (($(ls wt | wc -l)))
            then
                declare wt
                for wt in wt/*
                do
                    declare wtrp
                    wtrp=$(realpath "$wt")
                    git wt purge "$wtrp"
                    [[ -d $wtrp ]] && ok_to_purge=0
                done
            fi
            git repo pr -g && ok_to_purge=0 ## func returns 0 (success) if it
                                            ## finds a PR, in which case we
                                            ## can't purge it.
            ! git repo is pristine -v && ok_to_purge=0
            if ((ok_to_purge))
            then
                resp=$(cmd-yesno -dc "Repo is pristine. Delete it" n)
                [[ $resp == 'y' ]] && git repo del --current --yes
                echo
            fi
        )
    done
}

git-repo-reset ()
{
    git-repo-restore "$@"
}

git-repo-revert ()
{
    git-repo-restore "$@"
}

git-repo-restore ()
{
    cmd-echo "Cleaning..."
    git dorealclean

    cmd-echo "Unstaging..."
    declare -a files
    readarray -t files < <(git is committable)
    git reset HEAD -- "${files[@]}"

    cmd-echo "Uncheckouting..."
    readarray -t files < <(git is modified)
    git checkout -- "${files[@]}"

    cmd-echo "Status..."
    git status

}

git-repo-tags ()
{
     git tag --list --sort=v:refname
}

# shellcheck disable=SC2120 #https://github.com/koalaman/shellcheck/wiki/SC2120
git-repo-current-branch ()
{
    if [[ -n $1 ]]
    then
        cmd-echo --ec -- "Cannot set current branch yet"
        false;return $?
    else
        declare cb
        cb=$($REALGIT branch --show-current)
        if [[ -z $cb ]]
        then
            cmd-echo --wc -- "--show-current can't find current branch. Are you in a rebase? Falling back to alt method" >&2
            cb=$($REALGIT branch --color=never --contains HEAD | grep '(no branch, rebasing' | sed 's/.* \(.*\))/\1/')
            if [[ -z $cb ]]
            then
                cmd-echo --ec -- "Cannot get current branch"
                false;return $?
            fi
        fi
        echo "$cb"
    fi
    true
}

git-repo-show-current-branch ()
{
    git-repo-current-branch
}

# shellcheck disable=SC2120 #https://github.com/koalaman/shellcheck/wiki/SC2120
git-repo-default-branch ()
{
    if [[ -n $1 ]]
    then
        cmd-echo --ec -- "Cannot set default branch yet"
    else
        declare base_repo
        for base_repo in "$(git repo is a worktree of)" "$(git root)"
        do
            [[ -n $base_repo ]] && break
        done;
        [[ -z $base_repo ]] && { false; return $?; }
        declare default_branch
        default_branch=$(sed 's/.*\///' < "$base_repo"/.git/refs/remotes/origin/HEAD)
        [[ -n $default_branch ]] && echo "$default_branch" && return 0
        cmd-echo --ec -- "Cannot find default branch for ${PWD}"
        false; return $?
    fi
}

git-repo-show-default-branch ()
{
    git-repo-default-branch
}

git-repo-source-branch ()
{
    declare current_branch
    current_branch=$(git-repo-current-branch)

    declare source_branch
    source_branch=$(git config --get "branch.$current_branch.extmeta-from-branch")
    [[ -n $source_branch ]] && echo "$source_branch" && { true; return $?; }
    false
}

git-repo-show-source-branch ()
{
    git-repo-source-branch
}

main()
{
    declare action=$1

    if [[ "$action" =~ --doandcd ]]
    then
        doandcdfile=$2
        shift; shift;
        action=$1
    fi

    if [[ "$action" =~ ^-+h ]]
    then
        bash-usage "$0"
        return  0
    fi
    if [[ $action = 'is' ]]
    then
        [[ "$2" = 'a' ]] && shift
        if [[ -n $2 ]]
        then
            shift
            action="${action}_${1//-/_}"
        fi
    fi

    action_func_name="git-repo-${action}"
    if declare -F "$action_func_name" >/dev/null
    then
        shift ## the $action
        "$action_func_name" "$@"
    else
        case $action in
            * )
                cmd-echo --ec --id git-repo -- "unknown git repo action '$action'"
                return 1
                ;;
        esac
    fi
    return $?
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-repo - act on or interrogate the current repo

=head1 SYNOPSIS

 git-repo delete
 git-repo diff
 git-repo is
 git-repo ina
 git-repo name
 git-repo pr-get
 git-repo reset/revert/restore
 git-repo sync
 git-repo tags

 git-repo purge/prune [repo-dir [repo-dir]... ]

 DESCRIPTION

A collection of actions and data about the current repository.

=head1 ACTIONS

=over 4

=item delete

 git repo delete [--current | repo-dir]

Mostly used with --current, deletes the repo, checking for worktrees and uncommitted changes first, maintains the 'git go' list...

=item diff

  git repo diff [--nocolor] \
                [ [--name[s]-only | -l ] | --edit ] \
                [--exclude path/to/exclude] \
                [src] tgt

Compare two repos on disk. If only one repo is specified, 'src' is taken as the
current directory, which should be a repo root.

If your intent is to try and copy the differences from one repo to another,
then, in the source repo that has the files you want to copy:

  while read from to
  do
    cp -v $from $to
  done < <(git repo diff --name-only path/to/the/target/repo)

If you want to more carefully do such a copy, then use --edit to bring all the
files into your editor and use its diff and write facilities to Do The Right
Thing.

=item is

  git repo is [  a
               | a fork [of]
               | a worktree [of]
               | clean
               | [pristine|spotless]
               | up-to-date
              ] [repo-dir]

With no arguments, is the current directory a repo.

With a 'repo-dir' argument, work on that directory. Otherwise work on the current directory.

With 'a', is the current or specified directory a git repo.

With 'a fork', is the current or specified directory repo whose remote origin is, in turn, a fork of a remote repo.

With 'a fork of', print the repo it was forked from, if a fork.

With 'a worktree', is the current or specified directory repo a worktree.

With 'a worktree of', print the main worktree (from git init or git clone) for this linked worktree.

With 'clean', does the current or specified git repo have no edited tracked files.

With 'pristine|spotless', is the current or specified git repo 'clean' with no untracked files. If it is NOT a worktree, it is checked to make sure that it has no outsanding worktrees. '-v' will print why it is not pristine.

With 'up-to-date', is the current or specified git repo up to date with its remote branch. If there is no remote branch, the return is always true.

Note that 'pristine|spotless' and 'up-to-date' are unrelated. The branch can be 'up-to-date', yet have editable files.

=item name

Print the name of the remote repo.

=item pr

  git repo pr --get [--silent]

Deal with pull requests related to the current repo. --get will look for an open pull request for this branch against remotes 'upstream' and then 'origin'. --silent will supress printing the PR reference so that you can just used the return value; 0 if there is an open pull request, 1 if not.

=item revert/reset/restore

Performs a realclean, resets all uncommitted changes.

=item sync

 --branch branch [--remote remote]

Run a 'git pull' against the --remote and --branch specified.

 --def[ault]

If --def or --default is specifed instead of --branch and --remote, then we use
that default branch of the repo as the branch name to sync against and we look
for that branch in the remotes 'upstream' and 'origin' in that order, using the
first one in which we find.

=item purge/prune

This command is different. It does not work on the current repo. It loops over
a list of repos or, if no list is provided, all the repos. If a repo has
worktrees, it runs 'git worktree delete' on each one. If a repo has no open
pulls, no worktrees and is completely clean (as determined by 'git repo is
pristine'. no) then it prompts to accept deleting the repo.

**NOTE:** This probably belongs in git mono or a git repos command that would
  replace git mono. The git mono default of 'exec all of this for each repo'
  could be the --exec option of git repos.

=item tags

Show all the tags in ascending version order. Alias for

  git tag --list --sort=v:refname

=back

=cut

__PODUSAGE__

#  LocalWords:  fi
