# -*- sh -*-

# vmfuncs

VMFUNCS_FILE=${BASH_SOURCE[0]}

auditfuncs_init $VMFUNCS_FILE
safe_func_export vmfuncs_audit

. $(which controlfuncs_build) $VMFUNCS_FILE

VMFUNCS_TOOLKIT_FILE=~/.ssh/id_rsa.toolkit
VMFUNCS_TOOLKIT_EXPIRE_FILE=~/.ssh/id_rsa.toolkit.expires
VMFUNCS_BCPCVMS_FILE=~/personal/bin/.bcpcvms

unset NFSMACHINE_LIST
unset NFSMACHINE
declare -a NFSMACHINE_LIST
NFSMACHINE_LIST[0]=nylxdev1.dev.bloomberg.com
NFSMACHINE_LIST[1]=nylxdev2.dev.bloomberg.com

set-nfsmachine ()
{
    vmfuncs_audit "$@"

    if [ -n "$NFSMACHINE" ]
    then
        return $(true)
    fi

    declare -a nfsmachine_list_local
    nfsmachine_list_local=(${NFSMACHINE_LIST[@]})

    local nfsmachine_list_count=${#nfsmachine_list_local[*]}
    while (( nfsmachine_list_count ))
    do
        local idx=$(((RANDOM % $nfsmachine_list_count)))
        NFSMACHINE=${nfsmachine_list_local[$idx]}

        ssh $NFSMACHINE "echo 'Connected!'" 1>/dev/null 2>/dev/null
        if [ "$?" = '0' ]
        then
            return $(true)
        else
            unset NFSMACHINE
            unset nfsmachine_list_local[$idx]
            ((nfsmachine_list_count-=1))
        fi
    done
    echo "Cannot connect to an NFS machine"
    return $(false)
}
safe_func_export set-nfsmachine

check-nfsmachines ()
{
    vmfuncs_audit "$@"

    local m
    for m in ${NFSMACHINE_LIST[@]}
    do
        echo "Checking $m..."
        ssh $m "echo 'Connected!'"
    done
    return $(true)
}
safe_func_export check-nfsmachines

vmchoose ()
{
    ##@@ none||none||vmchoose||pick a VM to connect to
    vmfuncs_audit "$@"

    local PS3='Pick a machine:'
    select vmname in ${!vmips[@]}
    do
        if [ -n "$vmname" ]
        then
            break
        fi
    done
    echo $vmname
}

vmgo ()
{
    ##@@ none||none||vmgo||connect to VM
    vmfuncs_audit "$@"

    vm_toolkit_file_maint

    . $VMFUNCS_BCPCVMS_FILE
    vmname=${1:-undef}

    if [ "${vmips[$vmname]}" = '' ]
    then
        vmname=$(vmchoose)
    fi
    vmip=${vmips[$vmname]}
    ssh -i $VMFUNCS_TOOLKIT_FILE $vmip $@
}
alias govm='vmgo '

vmshow ()
{
    ##@@ none||none||vmshow||show the list of VMs
    vmfuncs_audit "$@"

    cat $VMFUNCS_BCPCVMS_FILE | grep -v 'declare -A vmips'
}
alias showvm='vmshow '

vmadd ()
{
    ##@@ none||none||vmadd||add a VM to the list
    vmfuncs_audit "$@"

    if [ $# != '2' ]
    then
        echo usage vmadd name ip
        return 1
    fi

    echo "vmips[$1]=$2" >> $VMFUNCS_BCPCVMS_FILE
    sort -u $VMFUNCS_BCPCVMS_FILE | grep -v 'declare -A vmips' > $VMFUNCS_BCPCVMS_FILE.$$

    echo 'declare -A vmips' >  $VMFUNCS_BCPCVMS_FILE
    cat $VMFUNCS_BCPCVMS_FILE.$$ >> $VMFUNCS_BCPCVMS_FILE
    rm -f $VMFUNCS_BCPCVMS_FILE.$$
    vmshow
}
alias addvm='vmadd '

vmdel ()
{
    ##@@ none||none||vmdel||remove a VM from the list
    vmfuncs_audit "$@"

    . $VMFUNCS_BCPCVMS_FILE
    vmname=${1:-undef}

    if [ "${vmips[$vmname]}" = '' ]
    then
        vmname=$(vmchoose)
    fi
    cat $VMFUNCS_BCPCVMS_FILE | grep -v "vmips\[$vmname\]=${vmips[$vmname]}" > $VMFUNCS_BCPCVMS_FILE.$$
    mv $VMFUNCS_BCPCVMS_FILE.$$ $VMFUNCS_BCPCVMS_FILE
    vmshow
}
alias delvm='vmdel '

cptonfs ()
{
    ##@@ none||none||cptonfs||copy a file to the vmbounce directory of the NFS filesystem
    vmfuncs_audit "$@"

    set-nfsmachine; status=$?; [ ! "$status" = 0 ] && return $status
    scp "$@" $NFSMACHINE:vmbounce
}
alias cp-to-nfs='cptonfs '
alias scp-to-nfs='cptonfs '

cpfromnfs ()
{
    ##@@ none||none||cpfromfs||copy a file from the vmbounce directory of the NFS filesystem to the local ~/vmbounce directory
    vmfuncs_audit "$@"

    mkdir -p ~/vmbounce
    set-nfsmachine; status=$?; [ ! "$status" = 0 ] && return $status
    scp $NFSMACHINE:vmbounce/* ~/vmbounce
}
alias cp-from-nfs='cpfromnfs '
alias scp-from-nfs='cpfromnfs '

SSHFS_KEY=$HOME/.ssh/id_rsa.toolkit
SSHFS_FTPHOST=devsftp.bloomberg.com
SSHFS_FTPPORT=2222
SSHFS_LOCALHOME=$HOME/nfs
SSHFS_LOCALMBIG=$HOME/MBIG
SSHFS_MBIGNUM=4485

mount-nfs () {
    ##@@ none||none||mount-nfs
    vmfuncs_audit "$@"

    sshfs -oIdentityFile=$SSHFS_KEY -oidmap=user -p$SSHFS_FTPPORT \
          $SSHFS_FTPHOST:. \
          $SSHFS_LOCALHOME
}

umount-nfs () {
    ##@@ none||none||umount-nfs
    vmfuncs_audit "$@"

    sudo umount $SSHFS_LOCALHOME
}

mount-MBIG () {
    ##@@ none||none||mount-MBIG
    vmfuncs_audit "$@"

    sshfs -oIdentityFile=$SSHFS_KEY -oidmap=user -p$SSHFS_FTPPORT \
          $SSHFS_FTPHOST:/bb/mbig/mbig${SSHFS_MBIGNUM} \
          $SSHFS_LOCALMBIG
}

umount-MBIG () {
    ##@@ none||none||umount-MBIG
    vmfuncs_audit "$@"

    sudo umount $SSHFS_LOCALMBIG
}

mount-sshfs () {
    ##@@ none||none||mount-sshfs
    vmfuncs_audit "$@"

    mount-nfs && mount-MBIG
    return $?
}

umount-sshfs () {
    ##@@ none||none||umount-sshfs
    vmfuncs_audit "$@"

    umount-nfs && umount-MBIG
    return $?
}

bldo-check ()
{
    ##@@ none||none||bldo-check||ssh all the BDLO machines to refresh the RSA keys
    vmfuncs_audit "$@"

    local tmpout=$(mktemp)
    local interactive=$1
    local bldos=$(cat /bb/csdata/bldfarm/pools/*BLDO* 2>/dev/null)
    if [ -z "$bldos" ]
    then
        echo No BLDO files found
    else
        local hcount=$(echo $bldos | wc -w)
        local hindex=0
        for h in $bldos
        do
            ((hindex+=1))
            echo "*** $h ($hindex/$hcount) ***"
            ssh $h "echo 'Connected.'" 2>&1 | tee $tmpout
            local info=$(grep 'Offending RSA key in' $tmpout | perl -pe 'chomp;chop;s/.* //')
            if [ -n "$info" ]
            then
                is-interactive
                if [ "$?" = "${TRUE}" ]
                then
                    local data
                    asplit data : "$info"
                    sedinplace "${data[1]}d" ${data[0]}
                    ssh $h "echo 'Connected.'"
                fi
            fi
        done
    fi
}

bldo-go ()
{
    ##@@ none||none||bldo-go
    vmfuncs_audit "$@"

    local arch='.*'
    OPTSARGS=$(getoptp  --long arch: -n 'bldo-go' -- "$@")
    local status=$?
    ((status != 0)) && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --arch)
                case $2 in
                    i|ibm|aix)
                        arch=ibldo;;
                    l|lnx|linux|amd64)
                        arch=lnxbldo;;
                    s|sun|sol|solaris)
                        arch=sbldo;;
                    *)
                        echo "$2 is not a valid arch"
                        return 1
                        ;;
                esac
                shift;shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    machine=$( cat /bb/csdata/bldfarm/pools/*BLDO* \
                      | grep -E "$arch" \
                      | head -$(($RANDOM%$(cat /bb/csdata/bldfarm/pools/*BLDO* \
                                                  | grep -E "$arch" \
                                                  | wc -l))) | tail -1)

    ssh $machine;
}

vmrebuild ()
{
    ##@@ none||none||vmrebuild
    vmfuncs_audit "$@"

    local opt_berks=0
    local opt_build=0
    local opt_post=0
    OPTSARGS=$(getoptp -o s --long berks,build,post,ip:,keypair: -n 'vmbuild' -- "$@")
    local status=$?
    ((status != 0)) && $usage_func && return $status

    eval set -- "$OPTSARGS"
    while true
    do
        case "$1" in
            --berks) opt_berks=1; shift ;;
            --build) opt_build=1; shift ;;
            --post) opt_post=1; shift ;;
            --ip) opt_ip=$2; shift; shift;;
            --keypair) opt_keypair=$2; shift; shift;;
            --) shift; break ;; ## end of opts, remaining $*, if any, are args
            *) echo "Internal error!"; $usage_func; return 1 ;;
        esac
    done

    local strikes

    ((!opt_berks)) && ((!opt_build)) && ((!opt_post)) && echo "ERROR: Need one of --berks, --build, --post options" && return 1

    if [ ! -r /home/${USER}/.ssh/id_rsa.toolkit ]
    then
        echo "ERROR: No id_rsa.toolkit file found"
        ((strikes+=1))
    fi

    if ((opt_berks))
    then
        set-nfsmachine; status=$?; [ ! "$status" = 0 ] && return $status

        if [ -z "$(which berks)" ]
        then
            echo "ERROR: No berks available here"
            ((strikes+=1))

            echo "Checking NFS:"
            ssh ${NFSMACHINE} ls -lad /home/${USER}/public_html
            (($?)) && echo "ERROR: NFS check" && ((strikes+=1))
        fi
    fi

    if ((opt_build))
    then
        [ -z "$opt_ip" ] && echo "ERROR: Missing --ip. Need floating IP from https://openstack.dob1.bcpc.bloomberg.com/horizon/project/access_and_security/ in the IP Address column of the Floating IPs tab. " \
            && ((strikes+=1))
        [ -z "$opt_keypair" ] && echo "ERROR: Missing --keypair. Need keypair from https://openstack.dob1.bcpc.bloomberg.com/horizon/project/access_and_security/" \
            && ((strikes+=1))

        if [ ! -r ~/.ssh/openstack_dob1_dpkgdev.yml ]
        then
            echo "ERROR: openstack_dob1_dpkgdev.yml missing"
            ((strikes+=1))
        else
            cat ~/.ssh/openstack_dob1_dpkgdev.yml
            echo "Is the password current?"
        fi
    fi

    ((strikes)) && echo "FATAL: $strikes strikes, yer out!" && return $strikes

    if ((opt_berks))
    then
        gitgo ${USER}-dev-cookbook
        (($?)) && return 1

        dirty=$(git status --porcelain)
        if (($?)) || [ -n "$dirty" ]
        then
            echo "ERROR: git repo not clean"
            return 1
        fi

        export BERKS_BBGITHUB_USE_SSH=1
        berks install && (($?)) && return 1
        berks update && (($?)) && return 1
        berks package ${USER}-dev.tar.gz && (($?)) && return 1
        scp ${USER}-dev.tar.gz ${NFSMACHINE}:public_html/ && (($?)) && return 1
    elif ((opt_build))
    then
        gitgo bcpc-sous-chef
        if [ $? = '0' ]
        then
            git pull
        else
            cd ~/gits/bbgithub && (($?)) && return 1
            bbgithub-clone druoso bcpc-sous-chef
        fi

        cookbook=${USER}-dev
        image=''

        echo "Fire up https://openstack.dob1.bcpc.bloomberg.com/horizon/project/instances/"
        echo "and refresh until an instance named ${USER}-dev appears."
        echo "Once it does, select it, go to the Log tab and select View Full Log."
        echo "Refresh the page until the last line looks like:"
        echo "cloud-init[3694]: Cloud-init v. 0.7.6 finished at Tue, 20 Oct 2015 16:07:58 +0000. Datasource DataSourceOpenStack [net,ver=2].  Up 201.62 seconds"

        ./bcpc-sous-chef \
            "$image" \
            --cluster dob1 \
            --credentials ~/.ssh/openstack_dob1_dpkgdev.yml \
            --flavor m1.medium \
            --instance $cookbook \
            --keypair $opt_keypair \
            --recipe-url http://devhtml.dev.bloomberg.com/~$USER/${cookbook}.tar.gz \
            --floating-ip $opt_ip \
            --runlist "${cookbook}::bcpc" --volume "${USER}-home"
    elif ((opt_post ))
    then
        for f in /tmp/mpersico5-dev-cookbook-init
        do
            echo "** $f **"
            $f
        done
    fi
}
