# -*- sh -*-

# utilfuncs

##################################################################################
## Also defined in auditfuncs, as the first *funcs called. Keep then function bodies
## in sync with those copies. But be aware that a utilfuncs-reload will NOT
## reload your changes with all is-func-defined checks. Important if your are testing
## changes to these functions.
##################################################################################
## Start predefs
if [ -z "$(type is_func_defined 2>/dev/null | head -1 | grep 'is a function')" ]
then
    is_func_defined ()
    {
        ##@@ none||none||is_func_defined||Is arg1 defined as a function. Returns 0 for no, 1 for yes.
        if [ -n "$(type $1 2>/dev/null | head -1 | grep 'is a function')" ]
        then
            return 1
        else
            return 0
        fi
    }
fi

is_func_defined safe_func_export
if (($?==0))
then
    safe_func_export ()
    {
        ##@@ none||none||safe_func_export|||Examine the SHELL variable to see if export -f is supported. If so, do so on arg1.
        [ -n "$SHELL" ] && [ $(basename $SHELL) = "bash" ] && export -f $1
    }
    safe_func_export safe_func_export
fi
safe_func_export is_func_defined

is_func_defined repl
if (($?==0))
then
    repl ()
    {
        ##@@ none||none||repl||repl x N - replicate character 'X', N times. Use +n to get a newline.
        local nl=''
        if [ "$1" = '-n' ]
        then
            echo '-n not supported. repl does NOT print a newline by default.'
            echo 'If you want a newline, use +n.'
            return 1
        fi

        if [ "$1" = '+n' ]
        then
            nl=1
            shift
        fi

        local char=$1
        local rep=$2

        if [ "$char" = '-' ]
        then
            printf "="'%.s' $(eval "echo {1.."$((${rep}))"}") | tr '=' "$char"
        else
            printf "${char}"'%.s' $(eval "echo {1.."$((${rep}))"}")
        fi

        [ -n "$nl" ] && echo;
        return 0
    }
    safe_func_export repl
fi

## End predefs.
##################################################################################

UTILFUNCS_FILE=${BASH_SOURCE[0]}

utilfuncs_edit ()
{
    xo $UTILFUNCS_FILE
}
safe_func_export utilfuncs_edit
alias utilfuncs-edit=utilfuncs_edit

utilfuncs_reload ()
{
    . $UTILFUNCS_FILE
}
safe_func_export utilfuncs_reload
alias utilfuncs-reload=utilfuncs_reload

utilfuncs-help () {
    help_strings $UTILFUNCS_FILE "$@"
}

add_bb ()
{
    ##@@ none||none||add_bb||
    addpath -x -f /bb/bin
}
safe_func_export add_bb

## 0-as-success is the correct way to return from commands and functions in
## UNIX so that the typical 0-success-from-UNIX-commands paradigm "just works"
## in statements like the following (assuming xxx is some program exiting 0 or
## function returning 0):
##
##    xxx && echo xxx worked
##
## What you CAN'T do are these
##    if [ xxx ]       ## won't execute
##    if [ $(xxx) ]    ## the value that [] sees is the output from stdout
##
## If you need an 'if', then you are stuck with
##    xxx
##    if [ "$?" = '0' ]
##
## Remember when you were told in CS 101 not to assume that logic values were
## integers and not to mix logic evals with math? :-)
##
is_int ()
{
    ##@@ none||none||is_int||Is an integer. Return 0 if true.
    if [[ $1 =~ ^-?[0-9]+$ ]]
    then
        return 0
    else
        return 1
    fi

}
safe_func_export is_int

is_neg ()
{
    ##@@ none||none||is_neg||Is an integer and is < 0. Return 0 if true.
    is_int $1 && (( $1 < 0 )) && return 0
    return 1
}
safe_func_export is_neg

is_pos ()
{
    ##@@ none||none||is_pos||Is an integer and is >= 0. Return 0 if true.
    is_neg $1 && return 1
    return 0
}
safe_func_export is_pos

pause ()
{
    ##@@ none||none||pause||Print arguments as a prompt. Any keypress moves on.
    read -p "$*"
}
safe_func_export pause

pick ()
{
    ##@@ none||none||pick||Prompt, regexp of valid choices (no /'s), default.
    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare choicesmatch="/$choices/"
    declare prompt="$prompt_text ($choices)"
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
	    if [[ "$choicesmatch" =~ "/$resp/" ]]
	    then
	        echo $resp
            return 0
	    fi
    done
}
safe_func_export pick

yesno ()
{
    ##@@ none||none||yesno||Args: Prompt, y/n default, command and args to run if 'y', returns command status. If no command, prints response, returns 0.
    declare prompt_text=$1;shift
    declare choices="y/n"
    declare default=$1;shift
    declare cmd
    cmd="$@"

    resp=$(pick "$prompt_text" "$choices" "$default")

	if [ "$resp" = 'y' ] || [ "$resp" = 'n' ]
	then
        if [ -z "$cmd" ]
        then
            ## No command, give response
	        echo $resp
	        return 0
        elif [ "$resp" = 'y' ]
        then
            $cmd
            return $?
        else
            return 0
        fi
	fi
}
safe_func_export yesno

dowhich ()
{
    ##@@ none||none||dowhich||Find the executable and then run it with any args.
    declare file=$1;shift
    declare args="$@"

    declare foundit=$(which $file)
    if [ -z "$foundit" ]
    then
        echo "$file not found on PATH"
        return 1
    else
        echo -n "Do $foundit $@"
        yesno "" 'n' $foundit "$@"
        return $?
    fi
}
safe_func_export dowhich

tarcopy ()
{
    ##@@ none||none||tarcopy||Use the tar trick to copy  arg1/* to arg2/* or arg2/arg1/*, with some intelligence.
    local srcdir=$1
    local tgtdir=$2
    if [ ! -e $srcdir ]
    then
        echo "$srcdir not found"
        return 1
    fi
    if [ ! -d $srcdir ]
    then
        echo "Source '$srcdir' must be a directory"
        return 1
    fi
    if [ $(basename $srcdir) = $(basename $tgtdir) ]
    then
        echo "You're trying to copy $srcdir to $tgtdir."
        echo "You probably want to use $(dirname $tgtdir)"
        echo "as the target instead."
        return 1
    fi
    if [ ! -e $tgtdir ]
    then
        echo "$tgtdir not found. Creating..."
        mkdir $tgtdir || return 1
        return 1
    fi
    if [ ! -d $tgtdir ]
    then
        echo "Target '$tgtdir' must be a directory"
        return 1
    fi
    tgtdir=$(realpath $tgtdir)
    startdir=$(pwd)
    if [ "$srcdir" != '.' ]
    then
        echo "WARNING: You are about to copy $srcdir into $tgtdir"
        echo "instead of copying the CONTENTS of $srcdir into $tgtdir"
        read -p "Do you want to copy the (d)irectory or its (c)ontents? " resp
        if [ "$resp" = 'd' ]
        then
            echo 'Ok...'
        elif [ "$resp" = 'c' ]
        then
            echo "Yeah, that's what I figured"
            echo "*** builtin cd $srcdir"
            builtin cd $srcdir
            srcdir='.'
        else
            echo "d or c, how hard could that have been???"
            return 1
        fi
    fi
    echo "*** tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)"
    tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)
    if [ $(pwd) != "$startdir" ]
    then
        echo "*** builtin cd $startdir"
        builtin cd $startdir
    fi
}
safe_func_export tarcopy
alias tarcp='tarcopy '

list ()
{
    ##@@ none||none||list||Print each argument on its own line.
    for i in "$@"
    do
        echo $i
    done
}
safe_func_export list

cattail ()
{
    ##@@ none||none||cattail||cat the whole file then continue tail -f
    tail -n +1 -f "$@"
}
safe_func_export cattail

tail_number_add ()
{
    ##@@ none||none||tail_number_add||Add a '(' and an index number to each argument.
    local count=$#
    local pad=${#count}
    local i=0
    local out
    for a in "$@"
    do
        ((i+=1))
        local e=$(printf '%s(%d' "$a" $i)
        out="$out $e"
    done
    echo "$out"
}
safe_func_export tail_number_add

tail_number_strip ()
{
    ##@@ none||none||tail_number_strip||From each argument (in theory the product of tail_number_add), strip from the '(' to the end.
    local out
    local a
    for a in "$@"
    do
        out="$out ${a%(*}"
    done
    echo "$out"
}
safe_func_export tail_number_strip

##
## Bash array functions
##

## References:
## http://www.tech-recipes.com/rx/911/queue-and-stack-using-array/
## http://stackoverflow.com/questions/12691121/bash-array-expansion-using-variable-indirection-expansion
## http://stackoverflow.com/questions/23819839/assign-to-a-bash-array-variable-indirectly-by-dynamically-constructed-variable
##     bash 4.3+: use declare -n to effectively create an alias ('nameref') of another variable

bash_current_version_compare()
{
    ##@@ none||none||bash_current_version_compare||Compare current bash shell's version against the version in arg1. Return 255, 0, 1 accordingly (because -1 gets foobared in shell).
    local other_bash_version
    ## Can't use asplit here - catch 22
    IFS='.' read -r -a array_alias <<< "$1"

    local i
    for i in 0 1 2 3
    do
        [ -z "${other_bash_version[$i]}" ] && other_bash_version[$i]=0
        if (( ${BASH_VERSINFO[$i]} < ${other_bash_version[$i]} ))
        then
            return -1
        fi
        if (( ${BASH_VERSINFO[$i]} > ${other_bash_version[$i]} ))
        then
            return 1
        fi
    done
    return 0
}

bash_current_version_compare 4.3
comp=$?
if ((comp==255))
then
    echo "Cannot define array functions that use declare -n in bash $BASH_VERSION. Must be >= 4.3"
else

## Don't indent or else imenu won't find the functions.

asplit ()
{
    ##@@ none||none||asplit||Take the single string in arg3, split it by the string in arg2 and stuff it into the array named by arg1. arg2 is NOT a regexp.
    declare -n array_alias="$1"
    IFS="$2" read -r -a array_alias <<< "$3"
}

aclear ()
{
    declare -n array_alias="$1"
    array_alias=()
    return 0
}
safe_func_export aclear

alength ()
{
    declare -n array_alias="$1"
    echo ${#array_alias[@]}
    return 0
}
safe_func_export alength

alist ()
{
    local use_idx=0
    if [ "$1" = '--idx' ]
    then
        use_idx=1
        shift
    fi

    declare -n array_alias="$1"
    if [ "$use_idx" = 1 ]
    then
        for i in "${!array_alias[@]}"
        do
            printf "%s\t%s\n" "$i" "${array_alias[$i]}"
        done
    else
        for i in "${array_alias[@]}"
        do
            echo $i
        done
    fi
    return 0
}
safe_func_export alist

asplice ()
{
    declare -n array_alias="$1"; shift
    local offset=0; [ -n "$1" ] && offset=$1 && shift
    if (( $offset < 0 ))
    then
        ((offset=${#array_alias[@]}+$offset))
    fi
    local length=0; [ -n "$1" ] && length=$1 && shift
    ((length+=1))

    local removed=("${array_alias[@]:$offset:$length}")
    alist removed
    array_alias=("${array_alias[@]:0:$(($offset))}" "$@" "${array_alias[@]:$(($length+$offset))}")
    return 0
}

apush ()
{
    local array_name="$1";shift
    asplice $array_name $(alength $array_name) 0 "$@"
    return $?
}
safe_func_export apush

apop ()
{
    local array_name="$1";shift
    asplice $array_name -1
    return $?
}
safe_func_export apop

ashift ()
{
    local array_name="$1";shift
    asplice $array_name 0 1
    return $?
}
safe_func_export ashift

aunshift ()
{
    local array_name="$1";shift
    asplice $array_name 0 0 "$@"
    return $?
}
safe_func_export aunshift
fi

unset NFSMACHINE_LIST
unset NFSMACHINE
declare -a NFSMACHINE_LIST
NFSMACHINE_LIST[0]=nylxdev1.dev.bloomberg.com
NFSMACHINE_LIST[1]=nylxdev2.dev.bloomberg.com

set-nfsmachine ()
{
    declare -a nfsmachine_list_local
    nfsmachine_list_local=(${nfsmachine_list_local[@]})

    while (( ${#nfsmachine_list_local[*]} ))
    do
        local idx=$(((RANDOM % ${#nfsmachine_list_local[*]})))
        NFSMACHINE=${nfsmachine_list_local[$idx]}

        ssh $NFSMACHINE "echo 'Connected!'" 1>/dev/null 2>/dev/null
        if [ "$?" = '0' ]
        then
            return 0
        else
            unset NFSMACHINE
            unset nfsmachine_list_local[$idx]
        fi
    done
    echo "Cannot connect to an NFS machine"
    return 1
}

check-nfs-machines ()
{
    local m
    for m in ${NFSMACHINE_LIST[@]}
    do
        echo "Checking $m..."
        ssh $m "echo 'Connected!'"
    done
}
