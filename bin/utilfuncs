# -*- sh -*-

# utilfuncs

UTILFUNCS_FILE=${BASH_SOURCE[0]}
utilfuncs_edit ()
{
    xo $UTILFUNCS_FILE
}
export -f utilfuncs_edit
alias utilfuncs-edit=utilfuncs_edit

utilfuncs_reload ()
{
    . $UTILFUNCS_FILE
}
export -f utilfuncs_reload
alias utilfuncs-reload=utilfuncs_reload

add_bb ()
{
    addpath -x -f /bb/bin
}
export -f add_bb

## 0 as true is the 'right' way for UNIX so that (($?)) "works", i.e.; (( $? ))
## && echo 'truth', because programs return error codes - 0 is no error.  Note,
## however that if (( $? )) is FALSE. Remember when you were told not to assume
## that logic values were integers and to mix logic evals with math? :-)
is_int ()
{
    if [[ $1 =~ ^-?[0-9]+$ ]]
    then
        return 0 ## Unix TRUE/success
    else
        return 1
    fi

}
export -f is_int
is_neg ()
{
    is_int $1 && (( $1 < 0 )) && return 0
    return 1
}
export -f is_neg

is_pos ()
{
    is_neg $1 && return 1
    return 0
}
export -f is_pos

pause ()
{
    read -p "$*"
}
export -f pause

pick ()
{
    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare choicesmatch="/$choices/"
    declare prompt="$prompt_text ($choices)"
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
	    if [[ "$choicesmatch" =~ "/$resp/" ]]
	    then
	        echo $resp
            return 0
	    fi
    done
}

## Here we went with 0 is true, because it matched the return from potentially
## executing commands on a 'y' response. Go figure...
yesno ()
{
    declare prompt_text=$1;shift
    declare choices="y/n"
    declare default=$1;shift
    declare cmd
    cmd="$@"

    resp=$(pick "$prompt_text" "$choices" "$default")

	if [ "$resp" = 'y' ] || [ "$resp" = 'n' ]
	then
        if [ -z "$cmd" ]
        then
            ## No command, give response
	        echo $resp
	        return 0
        elif [ "$resp" = 'y' ]
        then
            $cmd
            return $?
        else
            return 0
        fi
	fi
}
export -f yesno

dowhich ()
{
    declare file=$1;shift
    declare action="$@"

    declare foundit=$(which $file)
    if [ -z "$foundit" ]
    then
        echo "$file not found on PATH"
        return 1
    elif [ -z "$action" ]
    then
        echo $foundit
        return 0
    else
        yesno "Use $foundit" 'n' $action $foundit
        return $?
    fi
}
export -f dowhich

tarcopy ()
{
    local srcdir=$1
    local tgtdir=$2
    if [ ! -e $srcdir ]
    then
        echo "$srcdir not found"
        return 1
    fi
    if [ ! -d $srcdir ]
    then
        echo "Source '$srcdir' must be a directory"
        return 1
    fi
    if [ $(basename $srcdir) = $(basename $tgtdir) ]
    then
        echo "You're trying to copy $srcdir to $tgtdir."
        echo "You probably want to use $(dirname $tgtdir)"
        echo "as the target instead."
        return 1
    fi
    if [ ! -e $tgtdir ]
    then
        echo "$tgtdir not found"
        return 1
    fi
    if [ ! -d $tgtdir ]
    then
        echo "Target '$tgtdir' must be a directory"
        return 1
    fi
    echo "*** tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)"
    tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)
}
export -f tarcopy
alias tarcp='tarcopy '

list ()
{
    for i in "$@"
    do
        echo $i
    done
}

cattail ()
{
    tail -n +1 "$@"
}

tail_number_select ()
{
    local count=$#
    local pad=${#count}
    local i=0
    local out
    for a in "$@"
    do
        ((i+=1))
        local e=$(printf '%s(%d' "$a" $i)
        out="$out $e"
    done
    echo "$out"
}

tail_number_strip()
{
    local out
    local a
    for a in "$@"
    do
        out="$out ${a%(*}"
    done
    echo "$out"
}
