# -*- sh -*-

# utilfuncs

UTILFUNCS_FILE=${BASH_SOURCE[0]}
utilfuncs_edit ()
{
    xo $UTILFUNCS_FILE
}
export -f utilfuncs_edit
alias utilfuncs-edit=utilfuncs_edit

utilfuncs_reload ()
{
    . $UTILFUNCS_FILE
}
export -f utilfuncs_reload
alias utilfuncs-reload=utilfuncs_reload

add_bb ()
{
    addpath -x -f /bb/bin
}
export -f add_bb

## 0 as true is the 'right' way for UNIX so that (($?)) "works", i.e.; (( $? ))
## && echo 'truth', because programs return error codes - 0 is no error.  Note,
## however that if (( $? )) is FALSE. Remember when you were told not to assume
## that logic values were integers and to mix logic evals with math? :-)
is_int ()
{
    if [[ $1 =~ ^-?[0-9]+$ ]]
    then
        return 0 ## Unix TRUE/success
    else
        return 1
    fi

}
export -f is_int
is_neg ()
{
    is_int $1 && (( $1 < 0 )) && return 0
    return 1
}
export -f is_neg

is_pos ()
{
    is_neg $1 && return 1
    return 0
}
export -f is_pos

pause ()
{
    read -p "$*"
}
export -f pause

## Here we went with 0 is true, because it matched the return from potentially
## executing commands on a 'y' response. Go figure...
yesno ()
{
    declare prompt_text=$1;shift
    declare prompt="$prompt_text (y/n)"
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    declare cmd
    cmd="$@"

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
	    if [ "$resp" = 'y' ] || [ "$resp" = 'n' ]
	    then
            if [ -z "$cmd" ]
            then
                ## No command, give response
	            echo $resp
	            return 0
            elif [ "$resp" = 'y' ]
            then
                $cmd
                return $?
            else
                return 0
            fi
	    fi
    done
}
export -f yesno

dowhich ()
{
    declare file=$1;shift
    declare action="$@"

    declare foundit=$(which $file)
    if [ -z "$foundit" ]
    then
        echo "$file not found on PATH"
        return 1
    elif [ -z "$action" ]
    then
        echo $foundit
        return 0
    else
        yesno "Use $foundit" 'n' $action $foundit
        return $?
    fi
}
export -f dowhich

tarcopy ()
{
    echo 'tar cf - * | ( cd $tgtdir; tar xvfp -)'
    echo 'also consider cp -a src[ src...] tgtdir'
}
export -f tarcopy

list ()
{
    for i in "$@"
    do
        echo $i
    done
}

cattail ()
{
    tail -n +1 "$@"
}
