# -*- sh -*-

# utilfuncs

#######################################################################
## Defined first because they are needed further down in utilfuncs and
## everywhere else.
#######################################################################
# Start early defs

is_func_defined ()
{
    ##@@ none||none||is_func_defined||Is arg1 defined as a function. Returns 0 for no, 1 for yes.
    if [ -n "$(type $1 2>/dev/null | head -1 | grep 'is a function')" ]
    then
        return 0 ## UNIX TRUE
    else
        return 1 ## UNIX FALSE
    fi
}

safe_func_export ()
{
    ##@@ none||none||safe_func_export|||Examine the SHELL variable to see if export -f is supported. If so, do so.
    [ -z "$1" ] && echo "usage: safe_func_export [funcname || --all]" && return 1;
    if [ -n "$SHELL" ] && [ $(basename $SHELL) = "bash" ]
    then
        local funcnames
        if [ "$1" = '--file' ]
        then
            funcnames=$(grep -E '^[a-zA-Z0-9_-]+\s*\(\)' $2 | sed 's/().*//')
        elif [ "$1" = '--all' ]
        then
            funcnames=$( declare -F | grep -v -- '-fx' | sed 's/declare -f//' )
        else
            funcnames="$@"
        fi
        export -f $funcnames
    fi
}

repl ()
{
    ##@@ none||none||repl||repl x N - replicate character 'X', N times. Use +n to get a newline.
    local nl=''
    if [ "$1" = '-n' ]
    then
        echo '-n not supported. repl does NOT print a newline by default.'
        echo 'If you want a newline, use +n.'
        return 1
    fi

    if [ "$1" = '+n' ]
    then
        nl=1
        shift
    fi

    local char=$1
    local rep=$2

    if [ "$char" = '-' ]
    then
        printf "="'%.s' $(eval "echo {1.."$((${rep}))"}") | tr '=' "$char"
    else
        printf "${char}"'%.s' $(eval "echo {1.."$((${rep}))"}")
    fi

    [ -n "$nl" ] && echo;
    return 0
}

editor_opt () {
    ## Args are
    ##   default value for editor
    ##   other args
    ## Echos the editor value
    ## Return status is the number of shifts to perform
    local editor=$1;shift
    local shifts=0
    if [ "$1" = '--editor' ]
    then
        editor=$2;shifts=2
    elif [[ $1 =~ ^--(.*) ]]
    then
        editor=${BASH_REMATCH[1]};shifts=1
    fi
    echo $editor
    return $shifts
}

## Load auditfuncs here so we can audit the utils. We assume that we are all in
## the same dir.
current_path=$(dirname ${BASH_SOURCE[0]})
. $current_path/auditfuncs

## FPATH in bash. Hooray!  Uncomnent after making sure it does not break cron
## jobs:
[ -e $current_path/autoloadfuncs ] && . $current_path/autoloadfuncs

# End early defs
##################################################################################

auditfuncs-init
## We use this construction to find controlfuncs_build because we load this
## before we set up personal path stuff.
. $(dirname $UTILFUNCS_FILE)/controlfuncs_build $UTILFUNCS_FILE

## 0-as-success is the correct way to return from commands and functions in
## UNIX so that the typical 0-success-from-UNIX-commands paradigm "just works"
## in statements like the following (assuming xxx is some program exiting 0 or
## function returning 0):
##
##    xxx && echo xxx worked
##
## What you CAN'T do are these
##    if [ xxx ]       ## won't execute
##    if [ $(xxx) ]    ## the value that [] sees is the output from stdout
##
## If you need an 'if', then you are stuck with
##    xxx; if [ "$?" = "$(true)" ]
##
## So to make that easier, we define
##
TRUE=$(true;echo $?)
export TRUE
##
## so that you can use
##    xxx; if [ "$?" = "${TRUE}" ]
##
## Now, we also define
##
FALSE=$(false;echo $?)
export FALSE
##
## but since that's only a single value, you are probably better off using
##    xxx; if [ ! "$?" = "${TRUE}" ]
## instead.
##
## Remember when you were told in CS 101 not to assume that logic values were
## integers and not to mix logic evals with math? :-)
##
## The easiest way to enforce this is to return $(true) and $(false) instead of
## 0 and 1 from functions.
##
## And we should ALWAYS use SOME value when returning; do not use naked
## returns, which usually happens when return is used to bail early from a deep
## control structure. Do not depend on the return value of the last command
## executed; return it explicitly or return $(true) if you don't care.
##

## These make checking function returns read more naturally.
OK=$TRUE
export OK
NOT_OK=$FALSE
export NOT_OK
NOOK=$FALSE
export NOOK
NOK=$FALSE
export NOK

##############
## Numerics ##
##############
is-int ()
{
    ##@@ none||none||is-int||Is an integer. Return 0 if true.
    utilfuncs_audit "$@"

    if [[ $1 =~ ^-?[0-9]+$ ]]
    then
        return $(true)
    else
        return $(false)
    fi

}

is-neg ()
{
    ##@@ none||none||is-neg||Is an integer and is < 0. Return 0 if true.
    utilfuncs_audit "$@"

    is-int $1 && (( $1 < 0 )) && return $(true)
    return $(false)
}

is-pos ()
{
    ##@@ none||none||is-pos||Is an integer and is >= 0. Return 0 if true.
    utilfuncs_audit "$@"

    is-neg $1 && return $(false)
    return $(true)
}

###################
## Interactivity ##
###################
STDIN=0;export STDIN
STDOUT=1;export STDOUT
STDERR=2;export STDERR

is-interactive ()
{
    tty > /dev/null
    return $?
}

is-redirected ()
{
    if [ -t $1 ]
    then
        return $NOK
    else
        return $OK
    fi
}

pause ()
{
    ##@@ none||none||pause||Print arguments as a prompt. Any keypress moves on.
    utilfuncs_audit "$@"

    read -p "$*"
    return $?
}

pick ()
{
    ##@@ none||none||pick||Prompt, list of valid choices separated by /'s, default.
    utilfuncs_audit "$@"

    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare choicesmatch="/$choices/"
    declare prompt=$(echo "$prompt_text ($choices)" | perl -pe 's/\s+/ /g')
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
	    if [[ "$choicesmatch" =~ "/$resp/" ]]
	    then
	        echo $resp
            return $?
	    fi
    done
}

yesno ()
{
    ##@@ none||none||yesno||Args: Prompt, y/n default, command and args to run if 'y', returns command status. If no command, prints response, returns 0.
    utilfuncs_audit "$@"

    declare prompt_text=$1;shift
    declare choices="y/n"
    declare default=$1;shift
    declare cmd
    cmd="$@"

    resp=$(pick "$prompt_text" "$choices" "$default")

	if [ "$resp" = 'y' ] || [ "$resp" = 'n' ]
	then
        if [ -z "$cmd" ]
        then
            ## No command, give response
	        echo $resp
	        return $(true)
        elif [ "$resp" = 'y' ]
        then
            $cmd
            return $?
        else
            return $(true)
        fi
	fi
}

##########################
## Bash array functions ##
##########################

## References:
## http://www.tech-recipes.com/rx/911/queue-and-stack-using-array/
## http://stackoverflow.com/questions/12691121/bash-array-expansion-using-variable-indirection-expansion
## http://stackoverflow.com/questions/23819839/assign-to-a-bash-array-variable-indirectly-by-dynamically-constructed-variable
##     bash 4.3+: use declare -n to effectively create an alias ('nameref') of another variable

bash_current_version_compare()
{
    ##@@ none||none||bash_current_version_compare||Compare current bash shell's version against the version in arg1. Return 255, 0, 1 accordingly (because -1 gets foobared in shell).
    utilfuncs_audit "$@"

    local other_bash_version
    ## Can't use asplit here - catch 22
    IFS='.' read -r -a array_alias <<< "$1"

    local i
    for i in 0 1 2 3
    do
        [ -z "${other_bash_version[$i]}" ] && other_bash_version[$i]=0
        if (( ${BASH_VERSINFO[$i]} < ${other_bash_version[$i]} ))
        then
            return 255
        fi
        if (( ${BASH_VERSINFO[$i]} > ${other_bash_version[$i]} ))
        then
            return 1
        fi
    done
    return 0
}

bash_current_version_compare 4.3
comp=$?
if ((comp==255))
then
    echo "Cannot define array and hash functions that use declare -n in bash $BASH_VERSION. Must be >= 4.3"
else
## Don't indent off of the else, or else imenu won't find the functions.
ajoin()
{
    ##@@ none||none||ajoin||Print one string that joins arg2, arg3, etc, separated by arg1
    utilfuncs_audit "$@"

    local IFS="$1"; shift; echo "$*";return $?
}

asplit_to_stdout ()
{
    ##@@ none||none||asplit||Take the single string in arg2, split it by the string in arg1 and print the pieces to stdout. arg1 is NOT a regexp.
    local tmp
    ## 'local' not needed for IFS here since it's all one command.
    IFS="$1" read -r -a tmp <<< "$2"
    status=$?
    echo ${tmp[@]}
    return $status
}
asplit-to-stdout ()
{
    asplit_to_stdout "$@"
}

asplit_to_array ()
{
    ##@@ none||none||asplit||Take the single string in arg3, split it by the string in arg2 and stuff it into the array named by arg1. arg2 is NOT a regexp.
    declare -n array_alias="$1"
    ## 'local' not needed for IFS here since it's all one command.
    IFS="$2" read -r -a array_alias <<< "$3"
    status=$?
    return $status
}
asplit-to-array ()
{
    asplit_to_array "$@"
}

asplit ()
{
    ##@@ none||none||asplit||Take the single string in arg3, split it by the string in arg2 and stuff it into the array named by arg1. arg2 is NOT a regexp. If arg1 is '-', then we just print the pieces to stdout.
    utilfuncs_audit "$@"

    local status
    if [ "$1" = '-' ]
    then
        shift
        asplit_to_stdout "$@"
    else
        asplit_to_array "$@"
    fi
    return $?
}

aclear ()
{
    ##@@ none||none||asplit||Remove all the elements from the array named in arg1.
    utilfuncs_audit "$@"

    declare -n array_alias="$1";shift
    array_alias=()
    return $(true)
}

aset ()
{
    ##@@ none||none||asplit||Set all the elements in the array named in arg1 to the values of arg2, args3, ...
    utilfuncs_audit "$@"

    declare -n array_alias="$1";shift;
    array_alias=("$@")
    return $(true)
}

acopy ()
{
    ##@@ none||none||asplit||Copy all the values from the array named in arg2 to the array named in arg1. arg1 is not cleared first. Sparse indicies are maintined.
    utilfuncs_audit "$@"

    declare -n array_alias_tgt="$1";shift;
    declare -n array_alias_src="$1";shift;
    for i in ${!array_alias_src[@]}
    do
        array_alias_tgt[$i] = "${array_alias_src[$i]}"
    done
    return $(true)
}

aindicies ()
{
    ##@@ none||none||asplit||Print all the index values of the array named in arg1 to stdout, separated by a space. If the -list option is specified, then print each one on a separate line.
    utilfuncs_audit "$@"

    local list=0
    if [ "$1" = '-list' ]
    then
        list=1
        shift;
    fi
    declare -n array_alias="$1"
    if ((list))
    then
        for i in ${!array_alias[@]}
        do
            echo $i
        done
    else
        echo ${!array_alias[@]}
    fi
    return $(true)
}

avalues ()
{
    ##@@ none||none||avalues||Print all the values of the array named in arg1 to stdout, separated by a space. If the -list option is specified, then print each one on a separate line.
    utilfuncs_audit "$@"
    local list=0
    if [ "$1" = '-list' ]
    then
        list=1
        shift;
    fi
    declare -n array_alias="$1"
    if ((list))
    then
        for v in ${array_alias[@]}
        do
            echo $v
        done
    else
        echo ${array_alias[@]}
    fi
    return $(true)
}

aeach ()
{
    ##@@ none||none||aeach||Print all the index values and values of the array named in arg1 to stdout. Each index and value is separated by a space. Each pair is printed on a separate line.
    utilfuncs_audit "$@"

    _listkv "$1"
    return $?
}

acount ()
{
    ##@@ none||none||asplit||Print the number of elements in the array named in arg1 to stdout. This is not necessarily the value of the last index, due to sparseness.
    utilfuncs_audit "$@"

    declare -n array_alias="$1"
    echo ${#array_alias[@]}
    return $(true)
}

_listkv ()
{
    utilfuncs_audit "$@"

    declare -n array_alias="$1"
    for i in "${!array_alias[@]}"
    do
        printf "%s %s\n" "$i" "${array_alias[$i]}"
    done
    return $(true)
}

asplice ()
{
    ##@@ none||none||asplice||arg1 is the name of the array to modify. arg2 is the starting index. arg3 is the number of elements to remove. Removed elements are printed so that they can be captured if --removed is the first argument. Remaining args are what to insert at the removal point.
    utilfuncs_audit "$@"

    local print_removed=0
    [ "$1" = '--removed' ] && print_removed=1 && shift

    declare -n array_alias="$1"; shift

    local offset=0; [ -n "$1" ] && offset=$1 && shift
    (( $offset < 0 )) && ((offset=${#array_alias[@]}+$offset))

    local aal=${#array_alias[@]}
    local length=$((aal-offset)); [ -n "$1" ] && length=$1 && shift

    local removed=("${array_alias[@]:$offset:$length}")
    ((print_removed)) && echo ${removed[@]}

    array_alias=("${array_alias[@]:0:$(($offset))}" "$@" "${array_alias[@]:$(($length+$offset))}")

    return $(true)
}

apush ()
{
    ##@@ none||none||apush||Append arg2, arg3, etc.. to the end of the array named in arg1.
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice $array_name $(acount $array_name) 0 "$@"
    return $?
}

apop ()
{
    ##@@ none||none||apop||Remove one value from the end of the array named in arg1 and print it.
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice --removed $array_name -1
    return $?
}

ashift ()
{
    ##@@ none||none||ashift||Remove one value from the beginning of the array named in arg1 and print it.
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice --removed $array_name 0 1
    return $?
}

aunshift ()
{
    ##@@ none||none||apush||Prepend arg2, arg3, etc.. to the beginning of the array named in arg1.
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice $array_name 0 0 "$@"
    return $?
}

########################################
## Bash hash (assoc. array) functions ##
########################################
## References:
hvalues ()
{
    ##@@ none||none||hvalues||Print all the values of the hash named in arg1 to stdout, separated by a space. If the -list option is specified, then print each one on a separate line.
    utilfuncs_audit "$@"

    local list=0
    if [ "$1" = '-list' ]
    then
        list=1
        shift;
    fi
    declare -n hash_alias="$1";shift
    if ((list))
    then
        for v in ${hash_alias[@]}
        do
            echo $v
        done
    else
        echo ${hash_alias[@]}
    fi
    return $?
}

hkeys ()
{
    ##@@ none||none||hvalues||Print all the keys of the hash named in arg1 to stdout, separated by a space. If the -list option is specified, then print each one on a separate line.
    utilfuncs_audit "$@"

    local list=0
    if [ "$1" = '-list' ]
    then
        list=1
        shift;
    fi
    declare -n hash_alias="$1";shift
    if ((list))
    then
        for k in ${!hash_alias[@]}
        do
            echo $k
        done
    else
        echo ${!hash_alias[@]}
    fi
    return $?
}

## The perl loop
##    foreach (my ($k,$v) = each(%hash)) { ...
## can be had in shell with
##    heach hash | while read -r k v; do...
heach ()
{
    ##@@ none||none||heach||Print all the keys and values of the array named in arg1 to stdout. Each key and value is separated by a space. Each pair is printed on a separate line.
    _listkv $1
    return $?
}
fi ##     echo "Cannot define array functions that use declare -n in bash $BASH_VERSION. Must be >= 4.3"

########################
## Function functions ##
########################
func-name-spoof ()
{
    utilfuncs_audit "$@"

    local spoofing=$(false)
    local iam=${FUNCNAME[1]}
    if [ -n "${FUNCNAME[2]}" ] && \
           [ ! "${FUNCNAME[2]}" = 'source' ] && \
           [ ! "${FUNCNAME[2]}" = 'main' ]
    then
        iam="${FUNCNAME[2]}"
        spoofing=$(true)
    fi
    echo $iam
    return $spoofing
}

comment-stream ()
{
    utilfuncs_audit "$@"

    local comment="$1";shift
    IFS="$(printf '\n')"

    while read -r line
    do
        echo "${comment}$line"
    done
    return $(true)
}

func-echo ()
{
    if [ -n "$FUNC_ECHO_DEBUG" ]
    then
        echo
        echo "----- func-echo -----"
        for i in $(seq 0 $(((${#FUNCNAME[@]}-1))) )
        do
            echo "FUNCNAME[$i]=[${FUNCNAME[$i]}]"
        done
        echo "----- func-echo -----"
        echo
    fi

    local reset_normal="${ANSI_reset}"
    local reset_title=''
    local endofopts=0
    local nonl
    local cont=0
    while [[ "$1" =~ ^- ]] && ((endofopts==0))
    do
        case "$1" in
           --head) echo; shift;;
           --title)
               echo
               reset_title="${reset_normal}"
               reset_normal=''
               shift ;;
           -n | --n) nonl='-n'; shift;;
           -c | --c) cont=1; shift;;
           --)
               endofopts=1;;   ## No shift. Leave this arg in place to be
                               ## processed later on as arguments to tests.
           -* )
               echo "func-echo: $1 is an invalid option."; return 1;;
        esac
    done

    local idx=${#FUNCNAME[@]};((idx-=1))
    local funcname=${FUNCNAME[$idx]}
    [ "${FUNCNAME[$idx]}" = 'main' ] && funcname=$(basename $0)

    local printit=${funcname}
    if ((cont))
    then
        printit=$(echo $funcname | sed 's/./ /g')
    fi
    echo $nonl -e "${ANSI_reverse}>>> ${printit}${reset_normal}: $@${reset_title}"
}

func-pick ()
{
    local prompt_text="$(func-echo -n '')$1"
    shift
    pick "$prompt_text" "$@"
}

func-yesno ()
{
    local prompt_text="$(func-echo -n '')$1"
    shift
    yesno "$prompt_text" "$@"
}

#####################
## Key value store ##
#####################
## TODO: Reimplement with Perl and CACHE::File instead of SQLite.
kvstoreinit ()
{
    local exists_ok=0
    local unique=0
    local reset=0
    while [[ "$1" =~ ^- ]] && ((endofopts==0))
    do
        case "$1" in
            --exists-ok ) exists_ok=1; shift ;;
            --unique    ) unique=1; shift ;;
            --reset     ) reset=1; shift ;;
            --     ) endofopts=1; shift;;
            -*     ) echo "$1 is an invalid option."; return 1;;
        esac
    done

    if [ ! -d ~/.kvdbs ]
    then
        echo Initializing kv storage at ~/.kvdbs
        mkdir ~/.kvdbs
    fi

    local db=$1;

    if [ ! "$(basename $db)" = "$db" ]
    then
        echo "ERROR - kv store name '$db' cannot include directories; all are stored at '~/.kvdbs'"
        return 1
    fi

    local dbfile=~/.kvdbs/$db

    if [ -e $dbfile ]
    then
        if ((reset))
        then
            \rm $dbfile
        elif ((exists_ok))
        then
            return 0
        else
            echo "ERROR - kv store name $db exists"
            return 1
        fi
    fi

    if ((unique))
    then
        ## 'unique' has the use case where multiple processes would need their
        ## own copies of the database. Instead, we generate a UUID and give it
        ## back to the caller to pass back into subsequent calls. This is not
        ## yet implemented in subsequent calls.
        local u=$(uuid)
        echo $u
        sqlite3 $dbfile "create table keyval (uuid text, key text, value text,
                             primary key (uuid, key)"
        local status=$?
        return
    else
        sqlite3 $dbfile "create table keyval (key text primary key, value text)"
        return $?
    fi
}

kvget ()
{
    _kvgetany "value" "$@"
    return $?
}

kvgetvalues ()
{
    _kvgetany "value" "$@"
    return $?
}

kvgetkeys ()
{
    _kvgetany "key" "$@"
    return $?
}

kvgetboth ()
{
    _kvgetany "key,value" "$@"
    return $?
}

_kvgetany ()
{
    local columns=$1; shift

    local endofopts=0
    local sort=''
    local where=''
    local separator=''
    while [[ "$1" =~ ^- ]] && ((endofopts==0))
    do
        case "$1" in
            --sort ) sort='order by 1'; shift ;;
            --rev* ) sort='order by 1 desc'; shift ;;
            --sep* ) separator="--separator $2"; shift; shift ;;
            --     ) endofopts=1; shift;;
            -*     ) echo "$1 is an invalid option."; return 1;;
        esac
    done

    local db=$1; shift

    local dbfile=~/.kvdbs/$db

    if [ ! -e $dbfile ]
    then
        echo "ERROR - kv store name $db does not exist"
        return 1
    fi

    local key="$1"; shift
    local where=''

    [ -n "$key" ] && where="where key like '$key'" ## These databases should be
                                                   ## small enough that using
                                                   ## like in all cases will be
                                                   ## fast enough. Maybe the
                                                   ## SQL engine will convert a
                                                   ## like with no wildcards to
                                                   ## an equal anyway.

    sqlite3 --noheader $separator $dbfile "select $columns from keyval $where $sort"

    return $?
}

kvput ()
{
    ## Insert if DNE, update if it does.
    local db=$1; shift
    local dbfile=~/.kvdbs/$db

    if [ ! -e $dbfile ]
    then
        echo "ERROR - kv store name $db does not exist"
        return 1
    fi

    local key="$1"; shift

    sqlite3 --noheader $dbfile \
            "update keyval
             set key = '$key', value = '$@'
             where key = '$key';

             insert into keyval (key, value)
             select '$key', '$@'
             where (Select Changes() = 0)"
    return $?
}

kvputinit ()
{
    ## Put if DNE, ok if exists and same, bark if exists and different.
    local db=$1; shift
    local dbfile=~/.kvdbs/$db

    if [ ! -e $dbfile ]
    then
        echo "ERROR - kv store name $db does not exist"
        return 1
    fi

    local key="$1"; shift

    local value=$(sqlite3 --noheader $dbfile "select value from keyval where key = '$key'");
    if [ "$value" = "$@" ]
    then
        return 0
    elif [ -z "$value" ]
    then
        sqlite3 --noheader $dbfile "insert into keyval values ('$key', '$@')"
        return $?
    else
        echo "ERROR - kvputinit. Key = '$key'. Init value '$@' does not match existing value '$value' in kv store '$db'"
        return 1
    fi
}

###################
## Miscellaneous ##
###################
dowhich ()
{
    ##@@ none||none||dowhich||Find the executable and then run it with any args.
    utilfuncs_audit "$@"

    declare file=$1;shift
    declare args="$@"

    declare foundit=$(which $file)
    if [ -z "$foundit" ]
    then
        echo "$file not found on PATH"
        return $(false)
    else
        echo -n "Do $foundit $@"
        yesno "" 'n' $foundit "$@"
        return $?
    fi
}

tarcopy ()
{
    ##@@ none||none||tarcopy||Use the tar trick to copy  arg1/* to arg2/* or arg2/arg1/*, with some intelligence.
    utilfuncs_audit "$@"

    local srcdir=$1
    local tgtdir=$2
    if [ ! -e $srcdir ]
    then
        echo "$srcdir not found"
        return $(false)
    fi
    if [ ! -d $srcdir ]
    then
        echo "Source '$srcdir' must be a directory"
        return $(false)
    fi
    if [ $(basename $srcdir) = $(basename $tgtdir) ]
    then
        echo "You're trying to copy $srcdir to $tgtdir."
        echo "You probably want to use $(dirname $tgtdir)"
        echo "as the target instead."
        return $(false)
    fi
    if [ ! -e $tgtdir ]
    then
        echo "$tgtdir not found. Creating..."
        mkdir $tgtdir || return $(false)
    fi
    if [ ! -d $tgtdir ]
    then
        echo "Target '$tgtdir' must be a directory"
        return $(false)
    fi
    tgtdir=$(realpath $tgtdir)
    startdir=$(pwd)
    if [ "$srcdir" != '.' ]
    then
        echo "WARNING: You are about to copy $srcdir into $tgtdir"
        echo "instead of copying the CONTENTS of $srcdir into $tgtdir"
        read -p "Do you want to copy the (d)irectory or its (c)ontents? " resp
        if [ "$resp" = 'd' ]
        then
            echo 'Ok...'
        elif [ "$resp" = 'c' ]
        then
            echo "Yeah, that's what I figured"
            echo "*** builtin cd $srcdir"
            builtin cd $srcdir
            srcdir='.'
        else
            echo "d or c, how hard could that have been???"
            return $(false)
        fi
    fi
    echo "*** tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)"
    tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)
    if [ $(pwd) != "$startdir" ]
    then
        echo "*** builtin cd $startdir"
        builtin cd $startdir
    fi
    return $(true)
}

tarcp ()
{
    tarcopy "$@"
}

list ()
{
    ##@@ none||none||list||Print each argument on its own line.
    utilfuncs_audit "$@"

    ## Don't use echo "$@" | tr ' ' '\n'; it will not respect spaces inside of
    ## an argument.
    for i in "$@"
    do
        echo $i
    done
    return $(true)
}

cattail ()
{
    ##@@ none||none||cattail||cat the whole file then continue tail -f
    utilfuncs_audit "$@"

    tail -n +1 -f "$@"
    return $?
}

tail_number_add ()
{
    ##@@ none||none||tail_number_add||Add a '(' and an index number to each argument.
    utilfuncs_audit "$@"

    local count=$#
    local pad=${#count}
    local i=0
    local out
    for a in "$@"
    do
        ((i+=1))
        local e=$(printf '%s(%d' "$a" $i)
        out="$out $e"
    done
    echo "$out"
    return $?
}

tail_number_strip ()
{
    ##@@ none||none||tail_number_strip||From each argument (in theory the product of tail_number_add), strip from the '(' to the end.
    utilfuncs_audit "$@"

    local out
    local a
    for a in "$@"
    do
        out="$out ${a%(*}"
    done
    echo "$out"
    return $?
}

wcstrip ()
{
    asplit list ' ' "$(wc $@ )"
    apop list > /dev/null
    ajoin ' ' $(avalues -list list)
}

smartwc ()
{
    local filecount=0
    for i in $@
    do
        [ -f $i ] && ((filecount+=1))
    done
    if ((filecount == 1))
    then
        wc "$@" | perl -ape '$_ =~ s/$F[-1]//'
    else
        wc "$@"
    fi
}

simon-says ()
{
    sudo "$@"
}

grep-not-in ()
{
    grep -L "$@"
}

uuid ()
{
    perl -e 'open my $FH, "/dev/urandom"
      or die "Cannot generate UUID\n";
    sysread( $FH, my $r, 16 );
    close $FH;

    # treat $r as 8 16bit quantities using vec, format as a v4 uuid by
    # grouping appropriately and setting the appropriate variant and version
    # bits

    printf "%04x%04x-%04x-%04x-%04x-%04x%04x%04x",
      vec( $r, 0, 16 ), vec( $r, 1, 16 ),
      vec( $r, 2, 16 ),
      ( ( vec( $r, 3, 16 ) & 0x0FFF ) | 0x4000 ),
      ( ( vec( $r, 4, 16 ) & 0x3FFF ) | 0x8000 ),
      vec( $r, 5, 16 ), vec( $r, 6, 16 ), vec( $r, 7, 16 );'
}

get-next-descriptor ()
{
    ##@@ none||none||get-next-descriptor||print the next free shell io descriptor number.
    utilfuncs_audit "$@"
    local found=none
    local fd
    local rco
    local rci
    for fd in {0..255}
    do
        rco="$(true 2>/dev/null >&${fd}; echo $?)";
        rci="$(true 2>/dev/null <&${fd}; echo $?)";
        [[ "${rco}${rci}" = "11" ]] && found=${fd} && break
    done
    if [ -z "$found" ]
    then
        return 1
    else
        echo $found
        return 0
    fi
}

safe_func_export --file $UTILFUNCS_FILE

auditfuncs-end
