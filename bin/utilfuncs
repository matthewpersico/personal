# -*- sh -*-

# utilfuncs

UTILFUNCS_FILE=${BASH_SOURCE[0]}
utilfuncs_edit ()
{
    xo $UTILFUNCS_FILE
}
#nxport -f utilfuncs_edit
alias utilfuncs-edit=utilfuncs_edit

utilfuncs_reload ()
{
    . $UTILFUNCS_FILE
}
#nxport -f utilfuncs_reload
alias utilfuncs-reload=utilfuncs_reload

add_bb ()
{
    addpath -x -f /bb/bin
}
#nxport -f add_bb

## 0 as success is the correct way to return from commands and functions in
## UNIX so that the typical 0 success from UNIX commands just works in
## statements like the following (assuming xxx is some program exiting 0 or
## function returning 0):
##
##    xxx && echo xxx worked
##
## What you CAN'T do are these
##    if [ xxx ]       ## won't execute
##    if [ $(xxx) ]    ## the value that [] sees is the output from stdout
##
## If you need an 'if', then you are stuck with
##    xxx
##    if [ "$?" = '0' ]
##
## Remember when you were told in CS 101 not to assume that logic values were
## integers and not to mix logic evals with math? :-)
is_int ()
{
    if [[ $1 =~ ^-?[0-9]+$ ]]
    then
        return 0
    else
        return 1
    fi

}
#nxport -f is_int
is_neg ()
{
    is_int $1 && (( $1 < 0 )) && return 0
    return 1
}
#nxport -f is_neg

is_pos ()
{
    is_neg $1 && return 1
    return 0
}
#nxport -f is_pos

pause ()
{
    read -p "$*"
}
#nxport -f pause

pick ()
{
    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare choicesmatch="/$choices/"
    declare prompt="$prompt_text ($choices)"
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
	    if [[ "$choicesmatch" =~ "/$resp/" ]]
	    then
	        echo $resp
            return 0
	    fi
    done
}

yesno ()
{
    declare prompt_text=$1;shift
    declare choices="y/n"
    declare default=$1;shift
    declare cmd
    cmd="$@"

    resp=$(pick "$prompt_text" "$choices" "$default")

	if [ "$resp" = 'y' ] || [ "$resp" = 'n' ]
	then
        if [ -z "$cmd" ]
        then
            ## No command, give response
	        echo $resp
	        return 0
        elif [ "$resp" = 'y' ]
        then
            $cmd
            return $?
        else
            return 0
        fi
	fi
}
#nxport -f yesno

dowhich ()
{
    declare file=$1;shift
    declare action="$@"

    declare foundit=$(which $file)
    if [ -z "$foundit" ]
    then
        echo "$file not found on PATH"
        return 1
    elif [ -z "$action" ]
    then
        echo $foundit
        return 0
    else
        yesno "Use $foundit" 'n' $action $foundit
        return $?
    fi
}
#nxport -f dowhich

tarcopy ()
{
    local srcdir=$1
    local tgtdir=$2
    if [ ! -e $srcdir ]
    then
        echo "$srcdir not found"
        return 1
    fi
    if [ ! -d $srcdir ]
    then
        echo "Source '$srcdir' must be a directory"
        return 1
    fi
    if [ $(basename $srcdir) = $(basename $tgtdir) ]
    then
        echo "You're trying to copy $srcdir to $tgtdir."
        echo "You probably want to use $(dirname $tgtdir)"
        echo "as the target instead."
        return 1
    fi
    if [ ! -e $tgtdir ]
    then
        echo "$tgtdir not found"
        return 1
    fi
    if [ ! -d $tgtdir ]
    then
        echo "Target '$tgtdir' must be a directory"
        return 1
    fi
    tgtdir=$(realpath $tgtdir)
    startdir=$(pwd)
    if [ "$srcdir" != '.' ]
    then
        echo "WARNING: You are about to copy $srcdir into $tgtdir"
        echo "instead of copying the CONTENTS of $srcdir into $tgtdir"
        read -p "Do you want to copy the (d)irectory or its (c)ontents? " resp
        if [ "$resp" = 'd' ]
        then
            echo 'Ok...'
        elif [ "$resp" = 'c' ]
        then
            echo "Yeah, that's what I figured"
            echo "*** builtin cd $srcdir"
            builtin cd $srcdir
            srcdir='.'
        else
            echo "d or c, how hard could that have been???"
            return 1
        fi
    fi
    echo "*** tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)"
    tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)
    if [ $(pwd) != "$startdir" ]
    then
        echo "*** builtin cd $startdir"
        builtin cd $startdir
    fi
}
#nxport -f tarcopy
alias tarcp='tarcopy '

list ()
{
    for i in "$@"
    do
        echo $i
    done
}

cattail ()
{
    tail -n +1 "$@"
}

tail_number_select ()
{
    local count=$#
    local pad=${#count}
    local i=0
    local out
    for a in "$@"
    do
        ((i+=1))
        local e=$(printf '%s(%d' "$a" $i)
        out="$out $e"
    done
    echo "$out"
}

tail_number_strip()
{
    local out
    local a
    for a in "$@"
    do
        out="$out ${a%(*}"
    done
    echo "$out"
}
