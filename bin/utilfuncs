# -*- sh -*-

# utilfuncs

#######################################################################
## Defined first because they are needed further down in utilfuncs and
## everywhere else.
#######################################################################
# Start early defs

if [ -z "$(type is_func_defined 2>/dev/null | head -1 | grep 'is a function')" ]
then
    is_func_defined ()
    {
        ##@@ none||none||is_func_defined||Is arg1 defined as a function. Returns 0 for no, 1 for yes.
        if [ -n "$(type $1 2>/dev/null | head -1 | grep 'is a function')" ]
        then
            return 1
        else
            return 0
        fi
    }
fi

is_func_defined safe_func_export
if (($?==0))
then
    safe_func_export ()
    {
        ##@@ none||none||safe_func_export|||Examine the SHELL variable to see if export -f is supported. If so, do so on arg1.
        [ -n "$SHELL" ] && [ $(basename $SHELL) = "bash" ] && export -f $1
    }
    safe_func_export safe_func_export
fi
safe_func_export is_func_defined

is_func_defined repl
if (($?==0))
then
    repl ()
    {
        ##@@ none||none||repl||repl x N - replicate character 'X', N times. Use +n to get a newline.
        local nl=''
        if [ "$1" = '-n' ]
        then
            echo '-n not supported. repl does NOT print a newline by default.'
            echo 'If you want a newline, use +n.'
            return 1
        fi

        if [ "$1" = '+n' ]
        then
            nl=1
            shift
        fi

        local char=$1
        local rep=$2

        if [ "$char" = '-' ]
        then
            printf "="'%.s' $(eval "echo {1.."$((${rep}))"}") | tr '=' "$char"
        else
            printf "${char}"'%.s' $(eval "echo {1.."$((${rep}))"}")
        fi

        [ -n "$nl" ] && echo;
        return 0
    }
    safe_func_export repl
fi

editor_opt () {
    ## Args are
    ##   default value for editor
    ##   other args
    ## Echos the editor value
    ## Return status is the number of shifts to perform
    local editor=$1;shift
    local shifts=0
    if [ "$1" = '--editor' ]
    then
        editor=$2;shifts=2
    elif [[ $1 =~ ^--(.*) ]]
    then
        editor=${BASH_REMATCH[1]};shifts=1
    fi
    echo $editor
    return $shifts
}

# End early defs
##################################################################################

UTILFUNCS_FILE=${BASH_SOURCE[0]}

## Load auditfuncs here so we can audit the utils

. $(dirname $UTILFUNCS_FILE)/auditfuncs


auditfuncs_init $UTILFUNCS_FILE
safe_func_export utilfuncs_audit

utilfuncs_edit ()
{
    utilfuncs_audit "$@"
    local editor; editor=$(editor_opt xo "$@"); shift $?
    $editor $UTILFUNCS_FILE
}
safe_func_export utilfuncs_edit
alias utilfuncs-edit=utilfuncs_edit

utilfuncs_reload ()
{
    utilfuncs_audit "$@"
    . $UTILFUNCS_FILE
}
safe_func_export utilfuncs_reload
alias utilfuncs-reload=utilfuncs_reload
alias utilfuncs-load=utilfuncs_reload

utilfuncs-help () {
    help_strings $UTILFUNCS_FILE "$@"
}

add_bb ()
{
    ##@@ none||none||add_bb||
    utilfuncs_audit "$@"

    addpath -x -f /bb/bin
}
safe_func_export add_bb

## 0-as-success is the correct way to return from commands and functions in
## UNIX so that the typical 0-success-from-UNIX-commands paradigm "just works"
## in statements like the following (assuming xxx is some program exiting 0 or
## function returning 0):
##
##    xxx && echo xxx worked
##
## What you CAN'T do are these
##    if [ xxx ]       ## won't execute
##    if [ $(xxx) ]    ## the value that [] sees is the output from stdout
##
## If you need an 'if', then you are stuck with
##    xxx; if [ "$?" = "$(true)" ]
##
## So to make that easier, we define
##
TRUE=$(true;echo $?)
export TRUE
##
## so that you can use
##    xxx; if [ "$?" = "${TRUE}" ]
##
## Now, we also define
##
FALSE=$(false;echo $?)
export FALSE
##
## but since that's only a single value, you are probably better off using
##    xxx; if [ "! $?" = "${TRUE}" ]
## instead.
##
## Remember when you were told in CS 101 not to assume that logic values were
## integers and not to mix logic evals with math? :-)
##
## The easiest way to enforce this is to return $(true) and $(false) instead of
## 0 and 1 from functions.
##
## And we should ALWAYS use SOME value when returning; do not use naked
## returns, which usually happens when return is used to bail early from a deep
## control structure. Do not depend on the return value of the last command
## executed; return it explicitly or return $(true) if you don't care.
##

## These make checking function returns read more naturally.
OK=$TRUE
export OK
NOT_OK=$FALSE
export NOT_OK

is_int ()
{
    ##@@ none||none||is_int||Is an integer. Return 0 if true.
    utilfuncs_audit "$@"

    if [[ $1 =~ ^-?[0-9]+$ ]]
    then
        return $(true)
    else
        return $(false)
    fi

}
safe_func_export is_int

is_neg ()
{
    ##@@ none||none||is_neg||Is an integer and is < 0. Return 0 if true.
    utilfuncs_audit "$@"

    is_int $1 && (( $1 < 0 )) && return $(true)
    return $(false)
}
safe_func_export is_neg

is_pos ()
{
    ##@@ none||none||is_pos||Is an integer and is >= 0. Return 0 if true.
    utilfuncs_audit "$@"

    is_neg $1 && return $(false)
    return $(true)
}
safe_func_export is_pos

pause ()
{
    ##@@ none||none||pause||Print arguments as a prompt. Any keypress moves on.
    utilfuncs_audit "$@"

    read -p "$*"
    return $?
}
safe_func_export pause

pick ()
{
    ##@@ none||none||pick||Prompt, list of valid choices separated by /'s, default.
    utilfuncs_audit "$@"

    declare prompt_text="$1";shift
    declare choices="$1";shift
    declare choicesmatch="/$choices/"
    declare prompt=$(echo "$prompt_text ($choices)" | perl -pe 's/\s+/ /g')
    declare default=$1;shift
    ## Blank 'echo' is ok - just a new line.
    default=$(echo $default| tr [:upper:] [:lower:] | tr -d [:blank:] )

    if [ -n "$default" ]
    then
	    prompt="$prompt[$default]"
    fi
    prompt="$prompt? "

    declare resp
    while true
    do
	    read -p "$prompt" resp
	    resp=$(echo ${resp:0:1} | tr [:upper:] [:lower:] )
	    if [ -n "$default" ] && [ -z "$resp" ]
	    then
	        resp=$default
	    fi
	    if [[ "$choicesmatch" =~ "/$resp/" ]]
	    then
	        echo $resp
            return $?
	    fi
    done
}
safe_func_export pick

yesno ()
{
    ##@@ none||none||yesno||Args: Prompt, y/n default, command and args to run if 'y', returns command status. If no command, prints response, returns 0.
    utilfuncs_audit "$@"

    declare prompt_text=$1;shift
    declare choices="y/n"
    declare default=$1;shift
    declare cmd
    cmd="$@"

    resp=$(pick "$prompt_text" "$choices" "$default")

	if [ "$resp" = 'y' ] || [ "$resp" = 'n' ]
	then
        if [ -z "$cmd" ]
        then
            ## No command, give response
	        echo $resp
	        return $(true)
        elif [ "$resp" = 'y' ]
        then
            $cmd
            return $?
        else
            return $(true)
        fi
	fi
}
safe_func_export yesno

dowhich ()
{
    ##@@ none||none||dowhich||Find the executable and then run it with any args.
    utilfuncs_audit "$@"

    declare file=$1;shift
    declare args="$@"

    declare foundit=$(which $file)
    if [ -z "$foundit" ]
    then
        echo "$file not found on PATH"
        return $(false)
    else
        echo -n "Do $foundit $@"
        yesno "" 'n' $foundit "$@"
        return $?
    fi
}
safe_func_export dowhich

tarcopy ()
{
    ##@@ none||none||tarcopy||Use the tar trick to copy  arg1/* to arg2/* or arg2/arg1/*, with some intelligence.
    utilfuncs_audit "$@"

    local srcdir=$1
    local tgtdir=$2
    if [ ! -e $srcdir ]
    then
        echo "$srcdir not found"
        return $(false)
    fi
    if [ ! -d $srcdir ]
    then
        echo "Source '$srcdir' must be a directory"
        return $(false)
    fi
    if [ $(basename $srcdir) = $(basename $tgtdir) ]
    then
        echo "You're trying to copy $srcdir to $tgtdir."
        echo "You probably want to use $(dirname $tgtdir)"
        echo "as the target instead."
        return $(false)
    fi
    if [ ! -e $tgtdir ]
    then
        echo "$tgtdir not found. Creating..."
        mkdir $tgtdir || return $(false)
    fi
    if [ ! -d $tgtdir ]
    then
        echo "Target '$tgtdir' must be a directory"
        return $(false)
    fi
    tgtdir=$(realpath $tgtdir)
    startdir=$(pwd)
    if [ "$srcdir" != '.' ]
    then
        echo "WARNING: You are about to copy $srcdir into $tgtdir"
        echo "instead of copying the CONTENTS of $srcdir into $tgtdir"
        read -p "Do you want to copy the (d)irectory or its (c)ontents? " resp
        if [ "$resp" = 'd' ]
        then
            echo 'Ok...'
        elif [ "$resp" = 'c' ]
        then
            echo "Yeah, that's what I figured"
            echo "*** builtin cd $srcdir"
            builtin cd $srcdir
            srcdir='.'
        else
            echo "d or c, how hard could that have been???"
            return $(false)
        fi
    fi
    echo "*** tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)"
    tar cf - $srcdir | ( builtin cd $tgtdir; tar xvfp -)
    if [ $(pwd) != "$startdir" ]
    then
        echo "*** builtin cd $startdir"
        builtin cd $startdir
    fi
    return $(true)
}
safe_func_export tarcopy
alias tarcp='tarcopy '

list ()
{
    ##@@ none||none||list||Print each argument on its own line.
    utilfuncs_audit "$@"

    for i in "$@"
    do
        echo $i
    done
    return $(true)
}
safe_func_export list

cattail ()
{
    ##@@ none||none||cattail||cat the whole file then continue tail -f
    utilfuncs_audit "$@"

    tail -n +1 -f "$@"
    return $?
}
safe_func_export cattail

tail_number_add ()
{
    ##@@ none||none||tail_number_add||Add a '(' and an index number to each argument.
    utilfuncs_audit "$@"

    local count=$#
    local pad=${#count}
    local i=0
    local out
    for a in "$@"
    do
        ((i+=1))
        local e=$(printf '%s(%d' "$a" $i)
        out="$out $e"
    done
    echo "$out"
    return $?
}
safe_func_export tail_number_add

tail_number_strip ()
{
    ##@@ none||none||tail_number_strip||From each argument (in theory the product of tail_number_add), strip from the '(' to the end.
    utilfuncs_audit "$@"

    local out
    local a
    for a in "$@"
    do
        out="$out ${a%(*}"
    done
    echo "$out"
    return $?
}
safe_func_export tail_number_strip

##
## Bash array functions
##

## References:
## http://www.tech-recipes.com/rx/911/queue-and-stack-using-array/
## http://stackoverflow.com/questions/12691121/bash-array-expansion-using-variable-indirection-expansion
## http://stackoverflow.com/questions/23819839/assign-to-a-bash-array-variable-indirectly-by-dynamically-constructed-variable
##     bash 4.3+: use declare -n to effectively create an alias ('nameref') of another variable

bash_current_version_compare()
{
    ##@@ none||none||bash_current_version_compare||Compare current bash shell's version against the version in arg1. Return 255, 0, 1 accordingly (because -1 gets foobared in shell).
    utilfuncs_audit "$@"

    local other_bash_version
    ## Can't use asplit here - catch 22
    IFS='.' read -r -a array_alias <<< "$1"

    local i
    for i in 0 1 2 3
    do
        [ -z "${other_bash_version[$i]}" ] && other_bash_version[$i]=0
        if (( ${BASH_VERSINFO[$i]} < ${other_bash_version[$i]} ))
        then
            return 255
        fi
        if (( ${BASH_VERSINFO[$i]} > ${other_bash_version[$i]} ))
        then
            return 1
        fi
    done
    return 0
}

bash_current_version_compare 4.3
comp=$?
if ((comp==255))
then
    echo "Cannot define array functions that use declare -n in bash $BASH_VERSION. Must be >= 4.3"
else

## Don't indent or else imenu won't find the functions.
ajoin()
{
    ##@@ none||none||ajoin||Print one string of arg2, arg3, etc, separated by arg1
    utilfuncs_audit "$@"

    local IFS="$1"; shift; echo "$*";return $?
}
safe_func_export ajoin

asplit_to_stdout ()
{
    local tmp
    ## 'local' not needed for IFS here since it's all one command.
    IFS="$2" read -r -a tmp <<< "$3"
    status=$?
    echo ${tmp[@]}
    return $status
}

asplit_to_array ()
{
    declare -n array_alias="$1"
    ## 'local' not needed for IFS here since it's all one command.
    IFS="$2" read -r -a array_alias <<< "$3"
    status=$?
    return $status
}

asplit ()
{
    ##@@ none||none||asplit||Take the single string in arg3, split it by the string in arg2 and stuff it into the array named by arg1. arg2 is NOT a regexp. IF arg1 is '-', then we just print the pieces.
    utilfuncs_audit "$@"

    local status
    if [ "$1" = '-' ]
    then
        asplit_to_stdout "$@"
    else
        asplit_to_array "$@"
    fi
    return $?
}
safe_func_export asplit

aclear ()
{
    utilfuncs_audit "$@"

    declare -n array_alias="$1";shift
    array_alias=()
    return $(true)
}
safe_func_export aclear

aset ()
{
    utilfuncs_audit "$@"

    declare -n array_alias="$1";shift;
    array_alias=("$@")
    return $(true)
}
safe_func_export aclear

aindicies ()
{
    utilfuncs_audit "$@"

    declare -n array_alias="$1"
    seq 0 $((${#array_alias[@]}-1))
    return $(true)
}
safe_func_export aindicies

acount ()
{
    utilfuncs_audit "$@"

    declare -n array_alias="$1"
    echo ${#array_alias[@]}
    return $(true)
}
safe_func_export acount

alist ()
{
    utilfuncs_audit "$@"

    local use_idx=0
    if [ "$1" = '--idx' ]
    then
        use_idx=1
        shift
    fi

    declare -n array_alias="$1"
    if [ "$use_idx" = 1 ]
    then
        for i in "${!array_alias[@]}"
        do
            printf "%s\t%s\n" "$i" "${array_alias[$i]}"
        done
    else
        for i in "${array_alias[@]}"
        do
            echo $i
        done
    fi
    return $(true)
}
safe_func_export alist

asplice ()
{
    utilfuncs_audit "$@"

    declare -n array_alias="$1"; shift
    local offset=0; [ -n "$1" ] && offset=$1 && shift
    if (( $offset < 0 ))
    then
        ((offset=${#array_alias[@]}+$offset))
    fi
    local length=0; [ -n "$1" ] && length=$1 && shift
    ((length+=1))

    local removed=("${array_alias[@]:$offset:$length}")
    alist removed
    array_alias=("${array_alias[@]:0:$(($offset))}" "$@" "${array_alias[@]:$(($length+$offset))}")
    return $(true)
}
safe_func_export asplice

apush ()
{
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice $array_name $(acount $array_name) 0 "$@"
    return $?
}
safe_func_export apush

apop ()
{
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice $array_name -1
    return $?
}
safe_func_export apop

ashift ()
{
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice $array_name 0 1
    return $?
}
safe_func_export ashift

aunshift ()
{
    utilfuncs_audit "$@"

    local array_name="$1";shift
    asplice $array_name 0 0 "$@"
    return $?
}
safe_func_export aunshift
fi

func-name-spoof ()
{
    utilfuncs_audit "$@"

    local spoofing=$(false)
    local iam=${FUNCNAME[1]}
    if [ -n "${FUNCNAME[2]}" ] && \
           [ ! "${FUNCNAME[2]}" = 'source' ] && \
           [ ! "${FUNCNAME[2]}" = 'main' ]
    then
        iam="${FUNCNAME[2]}"
        spoofing=$(true)
    fi
    echo $iam
    return $spoofing
}
safe_func_export func-name-spoof

comment-stream ()
{
    utilfuncs_audit "$@"

    local comment="$1";shift
    IFS="$(printf '\n')"

    while read -r line
    do
        echo "${comment}$line"
    done
    return $(true)
}
safe_func_export comment-stream

func-echo ()
{
    if [ -n "$FUNC_ECHO_DEBUG" ]
    then
        echo
        echo "----- func-echo -----"
        for i in $(seq 0 $(((${#FUNCNAME[@]}-1))) )
        do
            echo "FUNCNAME[$i]=[${FUNCNAME[$i]}]"
        done
        echo "----- func-echo -----"
        echo
    fi

    local reset_normal="${ANSI_reset}"
    local reset_title=''

    if [ "$1" = '--head' ]
    then
        echo
        shift
    fi
    if [ "$1" = '--title' ]
    then
        echo
        reset_title="${reset_normal}"
        reset_normal=''
        shift
    fi
    local nonl
    if [ "$1" = '-n' ]
    then
        nonl='-n'
        shift
    fi
    local idx=${#FUNCNAME[@]};((idx-=1))
    local funcname=${FUNCNAME[$idx]}
    [ "${FUNCNAME[$idx]}" = 'main' ] && funcname=$(basename $0)
    echo $nonl -e "${ANSI_reverse}>>> ${funcname}${reset_normal}: $@${reset_title}"
}
safe_func_export func-echo

func-pick ()
{
    if [ -n "$FUNC_PICK_DEBUG" ]
    then
        echo
        echo "----- func-pick -----"
        for i in $(seq 0 $(((${#FUNCNAME[@]}-1))) )
        do
            echo "FUNCNAME[$i]=[${FUNCNAME[$i]}]"
        done
        echo "----- func-pick -----"
        echo
    fi
    local prompt_text="$(func-echo -n '')$1"
    shift
    pick "$prompt_text" "$@"
}
safe_func_export func-pick

func-yesno ()
{
    if [ -n "$FUNC_YESNO_DEBUG" ]
    then
        echo
        echo "----- func-yesno -----"
        for i in $(seq 0 $(((${#FUNCNAME[@]}-1))) )
        do
            echo "FUNCNAME[$i]=[${FUNCNAME[$i]}]"
        done
        env
        echo "----- func-yesno -----"
        echo
    fi
    local prompt_text="$(func-echo -n '')$1"
    shift
    yesno "$prompt_text" "$@"
}
safe_func_export func-yesno

is-interactive ()
{
    tty > /dev/null
    return $?
}
safe_func_export is-interactive

wcstrip ()
{
    asplit list ' ' "$(wc $@ )"
    apop list > /dev/null
    ajoin ' ' $(alist list)
}
safe_func_export wcstrip

smartwc ()
{
    local filecount=0
    for i in $@
    do
        [ -f $i ] && ((filecount+=1))
    done
    if ((filecount == 1))
    then
        wc "$@" | perl -ape '$_ =~ s/$F[-1]//'
    else
        wc "$@"
    fi
}
