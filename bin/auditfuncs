# -*- sh -*-

# auditfuncs

##################################################################################
## Because we call this script before all other *funcs scripts, we predefine a few
## utilities here as well as in utilfuncs. Keep them all in sync.
##################################################################################
## Start predefs
if [ -z "$(type is_func_defined 2>/dev/null | head -1 | grep 'is a function')" ]
then
    is_func_defined ()
    {
        ##@@ none||none||is_func_defined||Is arg1 defined as a function. Returns 0 for no, 1 for yes.
        if [ -n "$(type $1 2>/dev/null | head -1 | grep 'is a function')" ]
        then
            return 1
        else
            return 0
        fi
    }
fi

is_func_defined safe_func_export
if (($?==0))
then
    safe_func_export ()
    {
        ##@@ none||none||safe_func_export|||Examine the SHELL variable to see if export -f is supported. If so, do so on arg1.
        [ -n "$SHELL" ] && [ $(basename $SHELL) = "bash" ] && export -f $1
    }
    safe_func_export safe_func_export
fi
safe_func_export is_func_defined

is_func_defined repl
if (($?==0))
then
    repl ()
    {
        ##@@ none||none||repl||repl x N - replicate character 'X', N times. Use +n to get a newline.
        local nl=''
        if [ "$1" = '-n' ]
        then
            echo '-n not supported. repl does NOT print a newline by default.'
            echo 'If you want a newline, use +n.'
            return 1
        fi

        if [ "$1" = '+n' ]
        then
            nl=1
            shift
        fi

        local char=$1
        local rep=$2

        if [ "$char" = '-' ]
        then
            printf "="'%.s' $(eval "echo {1.."$((${rep}))"}") | tr '=' "$char"
        else
            printf "${char}"'%.s' $(eval "echo {1.."$((${rep}))"}")
        fi

        [ -n "$nl" ] && echo;
        return 0
    }
    safe_func_export repl
fi

## End predefs.
##################################################################################

AUDITFUNCS_FILE=${BASH_SOURCE[0]}

auditfuncs_init ()
{
    local bn=$(basename $1)
    local dn=$(dirname $(realpath $1))
    local audit_system=$(echo $bn | tr '[A-Z]' '[a-z]')
    local audit_system_upper=$(echo $bn | tr '[a-z]' '[A-Z]')
    local audit_system_file="${dn}/../data/${bn}.audit.$(hostname)"

    ## cygwin does not grok "source /dev/stdin <<EOF"
    eval "
${audit_system}_audit ()
{
    [ ! \"\$1\" = '-na' ] && echo \$(date +%Y_%m_%d_%H_%M_%S) \$(repl = \${#FUNCNAME[@]}) \${FUNCNAME[1]} \$@ >> $audit_system_file
}
"
}
auditfuncs_init $AUDITFUNCS_FILE

auditfuncs_edit ()
{
    auditfuncs_audit
    xo $AUDITFUNCS_FILE
}
safe_func_export auditfuncs_edit
## I used to define functions with '_' and aliases with '-' because the emacs
## modes that parse for functions to generate jump lists didn't see functions
## with '-' in their name. But since I've fixed that issue, I should go back
## and rename all these.
alias auditfuncs-edit=auditfuncs_edit

auditfuncs_reload ()
{
    auditfuncs_audit
    . $AUDITFUNCS_FILE
}
safe_func_export auditfuncs_reload
alias auditfuncs-reload=auditfuncs_reload
