# -*- sh -*-
# shellcheck shell=bash

# bash-usage

use on_exit
use mktemp

declare man_center='Persico Utility'
_extract_usage ()
{
    local marker=$1
    local file=$2
    local start_marker_locator
    if start_marker_locator=$(grep -E "^:<<.{0,1}__${marker}__" "$file" 2>/dev/null); then
        local tmpfile
        tmpfile=$(mktempfile)
        touch "$tmpfile"
        [[ $marker == 'USAGE' ]] && echo "${start_marker_locator:1}" >> "$tmpfile"
        sed -e "0,/^$start_marker_locator/d" -e "/^__${marker}__/,\$d" "$file" >> "$tmpfile"
        [[ $marker == 'USAGE' ]] && echo "__${marker}__" >> "$tmpfile"
        echo "$tmpfile"
        true; return
    fi
    false; return
}

_shell_heredoc ()
{
    local usage_file=$1
    local execfile="${usage_file}.sh"
    echo "cat $(cat "${usage_file}")" > "$execfile"
    chmod +x "$execfile"
    "$execfile"
}

_pandoc_heredoc ()
{
    local usage_file=$1
    local man_title=$2
    local man_file="${usage_file}.1"
    cat <<EOMANHEAD > "${usage_file}.wh"
% ${man_title}(1) | ${man_center}
%
% $(date)

$(cat "${usage_file}")
EOMANHEAD

    pandoc -f markdown -t man -s "${usage_file}.wh" >> "${man_file}"
    man -l "$man_file"
}

_guts-usage ()
{
    local src="$1"
    local man_title; man_title=$(basename "${src^^}")
    local -a markers=(MDUSAGE PODUSAGE USAGE)
    local marker
    local m
    for m in "${markers[@]}"; do
        if grep -q -E "^:<<.{0,1}__${m}" "$src"; then
            marker=$m
            break
        fi
    done
    if [[ -z $marker ]]; then
        cmd-echo --id bash-usage -w -- "No usage text found for '$src'."
        false; return
    fi

    local usage_file
    usage_file=$(_extract_usage "$marker" "$src")
    rm-on-exit "$usage_file"
    case $marker in
        MDUSAGE )
            if which pandoc 1>/dev/null 2>&1; then
                _pandoc_heredoc "$usage_file" "$man_title"
            else
                ${PAGER:cat} "$usage_file"
            fi
            ;;
        PODUSAGE )
            pod2man --section 1 --name "$man_title" \
                    --center "$man_center" \
                    --date "$(date -d@"$(stat --printf %Y "$src")")" \
                    --release "" "$usage_file" | man -l -
            ;;
        USAGE )
            _shell_heredoc "$usage_file" | ${PAGER:cat}
            ;;
    esac
}

_script-usage ()
{
    local src
    src="$1"
    if [[ ! -r "$src" ]]; then
        local newsrc
        newsrc=$(type -P "$src" 2>/dev/null)
        if [[ ! -r "$newsrc" ]]; then
            cmd-echo --id bash-usage -w  -- "Cannot find '$src' on PATH to get usage text."
            false; return
        else
            src="$newsrc"
        fi
    fi
    ## And once we have a filename, we just call _guts-usage on it.
    _guts-usage "$src"
}

_func-usage()
{
    local src
    src="$1"
    local newsrc
    newsrc=$(autoload -w "$src") ## A personally modified version of the
                                 ## autoload demo script that comes with
                                 ## bash. -w is "where" and it locates the file
                                 ## in which the function was defined
                                 ## (effectively a find command on FPATH).
    if [[ ! -r "$newsrc" ]]; then
        cmd-echo --id bash-usage -w -- "Cannot find '$src' on FPATH to get usage text."
        false; return
    else
        src="$newsrc"
    fi
    ## And once we have a filename, we just call _guts-usage on it.
    _guts-usage "$src"
}

main() {
    if [[ -z "$1" ]]; then
        cmd-echo --id bash-usage -w -- "Missing argument to read for usage text."
        false; return
    fi
    [[ "$1" =~ ^-+h ]] && bash-usage "$0" && { true; return; }
    if [[ "$1" == --title ]]; then
        man_center="$2"
        shift; shift
    fi

    local src=$1; shift
    local -a extra_usage=("$@")

    [[ -n ${extra_usage[0]} ]] && cmd-echo --color black --reverse --head "** Extended actions **"
    if [[ -r $src ]]; then
        _guts-usage "$src"
    else
        local type
        type=$(type "$src" 2>&1 | head -1 | grep -v 'not found')
        if [[ -z "$type" ]]; then
            cmd-echo --id bash-usage -e -- "$src not found"
        elif [[ "$type" =~ 'is a function' ]]; then
            _func-usage "$src"
        else
            src=${type##"$src" is }
            _script-usage "$src"
        fi
    fi
    if [[ -n ${extra_usage[0]} ]]; then
        cmd-echo --color black --reverse --head "** Standard actions **"
        if is-interactive ; then
            local resp
            resp=$(prompt -n 1 "Hit any key to continue, 'q' to quit...")
            [[ $resp == 'q' ]] && return
        fi
        "${extra_usage[@]}"
    fi
}

main "$@"
exit

:<<'__MDUSAGE__'
# NAME

bash-usage - print the usage text of a script or function

# SYNOPSIS

```
bash-usage file extra usage
bash-usage name extra usage
bash-usage -h
```

# DESCRIPTION

* Given a **file**:

-- pull out the usage text to a temp file

-- format the temp file accordingly


* Given a **name**:

-- determine if **name** is a script or a function

-- find the corresponding source file

-- proceed as above

We recognize three types of usage text:

## shell usage

Using one of these starting markers

```
 :<<__USAGE__
 :<<'__USAGE__'
 :<<"__USAGE__"
```

and an end marker **\_\_USAGE\_\_**, all the text between and including the start and
end markers will be read and processed using **cat <<**. That means text with the
last two quoted forms will be printed verbatim, but text with the unquoted form
will be evaluated for variables and **$()** commands contained within. Caveat
Programmer.

## POD usage

Using one of these starting markers

```
 :<<__PODUSAGE__
 :<<'__PODUSAGE__'
 :<<"__PODUSAGE__"
```

and an end marker **\_\_PODUSAGE\_\_**, all the text between the start and end
markers will be read and processed using **pod2text**. The various quoted forms
do not alter processing, as they do with [shell usage](#shell_usage).

## Markdown usage

Using one of these starting markers

```
 :<<__MDUSAGE__
 :<<'__MDUSAGE__'
 :<<"__MDUSAGE__"
```

and an end marker **\_\_MDUSAGE\_\_**, all the text between the start and end
markers, will be read and processed using **pandoc**. If **pandoc** is not
available, the text will simply be printed out, verbatim. The various quoted
forms do not alter processing, as they do with [shell usage](#shell_usage).

# ARGUMENTS

* name

**name** must be either:

-- the full path to a script

-- script that is on **$PATH**

-- a function name whose corresponding script matches the name exactly and is
   in a directory on **\$FPATH**. Even though bash does not do autoloads, we are
   using a modified version of the **autoload** script that is in the auxilary
   files of bash to load our functions. Our modification uses **\$FPATH** so
   that we can accurately find the definition file and read the usage text from
   there, as the usage comments are (as well as all other comments) are
   stripped from the function text when loaded.

* extra usage

If the command on which you are calling **bash-usage** is an extension of an
existing command, use the remnaining arguments to specify how to execute that
existing usage (ususally **man command** or **command --help**) and
**bash-usage** will execute it for you. Your usage and the original usage will
have distinct headers and you will have the opportuinity to bail out before the
second usage is executed.

# OPTIONS

* -h

Print this help.

__MDUSAGE__
