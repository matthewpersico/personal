#!/usr/bin/env bash
# bash-usage

use on_exit
use mktemp

_guts-usage ()
{
    declare tgt="$1"
    if grep -q -E "^:<<.{0,1}__PODUSAGE" "$tgt"; then
        pod2text "$tgt" | ${PAGER:cat}
    elif grep -q -E "^:<<.{0,1}__USAGE" "$tgt"; then
        declare tmpfile
        tmpfile=$(mktempfile)
        rm-on-exit "$tmpfile"
        declare start_marker
        start_marker_locator=$(grep -E "^:<<.{0,1}__USAGE" "$tgt" )
        start_marker=${start_marker_locator:1}
        ( echo "cat $start_marker"
          sed -e "0,/^$start_marker_locator/d" -e '/^__USAGE__/,$d' "$tgt"
          echo "__USAGE__"
        ) > "$tmpfile"
        chmod +x "$tmpfile"
        "$tmpfile"
    else
        echo "No usage text found for $tgt" >&2
    fi
}

_script-usage ()
{
    declare tgt
    tgt="$1"
    if [ ! -r "$tgt" ]; then
        declare newtgt
        newtgt=$(type -P "$tgt" 2>/dev/null)
        if [ ! -r "$newtgt" ]; then
            cmd-echo -w --id bash-usage -- "Cannot find $tgt on PATH to get usage text"
            exit 1
        else
            tgt="$newtgt"
        fi
    fi
    ## And once we have a filename, we just call _guts-usage on it.
    _guts-usage "$tgt"
}

_func-usage()
{
    declare tgt
    tgt="$1"
    declare newtgt
    newtgt=$(autoload -w "$tgt") ## A personally modified version of the
                                 ## autoload demo script that comes with
                                 ## bash. -w is "where" and it locates the file
                                 ## in which the function was defined
                                 ## (effectively a find command on FPATH).
    if [ ! -r "$newtgt" ]; then
        cmd-echo -w --id bash-usage -- "Cannot find $tgt on FPATH to get usage text"
        exit 1
    else
        tgt="$newtgt"
    fi
    ## And once we have a filename, we just call _guts-usage on it.
    _guts-usage "$tgt"
}

main() {
    declare tgt
    tgt=$1
    [ -z "$tgt" ] && cmd-echo -w --id bash-usage -- "Missing argument to read for usage text" && exit 1
    [[ "$1" =~ ^-+h ]] && bash-usage "$0" && exit 0

    if [[ -r $tgt ]]; then
        _guts-usage "$tgt"
        exit 0
    fi

    declare type
    type=$(type "$tgt" 2>&1 | head -1 | grep -v 'not found')
    if [ -z "$type" ]; then
        echo "$tgt not found"
    elif [[ "$type" =~ 'is a function' ]]; then
        _func-usage "$tgt"
    else
        tgt=${type##$tgt is }
        _script-usage "$tgt"
    fi
}

main "$@"

exit 0

:<<'__PODUSAGE__'
=head1 NAME

bash-usage - print the usage text of a script or function

=head1 SYNOPSIS

 bash-usage name
 bash-usage -h

=head1 DESCRIPTION

Given a file, print the usage therein.

Given 'name', determine if it is a script or a function and from that, go
figure out where the defining text for 'name' is within 'name' and read the
usage information out of it.

We recognize two types of usage text:

=over 4

=item shell usage

Using one of these starting markers

  :<<__USAGE__
  :<<'__USAGE__'
  :<<"__USAGE__'

and an end marker __USAGE__, all the text from start to end markers,
inclusively, will be read and processed using 'cat <<'. That means text with
the last two quoted forms will be printed verbatim, but text with the first
(unquoted) form will be evaluated for variables and $() commands contained
within. Caveat Progremmer.

=item POD usage

Using one of these starting markers

  :<<__PODUSAGE__
  :<<'__PODUSAGE__'
  :<<"__PODUSAGE__'

and an end marker __PODUSAGE__, the entire file is run through 'pod2text' and
all POD within will be processed, regardless of where it is. We simply adopted
the convention of using :<<__PODUSAGE__ when we extended bash-usage to process
it because it was consistent with the muscle memory of the original __USAGE__
convention. The various quoted forms don't mean anything; 'pod2text' will read
the entire file and ignore what is not pod.

=back

=head1 ARGUMENTS

=over 4

=item name

'name' must be either:

 - the full path to a script

 - script that is on $PATH

 - a function name that has been loaded with 'autoload' so that we can
   accurately find the definition file and read the usage text from there,
   as the usage comments (as well as all other comments) are stripped
   from the function text when loaded.

=back

=head1 OPTIONS

=over 4

=item -h

Print this help

=back

=cut

__PODUSAGE__
