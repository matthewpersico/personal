#!/usr/bin/env bash

# sedinplace

##
## Declarations
##

## Cleanup out tempfiles
typeset sedcmdfile=$(mktemp -t tmp.sedinplace.XXXXXXXXXX)
finish ()
{
    if [ -e "$sedcmdfile" ]
    then
        rm -rf "$sedcmdfile"
    fi
}

declare sedopts=''	        ## Options to the sed command
declare sedopt_inplace='-i'	## Particular option declare sedopts
declare opt_confirm=0
declare opt_verbose=0
declare opt_new=''
declare opt_keepscript=0
declare status
declare arg
declare exitstatus=0
declare -a files
declare f

##
## OPTS and ARGS
##

declare OPTSARGS
declare shortopts='kcbvn:'
declare longopts='keepscript,confirm,backup,verbose,new:'

# Process the command line.
OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@")
declare status=$?
((status != 0)) && exit $status

# Reset the command line ($@).
eval set -- "$OPTSARGS"

# Reprocess the command line, extracting options and their arguments into
# variables.
while true
do
    declare option=$1
    shift
    [ "$option" != '--' ] && option=${option##-} && option=${option##-}
    case "$option" in
	    c|confirm)
	        opt_confirm=1
	        sedopt_inplace='-i.sip'
	        ;;
	    b|backup)
	        sedopt_inplace='-i.sip'
	        cmd-echo -- "Backups in .sip files"
	        ;;
	    v|verbose)
	        opt_verbose=1
	        ;;
        n|new)
	        sedopt_inplace='-i.sip'
	        opt_new=$1
            shift
            ;;
        k|keepscript)
            opt_keepscript=1
            ;;
        --) break ;; ## VITAL!!! Exits the while loop, no more options,
                     ## remaining $*, if any, are args
        *)
            cmd-echo -ec -- "$option is an invalid option. See $0 --help"
            exit 1
            ;;
    esac
done

if ((opt_keepscript==0))
then
    trap finish EXIT SIGINT
else
    print The sed command script is "$sedcmdfile"
fi

## process args
for arg in "$@"
do
    ## Need -e and -f. -e makes it a file system object. -f alone
    ## could confuse a directory with a sed command.
    ## Pathological? Yes. But that's how I roll.
    if [ -e "$arg" ] && [ -f "$arg" ]
    then
	    files+=("$arg")
    else
        ### TODO - NEED A WAY TO GET ARGS WITH SPACES IN HERE!!!!!!!!
	    echo "$arg" >> "$sedcmdfile"
    fi
done

if [ $opt_verbose = 1 ]
then
    cmd-echo -- "Processing these files: ${files[*]}"
fi

sedopts="$sedopt_inplace"
sed $sedopts -f "$sedcmdfile" "${files[@]}"
status=$?
if [ $status != 0 ]
then
    exitstatus=$status
    cmd-echo -- "Sed editor. Status $status." \
             "The directory where the files live must be writable" \
             "for sed's temporaries and the final product."
fi

for f in "${files[@]}"
do
    if [ -e "${f}.sip" ]
    then
	    diff --text "${f}.sip" "$f" 1>/tmp/sedinplace.diff.$$
	    status=$?
	    if [ $status = 0 ]
	    then
            if ((opt_verbose))
            then
		        cmd-echo -- "No changes in $f"
            fi
		    \rm "${f}.sip"
        elif ((opt_new))
        then
            \mv "${f}" "${f}.${opt_new}";status=$?;((status)) && cmd-echo -- "Rename ${f} ${f}.${opt_new} error. Exiting." && exit 1
            \mv "${f}.sip" "${f}";status=$?;((status)) && cmd-echo -- "Rename ${f}.sip ${f} error. Exiting." && exit 1
            ((opt_verbose)) && cmd-echo -- "${f}.${opt_new}"
        elif ((opt_confirm))
        then
            cmd-echo
            cmd-echo -- "diff --text ${f}.sip $f"
            cat /tmp/sedinplace.diff.$$
		    resp=$(yesno "Keep edits? ('n' reverts the edits)")
		    if [ "$resp" = 'n' ]
		    then
		        mv -v "${f}.sip" "$f"
		    else
		        \rm "${f}.sip"
	        fi
        fi
    fi
done

exit $exitstatus
