#!/usr/bin/env bash

# git-worktree

if ! git-version-verify 'git-worktree'
then
    exit 1
fi

## Global used to control 'cd'ing around
doandcdfile=''

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        echo "** Extended actions **"
        script-usage
        echo
        echo "** Standard actions **"
        "${REALGIT}" worktree --help
    ) 2>&1 | ${PAGER:-less}
}

_git_worktree_check_set_pwd ()
{
    local opt_current_ok=$1
    ## Make sure pwd ends in wt
    if [[ ! "$(pwd)" =~ /wt$ ]]
    then
        if [ -d ./wt ]
        then
            builtin cd ./wt || ( cmd-echo -- "Cannot cd ./wt" && return 1)
        elif [ -d ../../wt ] && ((opt_current_ok))
        then
            builtin cd .. || ( cmd-echo -- "Cannot cd .. (wt)" && return 1)
        else
            cmd-echo -- "Current directory is $(pwd)." \
                      'No wt subdir.' \
                      'Will not manipulate worktrees outside of wt dir. Aborting.'
            return 1
        fi
    fi
    return 0
}

_git_worktree_record_created_date ()
{
    git config --replace-all "worktree.$1.EMcreated" "$(date "$GIT_EXT_META_DATE_FMT")" || exit $?
}

# shellcheck disable=SC2120
git-worktree-ina ()
{
    status=1 ## Not in a worktree
    wtroot=$(git worktree get-root)
    if [ -n "$wtroot" ]
    then
        (
            while [ "$(pwd)" != "$wtroot" ]
            do
                if [ -f .git ] && grep -q '/worktrees/' .git
                then
                    if [ "$1" = '-v' ]
                    then
                        grep  '/worktrees/' .git | sed 's|.*worktrees/||'
                    fi
                    exit 0
                fi
            done
            exit 1
        )
        status=$?
    fi
    return $status
}

git-worktree-get-name ()
{
    git-worktree-ina -v
    return $?
}

git-worktree-cre ()
{
    git-worktree-create "$@"
}

git-worktree-create ()
{
    local fetch_existing=0
    local status=0
    local opt_m=''
    local message=''
    local asmaster='master'
    local remote=origin
    local localbranchname
    local pull_request=''
    local wtfullpath
    declare moreopts
    moreopts=1
    declare verbose
    verbose=1
    local opt_reset=1
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        ## Strip all leading dashes here so that -foo and --foo can both
        ## be processed as 'foo'.
        declare original="$1"
        declare option

        option=$(dashstripper "$original")
        shift ## That way you avoid endless loops on invalid options.

        case $option in
            pr | pull )
                pull_request="$1"; shift
                ## Not going to create a pull request via a worktree
                ## create, force a fetch.
                fetch_existing=1;;
            no-reset | skip-reset) opt_reset=0 ;;
            f|fetch) fetch_existing=1 ;;
            m|message) opt_m=$1; message="$1"; shift ;;
            asmaster) asmaster=$1; shift ;;
            h|help) usage; return 0 ;;
            r|remote) remote=$1; shift ;;
            orphan) echo "Sorry, cannot create orphans this way."
                    echo "First create the orphan, then create a"
                    echo "worktree for it using --fetch."
                    return "$NOOK"
                    ;;
            l|local) localbranchname=$1; shift;;
            --) moreopts=0 ;; ## end of opts, remaining $*, if any, are args
            *) usage "Error getting options!"; return 1 ;;
        esac
    done

    ! _git_worktree_check_set_pwd && return 1
    local wtroot
    wtroot="$(pwd)"

    declare repo
    repo="$(basename "$(dirname "$(pwd)")")" ## we are in /wt by now.

    local wtname="$1"
    shift
    if [ -z "${wtname}" ]
    then
        if [ -z "$pull_request" ]
        then
            usage "Need a branch name to use for the worktree spec."
            return 1
        else
            wtname="pull/$remote/$pull_request"
        fi
    else
        if [ -n "$pull_request" ]
        then
            usage "Cannot specify both a worktree-name and pull request id."
            return 1
        fi
    fi
    [ -z "$localbranchname" ] && localbranchname="${wtname}"

    ## If the requested branch is a pull request, do some work on the local
    ## branch name.
    if [[ "$localbranchname" =~ pull/ ]]
    then
        ## Swap all / for - to give us a usable name for the branch
        localbranchname=${localbranchname//\//-}
    fi

    ## Check remote. Must be fetchable and pushable.
    local exists
    exists=$(git remote -v | \
                 sort -u | \
                 perl -ane \
                      'BEGIN{$tgt=shift}print $F[2] if $F[0] eq $tgt' "$remote"
          )
    if [ ! "$exists" = '(fetch)(push)' ]
    then
        cmd-echo -- "Can't find remote '$remote' for fetch and push"
        git remote -v | while read -r line; do cmd-echo -- -c -- "$line"; done
        return 1
    fi
    cmd-echo -- "Using '$remote' as remote."

    ## Check worktree dir
    ((verbose)) && cmd-echo -- "Check for existing worktrees with same name."
    local wtdir
    wtdir="$(pwd)/$localbranchname"
    if [ -e "${wtdir}" ]
    then
        cmd-echo -- "${wtdir} already exists. Aborting."
        return 1
    fi

    ## Check for branch
    local wtsubdir=$localbranchname
    local wtbranch=$localbranchname

    ((verbose)) && cmd-echo -- "Check for existing branch."
    local create_branch="-b"

    ## Make sure we do not have a local branch with the same name
    git pull ## update with latest remote names.
    exists=$(git branch --list --format='%(refname)' | sed 's|.*/||' | \
                 while read -r line
                 do
                     if [ "$line" = "$localbranchname" ]
                     then
                         echo "$localbranchname"
                         break
                     fi
                 done
          )
    if [ -n "$exists" ]
    then
        if ((fetch_existing==1)) && [ -n "$exists" ]
        then
            cmd-echo -- "Branch $localbranchname already exists locally. Using it."
            if $REALGIT worktree add "$localbranchname" "$localbranchname"
            then
                ((verbose)) && cmd-echo -- "cd ${wtsubdir}"
                ## dirlist, not builtin cd, to take advantage this cd enhancement
                dirlist "$localbranchname"
            else
                return $?
            fi
        else
            cmd-echo -- "Branch $localbranchname already exists locally. Cannot create it."
            return 1
        fi
    else
        if [ -z "$pull_request" ]
        then
            ## Now see if branch exists remotely
            exists=$(git branch -r --list --format='%(refname)' | sed 's|refs/remotes/||' | \
                         while read -r line
                         do
                             if [ "$line" == "$remote/${wtname}" ]
                             then
                                 echo "$remote/${wtname}"
                                 break
                             fi
                         done
                  )
        else
            ## Find the pull
            exists=$(git show-ref | sed 's|.*refs/||' | grep pull/ | \
                         while read -r line
                         do
                             if [ "$line" == "${wtname}" ]
                             then
                                 echo "refs/${wtname}"
                                 break
                             fi
                         done
                  )
        fi

        ## Yes, I could nest conditions instead of repeating them. I prefer to
        ## be explicit here.
        if ((fetch_existing==1)) && [ -n "$exists" ]
        then
            ## Fetch it, Dear Henry...
            ##                               branch             path
            $REALGIT worktree add --track -b "$localbranchname" "$localbranchname" "$exists"
            status=$?
            if ((status))
            then
                cmd-echo -- "Aborting."
                return 1
            fi
            ((verbose)) && cmd-echo -- "cd ${wtsubdir}"

            ## dirlist, not builtin cd, to take advantage this cd enhancement
            dirlist "$localbranchname"
            _git_worktree_record_created_date "$localbranchname"
        elif ((fetch_existing==1)) && [ -z "$exists" ]
        then
            cmd-echo -- "Cannot find '$remote/${wtname}' to fetch"
            return 1
        elif ((fetch_existing==0)) && [ -n "$exists" ]
        then
            cmd-echo -- "Branch '${wtname}' already exists in remote '$remote'"
            return 1
        else ## ((fetch_existing==0)) && [ -z "$exists" ]
            ## Since this worktree is going to create a branch of the local
            ## $asmaster, make sure the local $asmaster (where we should be right
            ## now) it is up to date.
            if [ "$(git branch get-current)" != "$asmaster" ]
            then
                cmd-echo -- "Cannot create branch and worktree because the current branch '$(git branch get-current)' is not the master branch '$asmaster'."
                return 1
            fi
            cmd-echo -- "Checking local '$asmaster', starting point for branch."
            git pull
            status=$?
            ## We can return here with no other notice, assuming the error message
            ## from the pull would have been printed to stderr.
            ((status)) && return 1

            ## Let's practice a little hygiene here and keep the origin master up
            ## to date with the upstream master.

            #### - WARNING - This should only be used if the current repo is a
            #### - clone of YOUR FORK of a canonical repo. If you are working
            #### - in a CLONE of the CANONICAL, you do NOT want to do this. Now
            #### - that think we can tell the difference, we will cautiously do
            #### - this.
            local upstream
            upstream=$(git-is-a-fork -v)
            if [ -n "$upstream" ]
            then
                eval "$(git-parse-remote-v)"
                # shellcheck disable=SC2154
                cmd-echo -- \
                         "We think that the local repo" \
                         "    $(git-worktree-get-root)" \
                         "is a clone of the remote repo" \
                         "    ${gitfuncs_remotes[origin]}"\
                         "which is, in turn, a fork of" \
                         "    $(git-is-a-fork -v)" \
                         "meaning that we think we can safely execute" \
                         "    git push origin $asmaster"
                resp=$(cmd-yesno Ok n)
                if [ "$resp" = 'y' ]
                then
                    git push origin "$asmaster"
                else
                    cmd-echo -- "Skipping..."
                fi
            else
                cmd-echo -- \
                         "We think that the local repo" \
                         "    $(git-worktree-get-root)" \
                         "is a clone of the remote repo" \
                         "    ${gitfuncs_remotes[origin]}"\
                         "which is NOT a fork of any repo," \
                         "meaning that we WILL NOT BE executing" \
                         "    git push origin $asmaster"
            fi

            ## Now create the worktree and the branch.
            ((verbose)) && cmd-echo -- "$REALGIT worktree add -b ${wtsubdir} ${wtbranch}"
            $REALGIT worktree add $create_branch "${wtsubdir}" "${wtbranch}"
            status=$?
            if ((status))
            then
                cmd-echo -- "Aborting."
                return 1
            fi

            ((verbose)) && cmd-echo -- "cd ${wtsubdir}"
            ## dirlist, not builtin cd, to take advantage this cd enhancement
            dirlist "${wtsubdir}"
            wtfullpath=$(pwd)

            _git_worktree_record_created_date "${wtbranch}"

            ## Finally push the branch upstream as a tracking branch
            ((verbose)) && cmd-echo -- "git push --set-upstream $remote ${wtbranch}"
            git push --set-upstream "$remote" "${wtbranch}"
        fi
    fi
    ## Convert the worktree's .git file to use a relative path to the master
    ## .git location. In that way, we can use the repo on machines where it may
    ## be mounted in a different place, so that the absolute path is different
    ## in those places.
    sed -i 's|\(gitdir: \).*/\(.git/worktrees\)|\1../../\2|' .git

    git-post-new

    if [ -n "$opt_m" ]
    then
        git-st-ext "$message"
    fi

    ## Add this repo to the list
    if ((opt_reset))
    then
        cmd-echo -- "Resetting git list..."
        git-go-set
    else
        cmd-echo -- "--skip-reset. Run 'git-go-set' at some point."
    fi

    if [ -z "$doandcdfile" ]
    then
        cmd-echo -- \
                 "Done. Execute" \
                 "    git go $repo/wt/${wtsubdir}" \
                 "to use."
    else
        echo "go $wtfullpath" > "$doandcdfile"
        cmd-echo -n -- "Done. "
    fi

    return 0
}

git-worktree-delete ()
{
    local opt_yes=0
    local opt_yes_string
    local opt_force=0
    local opt_reset=1
    local opt_keep_branch=0
    local opt_current=0
    local wtname=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='yfhk'
    declare longopts='no-reset,skip-reset,yes,force,help,keep-branch,current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            current) opt_current=1; wtname="$(basename "$(pwd)")" ;;
            no-reset | skip-reset) opt_reset=0; ;;
            y|yes) opt_yes=1; opt_yes_string='--yes'; ;;
            f|force) opt_force=1; ;;
            h|help) usage; return 0 ;;
            k|keep-branch) opt_keep_branch=1 ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -e -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    if ((opt_force + opt_yes + opt_keep_branch > 1 ))
    then
        cmd-echo -- "--force, --keep-branch and --yes are mutex options"
        return 1
    fi

    ! _git_worktree_check_set_pwd $opt_current && return 1
    local wtroot
    wtroot="$(pwd)"

    if [ -z "$wtname" ]
    then
        wtname="$1"; shift
    elif [ -n "$1" ]
    then
        cmd-echo -- "Cannot specify a worktree and --current"
        return 1
    fi

    if [ -z "$wtname" ]
    then
        cmd-echo -- "Worktree not specified"
        return 1
    fi
    if [ ! -d "$wtname" ]
    then
        cmd-echo -- "Cannot find worktree $wtname
$(ls -la)"
        return 1
    fi
    local wtpath
    wtpath="$wtroot/$wtname"

    builtin cd "$wtpath" || ( cmd-echo -- "Cannot cd $wtpath" && return 1)

    ## Make sure we are in a proper worktree.
    if [ ! -f .git ]
    then
        cmd-echo -- "$wtname is not a proper worktree for deletion, missing '.git' file"
        return 1
    fi

    ## Check for cleanliness.
    if [ "$(git status --porcelain | wc -l)" != '0' ] || \
           [ "$(git status | grep 'Your branch is' | grep -c -v 'up.to.date')" != '0' ]
    then
        if((!opt_force))
        then
            git status
            echo
            cmd-echo -- "Will not delete unclean worktree. Clean worktree or re-run command with --force."
            return 1
        fi
    fi

    ## Current branch
    local current_branch
    current_branch=$(git branch get-current)

    ## Checking cleanliness and consistency
    local current_dir
    current_dir=$(basename "$(pwd)")
    if [ "$current_branch" != "$current_dir" ]
    then
        cmd-echo -- "Branch name '$current_branch' does not match current subdir name '$current_dir'." \
                    "I'm bailing; you fix this mess."
        return 1
    fi
    git status
    local rc=$?
    if ((rc))
    then
        cmd-echo -- "git status returned non-success value $rc." \
                    "I'm bailing; you fix this mess."
        return 1
    fi

    ## Whack it. Start with the current dir, which is the worktree.
    local delit
    delit=$(basename "$(pwd)")
    builtin cd .. || ( cmd-echo -- "Cannot cd .." && return 1)
    if ! rm -rf "$delit"
    then
        cmd-echo -- "Bad rm of ./$delit (from $(pwd)). Aborting."
        return 1;
    fi

    ## Work our way up to the first non empty dir or the 'wt' dir, whichever we
    ## get to first, and stop deleting.
    while [ "$(basename "$(pwd)")" != 'wt' ]
    do
        if [ -z "$(ls -A "$(pwd)")" ]
        then
            #it's empty
            delit=$(basename "$(pwd)")
            builtin cd .. || ( cmd-echo -- "Cannot cd .." && return 1)
            \rm -rf "$delit" || cmd-echo -- "Bad rm of ./$delit (from $(pwd)). Aborting." && return 1;
        fi
    done

    cmd-echo -- "Local repo deleted."

    ## Now fix the administrative files.
    $REALGIT worktree prune
    cmd-echo -- "Local admin files updated."

    ## Now the take care of the branch.
    if ((opt_yes))
    then
        resp='y'
    elif ((opt_keep_branch))
    then
        resp='n'
    else
        resp=$(cmd-yesno "Delete associated branch $current_branch" 'n')
    fi
    if [ "$resp" = 'n' ]
    then
        cmd-echo -- "If you change your mind: git-branch delete $current_branch"
    else
        ## Have to be in the git repo that the basis for the worktree.
        while [ "$(basename "$(pwd)")" != 'wt' ]
        do
            builtin cd .. || ( cmd-echo -- "Cannot cd .." && return 1)
        done
        builtin cd .. || ( cmd-echo -- "Cannot cd .." && return 1)
        if [ "$resp" = 'y' ]
        then
            git-branch delete --no-go-set $opt_yes_string "$current_branch"
        fi
    fi

    if ((opt_reset))
    then
        cmd-echo -- "Resetting git list..."
        git-go-set
    else
        cmd-echo -- "--skip-reset. Run 'git-go-set' at some point."
    fi

    [ -n "$doandcdfile" ] && echo "go $wtroot" > "$doandcdfile"

    cmd-echo -- "Done."

    return 0
}

git-worktree-del ()
{
    git-worktree-delete "$@"
}

git-worktree-rename ()
{
    declare moreopts
    moreopts=1
    local opt_reset=1
    local opt_current=0
    local old_wtname=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='h'
    declare longopts='no-reset,skip-reset,help,current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            current) opt_current=1; old_wtname="$(basename "$(pwd)")" ;;
            no-reset | skip-reset) opt_reset=0;;
            h|help) usage; return 0 ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -e -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    if (( $# == 0 )) || ( (( $# == 1 )) && [ -z "$wtname" ] )
    then
        usage "Missing arguments"
        return 1
    fi

    if (( $# > 2 ))  || ( (( $# == 2 )) && [ -n "$wtname" ] )
    then
        usage "Too many arguments"
        return 1
    fi

    local status

    ! _git_worktree_check_set_pwd $opt_current && return 1
    local wtroot
    wtroot="$(pwd)"

    if [ -z "$old_wtname" ]
    then
        old_wtname="$1"
        shift
    fi

    if [ ! -d "$old_wtname" ]
    then
        cmd-echo -- "Cannot find worktree $old_wtname
$(ls -la)"
        return 1
    fi
    local old_wtpath="$wtroot/$old_wtname"

    local new_wtname="$1" ; shift
    if [ -d "$new_wtname" ]
    then
        cmd-echo -- "Will not overwrite existing worktree $new_wtname
$(ls -la)"
        return 1
    fi
    local new_wtpath="$wtroot/$new_wtname"

    builtin cd "$old_wtpath" || ( cmd-echo -- "Cannot cd $old_wtpath" && return 1)
    local cb
    cb="$(git branch get-current)"
    if [ "$cb" = "$old_wtname" ]
    then
        cmd-echo -- "Renaming the branch..."
        git-branch rename "$old_wtname" "$new_wtname"
        status=$?
        if ((status != OK))
        then
            return 1
        fi
    fi

    cmd-echo -- "Updating metadata..."
    ## Get the metadata directory for this worktree
    local metadatadir
    metadatadir="$(grep -E '^gitdir:' .git | sed 's/.* //')"

    ## Get the metadata files for this worktree
    local heregit
    heregit=$(pwd)/.git
    local theregit
    theregit=${metadatadir}/gitdir

    ## Change the metadata files
    perl -pi -e "s/$old_wtname/$new_wtname/g" "$heregit" "$theregit" \
        || return 1

    ## Move the metadata dir
    local newmetadatadir
    newmetadatadir="$(dirname "$metadatadir")/$new_wtname"
    mv "$metadatadir" "$newmetadatadir" || return 1

    cmd-echo -- "Moving the local files..."
    ## Move us
    builtin cd .. || ( cmd-echo -- "Cannot cd .." && return 1)
    mv "$old_wtpath" "$new_wtpath" || return 1

    ## Register the rename
    if ((opt_reset))
    then
        cmd-echo -- "Resetting git list..."
        git-go-set
    else
        cmd-echo -- "--skip-reset. Run 'git-go-set' at some point."
    fi

    cmd-echo -- "Done."

    return $?
}

git-worktree-diff-to-root ()
{
    # shellcheck disable=SC2119
    if ! git-worktree-ina
    then
        cmd-echo -- "Must be in a wt"
        return 1;
    fi

    declare moreopts
    moreopts=1
    declare opt_reverse
    opt_reverse=0
    declare opt_color
    opt_color='always'
    declare -a diff_opts
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        ## Strip all leading dashes here so that -foo and --foo can both
        ## be processed as 'foo'.
        declare original="$1"
        declare option
        option=$(dashstripper "$original")
        shift ## That way you avoid endless loops on invalid options.

        case $option in
            reverse   ) opt_reverse=1 ;;
            color     ) opt_color=$1; shift ;;
            w         ) diff_opts+=('-w') ;; ## note: where are the other opts set?????
            help      ) echo "No documentation yet. Sorry."; return 0 ;;
            debug | x ) set -x ;;
            --        ) moreopts=0 ;;
            *         ) echo "$original is an invalid option. See $0 --help"; return 1;;
        esac
    done

    declare -a files=("$@")
    if ((${#files[@]}==0))
    then
        mapfile -t files < <(git ls-files)
        if ((${#files[@]}==0))
        then
            cmd-echo -- "No git files found. Is current dir '$(pwd)' a git repo?"
            return 1;
        fi
    fi

    declare root
    root=$(pwd);
    root=${root%%/wt*}
    [ -t "$STDOUT" ] && opt_color=never ## No color if output redirected to a file.
    for i in "${files[@]}"
    do
        declare -a comp=("${root}/$i" "$i")
        if ((opt_reverse))
        then
            comp=("$i" "${root}/$i")
        fi
        git --no-pager diff --no-index --color=$opt_color "${diff_opts[@]}" "${comp[@]}" 2>&1
    done | less -RE
}

git-worktree-diff-from-root ()
{
    git-worktree-diff-to-root --reverse "$@"
    return $?
}

git-worktree-get-root ()
{
    local i
    local status=0
    local wtr
    wtr=$($REALGIT worktree list | \
              grep '\[master\]' | \
              sed -E 's/\s+[0-9a-z ]+\[master\]//')
    for i in "${PIPESTATUS[@]}"
    do
        ((i>status)) && status=$i
    done
    ((status)) && return "$status"
    if [ -n "${wtr}" ]
    then
        echo "${wtr}"
        return 0
    else
        echo
        return 1
    fi
}

git-worktree-mm ()
{
    git-worktree-mark-merged "$@"
}

git-worktree-mark-merged ()
{
    # shellcheck disable=SC2119
    if ! git-worktree-ina
    then
        cmd-echo -- "Must be in a worktree"
        return 1;
    fi

    local worktreename
    worktreename="$(basename "$(pwd)")"
    local worktreekey="worktree.$worktreename.em-markedmerged"

    local branchname
    branchname="$(git branch get-current)"
    local branchkey="branch.$branchname.em-markedmerged"

    local markdate
    markdate="$(date "$GIT_EXT_META_DATE_FMT")"

    git config --replace-all "$worktreekey" "$markdate" || exit $?
    git config --replace-all "$branchkey" "$markdate" || exit $?

    cmd-echo "Worktree $worktreename, branch $branchname marked merged at $markdate"
}

git-worktree-comment ()
{
    # shellcheck disable=SC2119
    if ! git-worktree-ina
    then
        cmd-echo -- "Must be in a worktree"
        return 1;
    fi
    if [[ $1 =~ -(show|get) ]]
    then
        git comment --get --worktree
    else
        git comment --branch --worktree "$@"
    fi
}

main ()
{
    declare action=$1

    if [[ "$action" =~ ^-+h ]]
    then
        usage
        return  0
    fi

    if [[ "$action" =~ --doandcd ]]
    then
        doandcdfile=$2
        shift; shift;
        action=$1
    fi

    action_func_name="git-worktree-${action}"
    if declare -F "$action_func_name" >/dev/null
    then
        shift ## the $action
        "$action_func_name" "$@"
    else
        case $action in
            add | list | lock | move | prune | remove | unlock )
                ## Dispatch to real git worktree
                "${REALGIT}" worktree "$@"
                ;;
            * )
                usage "Error: unknown git worktree action '$action'"
                return 1
                ;;
        esac
    fi
    return $?
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-worktree - git extention of git worktree

=head1 SYNOPSIS

 git-worktree create
 git-worktree delete [--current]
 git-worktree rename [--current]

 git-worktree get-root
 git-worktree diff-from-root
 git-worktree diff-to-root
 git-worktree ina
 git-worktree get-name
 git-worktree mark-merged|mm
 git-worktree comment

=head1 DESCRIPTION

Extensions to the 'git worktree' command that understand and enforce our
worktree conventions. To wit:

o We do development on feature branches, using a clone of a forked repo.

o We create a worktree for each feature branch.

o We locate the worktree in the 'wt' subdir of the corresponding repo.

o We add the worktree location to the list of repos reachable by the 'git go'
  command.

We now have a consistent environment to execute multiple lines of development
in a given repo without the need to constantly checkout branches over and over
into the same repo location.

Any action not described here will be passed onto the actual 'git worktree'
command.

All extentions take a -h or --help option to display this manpage.

=head1 EXTENSIONS

=over 4

=item create

A synonymn for 'add' but one that respects our conventions.

For branches:

 git worktree cre[ate] [-f] [-r remote] [-m 'message'] [--asmaster somebranch] [-l localbranchname] worktree-name
       -f|--fetch
           - Do not create the branch, but fetch an existing branch.
       -r|--remote
           - Use 'remote' as the source; the default is 'origin'.
       -m|--message
           - Record a short description readable with git-st-ext.
       --asmaster
           - use 'somebranch' as the worktree basis. The default is 'master'.
       -l localbranchname
           - When fetching an existing remote branch 'X', use 'localbranchname'
             as the tracking branch name instead of 'X'. Most useful if you are
             fetching someone else's 'master' branch.
       worktree-name
           - the name of the branch and worktree to create

For pull requests:

 git worktree cre[ate] [-r remote] [-m 'message'] [-l localbranchname] --pull ID
       -r|--remote
           - Use 'remote' as the source; the default is 'origin'.
       -m|--message
           - Record a short description readable with git-st-ext.
       -l  localbranchname
           - When fetching an existing pull request 'ID', use 'localbranchname'
             as the tracking branch name instead of pull-<remote>-<ID>.
       --pull ID
           - The pull request #

Note that there is not worktree-name argument. Unless overriden withe the '-l'
flag, the worktree name will be 'pull-<remote>-<ID>'.

=item delete

A synonymn 'remove' but one that respects our conventions.

 git worktree delete [-y] [-f] [--current | worktree-name ]
       -y|--yes     - Assume 'yes' to all prompts
       -f|--force   - Delete even if the repo is not 'clean'
       --current    - delete the worktree that is the current directory.
                      Otherwise, the current directory should be 'wt/'
                      and specify the worktree sub directory to delete.

=item rename

Changes the worktree name and the corresponding directory and branch.

 git worktree rename [--current | current-worktree-name] new-worktree-name
       --current    - rename the worktree that is the current directory.
                      Otherwise, the current directory should be 'wt/'
                      and specify the worktree sub directory to rename.


=item get-root

Get the root directory for the current worktree.

 git worktree get-root

=item diff-to-root

Perform a diff betweeen the master branch and the current worktree for a given
set of files or all the git-known files in the current worktree.

 git worktree diff-to-root [--reverse] [--color] [-w]
       --reverse - Perform the diff in the reverse order, i.e, betweeen the
                   current worktree and the master branch.
       --color   - Common git color options: always, never, or auto.
       -w        - Perform the diff ignoring whitespace.

=item diff-from-root

Perform a diff betweeen the current worktree and the master branch for a given
set of files or all the git-known files in the current worktree. A synonymn for

 git worktree diff-to-root --reverse

=item ina

Is the current working directory in a worktree? Adding the -p option will print
the worktree root.

<B>Note</B>: This is NOT the same as <C>git rev-parse --in-a-work-tree</C>.
That command tells you if you are in a working tree (with code) as opposed to a
bare repo (no code). Our command tells you if you are in a directory created
with 'git worktree'.

=item get-name

If the current working directory is in a worktree, print the name of the
worktree and exit 0. Otherwise print nothing and exit non-0. Really, this is a
synonym for <C>get worktree ina -v</C>.

=item mark-merged

Write configs 'worktree.<worktreename>.em-markmerged' and
'branch.<branchname>.em-markmerged' as the current date and time. Use this if
the worktree has been merged and can be deleted by some periodic sweep process.

=item comment

Add a comment that can be retrieved later. The current time is added to the end
of the comment when written.

 git worktree comment "some text explaining where you left off, maybe?"
 git worktree comment -[get|show]

=back


=cut

__PODUSAGE__
