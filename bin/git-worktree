#!/usr/bin/env bash

# git-worktree

if ! git-version-verify 'git-worktree'; then
    exit 1
fi

## Global used to control 'cd'ing around
doandcdfile=''

_git_worktree_check_set_pwd ()
{
    local action=$1
    local opt_current_ok=$2
    local cwd="${PWD}"

    ## Make sure pwd is the wt subdir or under that.
    if [[ ! $cwd =~ /wt ]]; then
        cwd="${cwd}/wt"
        if [[ -d ${cwd} ]]; then
            builtin cd "$cwd" || { cmd-echo -- "Cannot cd $cwd"; false; return $?; }
        else
            cmd-echo --ec -- "Current directory is ${cwd}." \
                     'No wt path component found.' \
                     'Will not manipulate worktrees outside of wt dir. Aborting.'
            false; return $?
        fi
    fi

    ## Yes you have to do this twice: once for when there's anything after the
    ## wt and once for when there's not.
    declare wtroot="${cwd%%/wt/*}"
    wtroot="${wtroot%%/wt}/wt"

    ## Make sure we don't process ourselves unless --current flag is thrown
    local newwd="${PWD}"
    while [[ $newwd != "$wtroot" ]]; do
        if [[ -f $newwd/.git ]]; then
            if ((opt_current_ok!=1)); then
                cmd-echo --ec -- "Will not $action current worktree without -c flag"
                false; return $?
            fi
        fi
        newwd=$(dirname "$newwd")
    done

    ## Go to root so we can start working
    builtin cd "$wtroot" || { cmd-echo -- "Cannot cd $wtroot"; false; return $?; }

    true; return $?
}

_git_worktree_info_remove ()
{
    ## There is no git-sanctioned worktree section. It's all us, so we have to
    ## manage it. The 'branch' stuff we add will be taken care of when the
    ## branch is deleted.
    git config --remove-section "worktree.$1" || return $?
}

_git_worktree_info_add_created_date ()
{
    declare cr
    cr="$(date "$GIT_EXT_META_DATE_FMT")"
    declare key
    for key in 'worktree' 'branch'; do
        git config --replace-all "$key.$1.${GIT_EXT_META_PREFIX}-created" "$cr" || return $?
    done
}

_git_worktree_info_add_fetched_date ()
{
    git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-fetched" "$(date "$GIT_EXT_META_DATE_FMT")" || return $?
}

_git_worktree_info_add_spec_ref ()
{
    # shellcheck disable=SC2155 #https://github.com/koalaman/shellcheck/wiki/SC2155
    declare resp=$(prompt "Specification (issue, JIRA, etc) reference(return for none):")
    if [[ -n $resp ]]; then
        git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-spec-ref" "$resp"
    fi
}

_git_worktree_was_fetched ()
{
    [[ -n $(git config --get "^worktree.$1.${GIT_EXT_META_PREFIX}-fetched" 2>/dev/null) ]]
}

_git_worktree_is_a_pull ()
{
    [[ $(git repo current-branch) =~ ^pull ]]
}

_git_worktree_info_add_from_branch_and_ref ()
{
    ## TODO: Check that basename works in all conditions. Probably not when the
    ## from branch has a / in it, as in Berg at Bloomberg.
    git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-from-ref" "$2"
    git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-from-branch" "$(basename "$2")"
    git config --replace-all "branch.$1.${GIT_EXT_META_PREFIX}-from-ref" "$2"
    git config --replace-all "branch.$1.${GIT_EXT_META_PREFIX}-from-branch" "$(basename "$2")"
}

_git_worktree_name_from_path ()
{
    local path=$1
    path="${path##*wt/}"
    local -a tmp
    asplit "$path" -s / -a tmp
    ajoin path -s / "${tmp[@]}"
    echo "$path"
}

# shellcheck disable=SC2120
git-worktree-ina ()
{
    declare status=1 ## Not in a worktree
    declare git_root
    if git_root=$(git root 2>/dev/null); then
        ## We are at least in a git repo
        declare git_meta="${git_root}/.git"
        if [ -f "$git_meta" ] && grep -q '/worktrees/' "$git_meta"; then
            ## Then the repo root has a .git file with a worktree statement in
            ## it. Therefore we are in a worktree.
            status=0
            if [ "$1" = '-v' ]; then
                grep  '/worktrees/' "$git_meta" | sed 's|.*worktrees/||'
            fi
        fi
    fi
    return $status
}

git-worktree-get-name ()
{
    git-worktree-ina -v
    return $?
}
git-worktree-get-source-branch ()
{
    declare current_branch
    current_branch=$(git repo current-branch)
    git config --get "worktree.${current_branch}.${GIT_EXT_META_PREFIX}-from-branch"
    return $?
}

git-worktree-create ()
{
    local fetch_existing=0
    local status=0
    local comment=''
    local branch_from
    local branch_from_arg
    local remote=origin
    local localbranchname
    local pull_request=''
    local wtfullpath
    declare moreopts
    moreopts=1
    declare verbose
    verbose=1
    local opt_reset=1
    while [[ "$1" =~ ^- ]] && ((moreopts)); do
        ## Strip all leading dashes here so that -foo and --foo can both
        ## be processed as 'foo'.
        declare original="$1"
        declare option

        option=$(dashstripper "$original")
        shift ## That way you avoid endless loops on invalid options.

        case $option in
            pr | pull )
                pull_request="$1"; shift
                ## Not going to create a pull request via a worktree.
                ## Rather create, force a fetch.
                fetch_existing=1;;
            no-reset | skip-reset) opt_reset=0 ;;
            f|fetch) fetch_existing=1 ;;
            c|comment) comment="$1"; shift ;;
            from | from-branch | branch-from)
                branch_from=$1; shift
                branch_from_arg="$option"
                ;;
            h|help) git-usage "$0"; return 0 ;;
            r|remote) remote=$1; shift ;;
            orphan) echo "Sorry, cannot create orphans this way."
                    echo "First create the orphan, then create a"
                    echo "worktree for it using --fetch."
                    return "$NOOK"
                    ;;
            l|local) localbranchname=$1; shift;;
            --) moreopts=0 ;; ## end of opts, remaining $*, if any, are args
            *) git-usage "$0" "Error getting options!"; return 1 ;;
        esac
    done

    ## Make sure we are in the right place to start making the work tree.
    ! _git_worktree_check_set_pwd create && return 1

    ## Update repo with latest remote info.
    declare -a git_remotes
    readarray -t git_remotes < <(git remote)
    for i in "${git_remotes[@]}"; do git fetch "$i"; git pull; done

    ## Start making the wt dir
    local wtroot
    wtroot="${PWD}"
    declare repo
    repo="$(basename "$(dirname "${PWD}")")" ## We are in /wt when we do this.
    local wtname="$1"
    shift
    if git repo named-branches && \
            [[ ! $(dirname "$wtname") == "$USER" ]] ; then
        cmd-echo -- "This repo is using named branches."
        local resp
        resp=$(yesno "Use $USER/$wtname" y)
        [[ $resp == 'y' ]] && wtname="$USER/$wtname"
    fi
    echo "$wtname"
    local pull_ref
    if [ -z "${wtname}" ]; then
        if [ -z "$pull_request" ]; then
            git-usage "$0" "Need a branch name to use for the worktree spec."
            return 1
        else
            pull_ref="pull/$pull_request/head"
            wtname="pull-$remote-$pull_request"
        fi
    else
        if [ -n "$pull_request" ]; then
            git-usage "$0" "Cannot specify both a worktree-name and pull request id."
            return 1
        fi
    fi
    [ -z "$localbranchname" ] && localbranchname="${wtname}"

    ## Check remote. Must be fetchable and pushable.
    local exists
    exists=$(git remote -v | \
                 sort -u | \
                 perl -ane \
                      'BEGIN{$tgt=shift}print $F[2] if $F[0] eq $tgt' "$remote"
          )
    if [ ! "$exists" = '(fetch)(push)' ]; then
        cmd-echo -- "Can't find remote '$remote' for fetch and push"
        git remote -v | while read -r line; do cmd-echo -- -c -- "$line"; done
        return 1
    fi
    cmd-echo -- "Using '$remote' as remote."

    ## Check worktree dir
    ((verbose)) && cmd-echo -- "Check for existing worktrees with same name."
    local wtdir
    wtdir="${PWD}/$localbranchname"
    if [ -e "${wtdir}" ]; then
        cmd-echo -- "${wtdir} already exists. Aborting."
        return 1
    fi

    ## Check for branch
    local wtsubdir=$localbranchname
    local wtbranch=$localbranchname

    ((verbose)) && cmd-echo -- "Check for existing branch."

    ## Make sure we do not have a local branch with the same name
    exists=$(git branch --list --format='%(refname)' | sed 's|.*/||' | \
                 while read -r line; do
                     if [ "$line" = "$localbranchname" ]; then
                         echo "$localbranchname"
                         break
                     fi
                 done
          )
    if [ -n "$exists" ]; then
        if ((fetch_existing==1)) && [ -n "$exists" ]; then
            cmd-echo -- "Branch $localbranchname already exists locally. Using it."
            if $REALGIT worktree add "$localbranchname" "$localbranchname"; then
                ((verbose)) && cmd-echo -- "cd ${wtsubdir}"
                ## dirlist, not builtin cd, to take advantage this cd enhancement
                dirlist "$localbranchname"
                wtfullpath=${PWD}
                cmd-echo -dc -- "set wtfullpath to ${wtfullpath} at line $((LINENO-1)) in $0, func ${FUNCNAME[0]}"
            else
                return $?
            fi
        else
            cmd-echo -- "Branch $localbranchname already exists locally. Cannot create it."
            return 1
        fi
    else
        if [ -z "$pull_request" ]; then
            ## Now see if branch exists remotely
            exists=$(git branch -r --list --format='%(refname)' | sed 's|refs/remotes/||' | \
                         while read -r line; do
                             if [ "$line" == "$remote/${wtname}" ]; then
                                 echo "$remote/${wtname}"
                                 break
                             fi
                         done
                  )
        else
            ## Here, the existence check also fetches and creates the branch,
            ## so we don't need to do that below.
            exists="$localbranchname"
            if ! git fetch "$remote" "$pull_ref:$localbranchname"; then
                cmd-echo -ec -- "Pull $pull_ref not found in $remote"
                return 1
            fi
        fi

        ## Yes, I could nest conditions instead of repeating them. I prefer to
        ## be explicit here.
        if ((fetch_existing==1)) && [ -z "$exists" ]; then
            cmd-echo -- "Cannot find '$remote/${wtname}' to fetch"
            return 1
        elif ((fetch_existing==0)) && [ -n "$exists" ]; then
            cmd-echo -- "Branch '${wtname}' already exists in remote '$remote'"
            return 1
        elif ((fetch_existing==1)) && [ -n "$exists" ]; then
            ## Fetch it, Dear Henry...
            declare -a wtargs
            if [[ -z "$pull_request" ]]; then
                wtargs=('--track' '-b' "$localbranchname" )
            else
                cmd-echo -wc -- \
                         "Pulling a PR directly will leave you with a branch" \
                         "that will not track the remote PR, and, therefore cannot be" \
                         "'git pull'ed to update it. " \
                         "" \
                         "If you think you're going to want to push new" \
                         "commits to the PR, or that you're going to have to" \
                         "pull updates to local copy of the PR, then you're" \
                         "probably better off cloning the repo where the PR" \
                         "originated, checking out the source branch of the" \
                         "PR, and working with that."
            fi
            $REALGIT worktree add "${wtargs[@]}" "$localbranchname" "$exists"
            status=$?
            if ((status)); then
                cmd-echo -- "Aborting."
                return 1
            fi
            declare respdbg
            respdbg=$(yesno "Continue" "n")
            [[ $respdbg == 'n' ]] && exit
            ((verbose)) && cmd-echo -- "cd ${wtsubdir}"
            ## dirlist, not builtin cd, to take advantage this cd enhancement
            dirlist "${wtsubdir}"
            wtfullpath=${PWD}
            cmd-echo -dc -- "set wtfullpath to ${wtfullpath} at line $((LINENO-1)) in $0, func ${FUNCNAME[0]}"

            _git_worktree_info_add_fetched_date "$localbranchname"
        else ## ((fetch_existing==0)) && [ -z "$exists" ]
            declare -a branch_from_ref
            if [[ -n $branch_from ]]; then
                ## $branch_from is the branch name. We need the full branch ref
                ## here. Get it and check it.
                declare -a all_refs=(git branch -a)
                readarray -t branch_from_ref < <(git branch -a | grep -e "upstream/${branch_from}$" | sed -E 's/^\s+//')
                case ${#branch_from_ref[@]} in
                    0 ) cmd-echo --ec -- "Branch '$branch_from' not found in refs list:" "${all_refs[@]}" "Aborting"
                        return 1;;
                    1 ) # Set up "triangle workflow'.Only need the branch
                        # specific pieces. The rest of it was set up when the
                        # fork was cloned.
                        declare -A triangle_workflow
                        triangle_workflow[branch.${branch_from}.merge]="refs/heads/${branch_from}"
                        triangle_workflow[branch.${branch_from}.mergeoptions]="--ff-only"
                        triangle_workflow[branch.${branch_from}.remote]="upstream"
                        for key in "${!triangle_workflow[@]}"; do
                            git config --replace-all "$key" "${triangle_workflow[$key]}" || return $?
                        done
                        ;;
                    * ) cmd-echo --ec -- "Branch '$branch_from' found more than once in refs list:" "${all_refs[@]}" \
                                 "Re-run and specify full reference for --$branch_from_arg"
                        return 1;;
                esac
            else
                branch_from_ref[0]="$(git-repo default-branch)"
            fi

            ## Now create the worktree and the branch.
            ((verbose)) && cmd-echo -- "$REALGIT worktree add -b ${wtsubdir} ${wtbranch} ${branch_from_ref[0]}"
            $REALGIT worktree add -b "${wtsubdir}" "${wtbranch}" "${branch_from_ref[0]}"
            status=$?
            if ((status)); then
                cmd-echo -- "Aborting."
                return 1
            fi

            ((verbose)) && cmd-echo -- "cd ${wtsubdir}"
            ## dirlist, not builtin cd, to take advantage this cd enhancement
            dirlist "${wtsubdir}"
            wtfullpath=${PWD}
            ## cmd-echo -dc -- "set wtfullpath to ${wtfullpath} at line $((LINENO-1)) in $0, func ${FUNCNAME[0]}"

            _git_worktree_info_add_created_date "${wtbranch}"
            _git_worktree_info_add_from_branch_and_ref "${wtbranch}" "${branch_from_ref[0]}"
            _git_worktree_info_add_spec_ref "${wtbranch}"
            ## Finally push the branch up as a tracking branch
            ((verbose)) && cmd-echo -- "git push --set-upstream $remote ${wtbranch}"
            git push --set-upstream "$remote" "${wtbranch}"
        fi
    fi

    ## Convert the worktree's .git file to use a relative path to the default
    ## .git location. In that way, we can use the repo on machines where it may
    ## be mounted in a different place, so that the absolute path is different
    ## in those places.
    declare wtroot
    wtroot=$(pwd)
    declare -a relative_path_parts
    relative_path_parts=()
    while [[ $wtroot != '/' ]] && [[ $(basename "$wtroot") != 'wt' ]]; do
        relative_path_parts+=('..')
        wtroot=$(dirname "$wtroot");
    done
    if [[ $wtroot == '/' ]]; then
        cmd-echo --wc -- "Cannot find a 'wt' parent dir; not making relative worktree .git entry"
    else
        relative_path_parts+=('..')
    fi
    declare relative_path_part
    ajoin relative_path_part -s '/' "${relative_path_parts[@]}"
    sed -i 's|\(gitdir: \).*/\(.git/worktrees\)|\1'"${relative_path_part}"'/\2|' .git

    git-post-new

    [[ -n $comment ]] && git-worktree-comment "$comment"

    ## Add this repo to the list
    if ((opt_reset)); then
        cmd-echo -- "Resetting git list..."
        git-go-set
    else
        cmd-echo -- "--skip-reset. Run 'git-go-set' at some point."
    fi

    ## Show some info
    cmd-echo -- "Branch and worktree metadata..."
    git-repo info --no-pulls

    ## Deal with the cd shenanigans
    if [ -z "$doandcdfile" ]; then
        cmd-echo -- \
                 "Done. Execute" \
                 "    git go $repo/wt/${wtsubdir}" \
                 "to use."
    else
        ## cmd-echo -dc -- "writting wtfullpath '$wtfullpath' into '$doandcdfile' at line $((LINENO+1)) in $0, func ${FUNCNAME[0]}"
        echo "go $wtfullpath" > "$doandcdfile"
        cmd-echo -n -- "Done. "
    fi

    return 0
}

git-worktree-delete ()
{
    local opt_yes=0
    local opt_yes_string
    local opt_force=0
    local opt_reset=1
    local opt_keep_branch=0
    local opt_current=0
    local wtname=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='yfhkc'
    declare longopts='no-reset,skip-reset,yes,force,help,keep-branch,current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true; do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            c | current) opt_current=1; wtname="$(_git_worktree_name_from_path "${PWD}")" ;;
            no-reset | skip-reset) opt_reset=0; ;;
            y|yes) opt_yes=1; opt_yes_string='--yes'; ;;
            f|force) opt_force=1; ;;
            h|help) git-usage "$0"; return 0 ;;
            k|keep-branch) opt_keep_branch=1 ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -ec -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    if ((opt_force + opt_yes + opt_keep_branch > 1 )); then
        cmd-echo -- "--force, --keep-branch and --yes are mutex options"
        return 1
    fi

    ! _git_worktree_check_set_pwd delete $opt_current && return 1
    local wtroot
    wtroot="${PWD}"

    if [ -z "$wtname" ]; then
        wtname="$1"; shift
    elif [ -n "$1" ]; then
        cmd-echo -- "Cannot specify a worktree and --current"
        return 1
    fi

    if [ -z "$wtname" ]; then
        cmd-echo -- "Worktree not specified"
        return 1
    fi
    if [ ! -d "$wtname" ]; then
        cmd-echo -- "Cannot find worktree $wtname
$(ls -la)"
        return 1
    fi
    local wtpath
    wtpath="$wtroot/$wtname"

    builtin cd "$wtpath" || { cmd-echo -- "Cannot cd $wtpath"; false; return $?; }

    ## Make sure we are in a proper worktree.
    if ! git-worktree-ina; then
        cmd-echo -- "$wtname is not a proper worktree for deletion"
        false; return $?
    fi

    ## Check for cleanliness.
    if [ "$(git status --porcelain | wc -l)" != '0' ] || \
           [ "$(git status | grep 'Your branch is' | grep -c -v 'up.to.date')" != '0' ]; then
        if((!opt_force)); then
            git status
            echo
            cmd-echo --ec -- "Will not delete unclean worktree. Clean worktree or re-run command with --force."
            false; return $?
        fi
    fi

    ## Current branch
    local current_branch
    current_branch=$(git repo current-branch)

    ## Checking cleanliness and consistency
    local current_branch_dir
    current_branch_dir=$(_git_worktree_name_from_path "${PWD}")
    if [ "$current_branch" != "$current_branch_dir" ]; then
        cmd-echo -- "Branch name '$current_branch' does not match current subdir name '$current_branch_dir'." \
                 "I'm bailing; you fix this mess."
        return 1
    fi
    git status
    local rc=$?
    if ((rc)); then
        cmd-echo -- "git status returned non-success value $rc." \
                    "I'm bailing; you fix this mess."
        return 1
    fi

    ## Whack it. Start with the current dir, which is the worktree.
    local delit
    delit=$(basename "${PWD}")
    builtin cd .. || { cmd-echo -- "Cannot cd .." && return 1; }
    if ! rm -rf "$delit"; then
        cmd-echo -- "Bad rm of ./$delit (from ${PWD}). Aborting."
        return 1;
    fi

    ## Work our way up to the first non empty dir or the 'wt' dir, whichever we
    ## get to first, and stop deleting.
    while [ "$(basename "${PWD}")" != 'wt' ]; do
        if [ -z "$(ls -A "${PWD}")" ]; then
            #it's empty
            delit=$(basename "${PWD}")
            builtin cd .. || { cmd-echo -- "Cannot cd .." && return 1; }
            \rm -rf "$delit" || { cmd-echo -- "Bad rm of ./$delit (from ${PWD}). Aborting." && return 1; }
        fi
    done

    cmd-echo -- "Local repo deleted."

    ## Now fix the administrative files.
    $REALGIT worktree prune

    # Hold onto some info..
    declare was_fetched
    was_fetched=$(_git_worktree_was_fetched "$current_branch"; echo $?)

    ## ...before we trash the metadata
    _git_worktree_info_remove "$current_branch"
    cmd-echo -- "Local admin files updated."

    ## Now the take care of the branch.
    if ((opt_yes)); then
        resp='y'
    elif ((opt_keep_branch)); then
        resp='n'
    else
        if [[ $was_fetched == "$(true; echo $?)" ]]; then
            cmd-echo -wc -- "This worktree's branch was fetched, not created. Be careful deleting the remote."
        fi
        resp=$(cmd-yesno "Delete associated branch $current_branch" 'n')
    fi
    if [ "$resp" = 'n' ]; then
        cmd-echo -- "If you change your mind: git-branch delete $current_branch"
    else
        ## Have to be in the git repo that the basis for the worktree.
        while [ "$(basename "${PWD}")" != 'wt' ]; do
            builtin cd .. || { cmd-echo -- "Cannot cd .." && return 1; }
        done
        builtin cd .. || { cmd-echo -- "Cannot cd .." && return 1; }
        if [ "$resp" = 'y' ]; then
            git-branch delete --no-go-set $opt_yes_string "$current_branch"
        fi
    fi

    ## Cleanup
    if ((opt_reset)); then
        cmd-echo -- "Resetting git list..."
        git-go-set
    else
        cmd-echo -- "--skip-reset. Run 'git-go-set' at some point."
    fi

    [ -n "$doandcdfile" ] && echo "go $wtroot" > "$doandcdfile"

    cmd-echo -- "Done."

    return 0
}

git-worktree-rename ()
{
    local opt_reset=1
    local opt_current=0
    local old_wtname=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='h'
    declare longopts='no-reset,skip-reset,help,current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true; do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            current) opt_current=1; old_wtname="$(_git_worktree_name_from_path "${PWD}")" ;;
            no-reset | skip-reset) opt_reset=0;;
            h|help) git-usage "$0"; return 0 ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -ec -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    # shellcheck disable=SC2030 #https://github.com/koalaman/shellcheck/wiki/SC2030
    if (( $# == 0 )) || ( (( $# == 1 )) && [[ -z "$old_wtname" ]] ); then
        git-usage "$0" "Missing arguments"
        return 1
    fi

    if (( $# > 2 )); then
        git-usage "$0" "Too many arguments"
        return 1
    fi

    local status

    ! _git_worktree_check_set_pwd rename $opt_current && return 1
    local wtroot
    wtroot="${PWD}"

    # shellcheck disable=SC2031 #https://github.com/koalaman/shellcheck/wiki/SC2031
    if [ -z "$old_wtname" ]; then
        old_wtname="$1"
        shift
    fi

    if [ ! -d "$old_wtname" ]; then
        cmd-echo -- "Cannot find worktree $old_wtname
$(ls -la)"
        return 1
    fi
    local old_wtpath="$wtroot/$old_wtname"

    local new_wtname="$1" ; shift
    if [ -d "$new_wtname" ]; then
        cmd-echo --ec -- "Will not overwrite existing worktree $new_wtname
$(ls -la)"
        return 1
    fi
    local new_wtpath="$wtroot/$new_wtname"
    builtin cd "$old_wtpath" || { cmd-echo -- "Cannot cd $old_wtpath" && return 1; }
    local cb
    cb="$(git repo current-branch)"
    if [ "$cb" = "$old_wtname" ]; then
        cmd-echo -- "Renaming the branch..."
        git-branch rename "$old_wtname" "$new_wtname"
        status=$?
        if ((status != OK)); then
            return 1
        fi
    fi

    cmd-echo -- "Updating metadata..."
    ## Get the metadata directory for this worktree
    local metadatadir
    metadatadir="$(grep -E '^gitdir:' .git | sed 's/.* //')"

    ## Get the metadata files for this worktree
    local heregit
    heregit=${PWD}/.git
    local theregit
    theregit=${metadatadir}/gitdir

    ## Change the metadata files
    perl -pi -e "s/$old_wtname/$new_wtname/g" "$heregit" "$theregit" \
        || return 1

    ## Move the metadata dir
    local newmetadatadir
    newmetadatadir="$(dirname "$metadatadir")/$new_wtname"
    mv "$metadatadir" "$newmetadatadir" || return 1

    cmd-echo -- "Moving the local files..."
    ## Move us
    builtin cd .. || { cmd-echo -- "Cannot cd .." && return 1; }
    mv "$old_wtpath" "$new_wtpath" || return 1

    ## Register the rename
    declare -a paths
    IFS='/' read -ra paths <<< "$new_wtpath"
    declare sliceindex=$((${#paths[@]} - 4 ))
    declare gitgoto
    gitgoto="$(printf "%s/" "${paths[@]:$sliceindex:3}")${paths[-1]}"
    if ((opt_reset)); then
        cmd-echo -- "Resetting git list..."
        git-go-set
        if ((opt_current)); then
            git go "$gitgoto"
        fi
    else
        cmd-echo -- "--skip-reset. Run 'git-go-set' at some point."
    fi

    if ((opt_current)); then
        if [ -z "$doandcdfile" ]; then
            cmd-echo -- \
                     "Done. Execute" \
                     "    git go $gitgoto" \
                     "to use."
        else
            echo "go $new_wtpath" > "$doandcdfile"
            cmd-echo -n -- "Done. "
        fi
    else
        cmd-echo -- "Done. "
    fi

    return 0
}

git-worktree-diff-to-root ()
{
    # shellcheck disable=SC2119
    if ! git-worktree-ina; then
        cmd-echo -- "Must be in a wt"
        return 1;
    fi

    declare moreopts
    moreopts=1
    declare opt_reverse
    opt_reverse=0
    declare opt_color
    opt_color='always'
    declare -a diff_opts
    while [[ "$1" =~ ^- ]] && ((moreopts)); do
        ## Strip all leading dashes here so that -foo and --foo can both
        ## be processed as 'foo'.
        declare original="$1"
        declare option
        option=$(dashstripper "$original")
        shift ## That way you avoid endless loops on invalid options.

        case $option in
            reverse     ) opt_reverse=1 ;;
            color       ) opt_color=$1; shift ;;
            w|name-only ) diff_opts+=("$option") ;;
            l           ) diff_opts+=('--name-only') ;;
            help        ) echo "No documentation yet. Sorry."; return 0 ;;
            debug | x   ) set -x ;;
            --          ) moreopts=0 ;;
            *           ) echo "$original is an invalid option. See $0 --help"; return 1;;
        esac
    done

    declare -a files=("$@")
    if ((${#files[@]}==0)); then
        mapfile -t files < <(git ls-files)
        if ((${#files[@]}==0)); then
            cmd-echo -- "No git files found. Is current dir '${PWD}' a git repo?"
            return 1;
        fi
    fi

    declare root
    root=${PWD};
    root=${root%%/wt*}
    [ -t "$STDOUT" ] && opt_color=never ## No color if output redirected to a file.
    declare i
    for i in "${files[@]}"; do
        declare -a comp=("${root}/$i" "$i")
        if ((opt_reverse)); then
            comp=("$i" "${root}/$i")
        fi
        git --no-pager diff --no-index --color=$opt_color "${diff_opts[@]}" "${comp[@]}" 2>&1
    done | less -RE
}

git-worktree-diff-from-root ()
{
    git-worktree-diff-to-root --reverse "$@"
    return $?
}

git-worktree-show-merged ()
{
    git config --get-regexp "${GIT_EXT_META_PREFIX}-markedmerged"
}

git-worktree-mm ()
{
    git-worktree-mark-merged "$@"
}

git-worktree-mark-merged ()
{
    local opt_current=0
    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='c'
    declare longopts='current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@")
    declare status=$?
    ((status != 0)) && return $status

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true; do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            c | current) opt_current=1; wtname="$(_git_worktree_name_from_path "${PWD}")" ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo -ec -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    ! _git_worktree_check_set_pwd "mark merged" $opt_current && return 1
    local wtroot
    wtroot="${PWD}"

    if [ -z "$wtname" ]; then
        wtname="$1"; shift
    elif [ -n "$1" ]; then
        cmd-echo -- "Cannot specify a worktree and --current"
        return 1
    fi

    if [ -z "$wtname" ]; then
        cmd-echo -- "Worktree not specified"
        return 1
    fi
    if [ ! -d "$wtname" ]; then
        cmd-echo -- "Cannot find worktree $wtname
$(ls -la)"
        return 1
    fi
    local wtpath
    wtpath="$wtroot/$wtname"

    builtin cd "$wtpath" || { cmd-echo -- "Cannot cd $wtpath" && return 1; }

    # shellcheck disable=SC2119
    if ! git-worktree-ina; then
        cmd-echo -- "$wtname is not a proper worktree for marking merged"
        return 1;
    fi

    local worktreename
    worktreename="$(_git_worktree_name_from_path  "${PWD}")"
    local worktreekey="worktree.$worktreename.${GIT_EXT_META_PREFIX}-markedmerged"

    local branchname
    branchname="$(git repo current-branch)"
    local branchkey="branch.$branchname.${GIT_EXT_META_PREFIX}-markedmerged"

    local markdate
    markdate="$(date "$GIT_EXT_META_DATE_FMT")"

    git config --replace-all "$worktreekey" "$markdate" || return $?
    git config --replace-all "$branchkey" "$markdate" || return $?

    cmd-echo "Worktree $worktreename, branch $branchname marked merged at $markdate"
}

git-worktree-purge()
{
    declare -a wts
    wts=("$@")
    [[ -z ${wts[0]} ]] && readarray -t wts < <(git go --listfull --wto)
    declare wt
    for wt in "${wts[@]}"; do
        (
            cd "$wt" || exit 0;
            cmd-echo -- "$wt"
            declare ok_to_purge=1
            if git repo pr-get --open; then
                ok_to_purge=0
            fi
            if ! git repo is pristine -v; then
                ok_to_purge=0
            fi
            if ((ok_to_purge)); then
                resp=$(cmd-yesno -dc "Worktree is pristine. Delete it" n)
                [[ $resp == 'y' ]] && git wt del --current --yes
            fi
            echo
        )
    done
}

git-worktree-comment ()
{
    # shellcheck disable=SC2119
    if ! git-worktree-ina; then
        cmd-echo -- "Must be in a worktree"
        return 1;
    fi
    if [[ $1 =~ -(show|get) ]]; then
        git comment --get --worktree
    else
        git comment --branch --worktree "$@"
    fi
}

main ()
{
    declare action=$1

    if [[ "$action" =~ --doandcd ]]; then
        doandcdfile=$2
        shift; shift;
        action=$1
    fi

    if [[ "$action" =~ ^-+h ]]; then
        git-usage "$0"
        return  0
    fi

    ## abbrevs
    for abbrevable in 'create' 'delete'; do
        if [[ $abbrevable =~ $action ]]; then
            action=$abbrevable
            break
        fi
    done

    action_func_name="git-worktree-${action}"
    if declare -F "$action_func_name" >/dev/null; then
        shift ## the $action
        "$action_func_name" "$@"
    else
        case $action in
            add | list | lock | move | prune | remove | unlock )
                ## Dispatch to real git worktree
                "${REALGIT}" worktree "$@"
                ;;
            * )
                cmd-echo --wc -- "unknown git worktree action '$action'."
                if [[ $(yesno "Do you want to create a worktree with that name?" "n") == 'y' ]]; then
                    git-worktree-create "$action" "$@"
                else
                    false
                fi
                ;;
        esac
    fi
    declare dq=$?
    set +x
    return $dq
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-worktree - git extention of git worktree

=head1 SYNOPSIS

 git-worktree create
 git-worktree delete [--current]
 git-worktree rename [--current]

 git-worktree get-root
 git-worktree diff-from-root
 git-worktree diff-to-root
 git-worktree ina
 git-worktree get-name
 git-worktree mark-merged|mm
 git-worktree show-merged
 git-worktree comment

 git-worktree purge [worktree-dir [worktree-dir]... ]

=head1 DESCRIPTION

Extensions to the 'git worktree' command that understand and enforce our
worktree conventions. To wit:

o We do development on feature branches, using a clone of a forked repo.

o We create a worktree for each feature branch.

o We locate the worktree in the 'wt' subdir of the corresponding repo.

o We add the worktree location to the list of repos reachable by the 'git go'
  command.

We now have a consistent environment to execute multiple lines of development
in a given repo without the need to constantly checkout branches over and over
into the same repo location.

Any action not described here will be passed onto the actual 'git worktree'
command.

All extentions take a -h or --help option to display this manpage.

=head1 EXTENSIONS

=over 4

=item create

A synonymn for 'add' but one that respects our conventions.

For branches:

 git worktree cre[ate] [-f] [-r remote] [-c 'comment'] \
              [--[branch-from|from-branch] somebranch] [-l localbranchname] \
              worktree-name
       -f|--fetch
           - Do not create the branch, but fetch an existing branch.
       -r|--remote
           - Use 'remote' as the source; the default is 'origin'.
       -c|--comment
           - Record a short description readable with git-st-ext.
       --branch_from
           - use 'somebranch' as the worktree basis. The default is read from the repo.
       -l localbranchname
           - When fetching an existing remote branch 'X', use 'localbranchname'
             as the tracking branch name instead of 'X'. Most useful if you are
             fetching someone else's default branch.
       worktree-name
           - the name of the branch and worktree to create

For pull requests:

 git worktree cre[ate] [-r remote] [-c 'comment'] [-l localbranchname] --pull ID
       -r|--remote
           - Use 'remote' as the source; the default is 'origin'.
       -c|--comment
           - Record a short description readable with git-st-ext.
       -l  localbranchname
           - When fetching an existing pull request 'ID', use 'localbranchname'
             as the tracking branch name instead of pull-<remote>-<ID>.
       --pull ID
           - The pull request #

Note that there is no worktree-name argument for the pull request form. Unless
overriden withe the '-l' flag, the worktree name will be 'pull-<remote>-<ID>'.

=item delete

A synonym for 'remove', but one that respects our conventions.

 git worktree delete [-y] [-f] [--current | worktree-name ]
       -y|--yes     - Assume 'yes' to all prompts
       -f|--force   - Delete even if the repo is not 'clean'
       --current    - delete the worktree that is the current directory.
                      Otherwise, the current directory should be 'wt/'
                      and specify the worktree sub directory to delete.

=item rename

Changes the worktree name and the corresponding directory and branch.

 git worktree rename [--current | current-worktree-name] new-worktree-name
       --current    - rename the worktree that is the current directory.
                      Otherwise, the current directory should be 'wt/'
                      and specify the worktree sub directory to rename.


=item get-root

Get the root directory for the current worktree.

 git worktree get-root

=item diff-to-root

Perform a diff betweeen the default branch and the current worktree for a given
set of files or all the git-known files in the current worktree.

 git worktree diff-to-root [--reverse] [--color] [-w]
       --reverse - Perform the diff in the reverse order, i.e, betweeen the
                   current worktree and the default branch.
       --color   - Common git color options: always, never, or auto.
       -w        - Perform the diff ignoring whitespace.

=item diff-from-root

Perform a diff betweeen the current worktree and the default branch for a given
set of files or all the git-known files in the current worktree. A synonymn for

 git worktree diff-to-root --reverse

=item ina

Is the current working directory in a worktree? Adding the -p option will print
the worktree root.

<B>Note</B>: This is NOT the same as <C>git rev-parse --in-a-work-tree</C>.
That command tells you if you are in a working tree (with code) as opposed to a
bare repo (no code). Our command tells you if you are in a directory created
with 'git worktree'.

=item get-name

If the current working directory is in a worktree, print the name of the
worktree and exit 0. Otherwise print nothing and exit non-0. Really, this is a
synonym for <C>get worktree ina -v</C>.

=item mark-merged

Write configs 'worktree.<worktreename>.${GIT_EXT_META_PREFIX}-markmerged' and
'branch.<branchname>.${GIT_EXT_META_PREFIX}-markmerged' as the current date and time. Use this if
the worktree has been merged and can be deleted by some periodic sweep process.

=item show-merged

Show the '${GIT_EXT_META_PREFIX}-markmerged' entries for the current repo.

=item comment

Add a comment that can be retrieved later.

 git worktree comment "some text explaining where you left off, maybe?"
 git worktree comment -[get|show]

=item purge

This command is different. It does not work on the current worktree. It loops
over a list of worktrees or, if no list is provided, all the worktrees. If a
worktree has no open pulls and is completely clean (as determined by 'git repo
is pristine') then it prompts to accept deleting the worktree.

**NOTE:** Need 'worktrees' command or make this an offshoot of 'git repos'.

=back


=cut

__PODUSAGE__
