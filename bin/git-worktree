# -*- sh -*-
# shellcheck shell=bash

# git-worktree

if [[ -z $GIT_DISPATCHER ]]; then
    git-dispatch-warning git-worktree
fi

## Global used to control 'cd'ing around
doandcdfile=''

declare celn='--nolineno'

_git_worktree_check_set_pwd ()
{
    local action=$1
    local opt_current_ok=$2
    local cwd="${PWD}"

    ## Make sure pwd is the wt subdir or under that.
    if [[ ! $cwd =~ /wt ]]; then
        cwd="${cwd}/wt"
        if [[ -d ${cwd} ]]; then
            builtin cd "$cwd" || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd $cwd"; false; return; }
        else
            cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Current directory is ${cwd}." \
                     'No wt path component found.' \
                     'Will not manipulate worktrees outside of wt dir. Aborting.'
            false; return
        fi
    fi

    ## Yes you have to do this twice: once for when there's anything after the
    ## wt and once for when there's not.
    local wtroot="${cwd%%/wt/*}"
    wtroot="${wtroot%%/wt}/wt"

    ## Make sure we don't process ourselves unless --current flag is thrown
    local newwd="${PWD}"
    while [[ $newwd != "$wtroot" ]]; do
        if [[ -f $newwd/.git ]]; then
            if ((opt_current_ok!=1)); then
                if [[ $action == 'create' ]]; then
                    cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Will not $action a worktree in a worktree."
                else
                    cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Will not $action current worktree without -c flag"
                fi
                false; return
            fi
        fi
        newwd=$(dirname "$newwd")
    done

    ## Go to root so we can start working
    builtin cd "$wtroot" || { cmd-echo ${celn} $LINENO --id git-worktree -- "Cannot cd $wtroot"; false; return; }

    true
}

_git_worktree_info_remove ()
{
    ## There is no git-sanctioned worktree section. It's all us, so we have to
    ## manage it. The 'branch' stuff we add will be taken care of when the
    ## branch is deleted.
    git config --remove-section "worktree.$1"
}

_git_worktree_info_add_created_date ()
{
    local cr
    cr="$(date "$GIT_EXT_META_DATE_FMT")"
    local key
    for key in 'worktree' 'branch'; do
        git config --replace-all "$key.$1.${GIT_EXT_META_PREFIX}-created" "$cr" || return
    done
}

_git_worktree_info_add_fetched_date ()
{
    git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-fetched" "$(date "$GIT_EXT_META_DATE_FMT")"
}

_git_worktree_set_triangle ()
{
    declare branch_from=$1
    declare branch_from_ref=$2
    local -a branch_parts
    asplit "$branch_from_ref" -s '/' -a branch_parts
    # branch parts will contain
    # remote [origin|upstream] one-or-more-entries (depending on if slashes were used in the branch name)
    if [[ ${branch_parts[0]} == 'remotes' ]]; then
        ashift branch_parts
    fi
    local remote
    ashift branch_parts remote
    local full_branch_name
    ajoin full_branch_name -s '/' "${branch_parts[@]}"

    local -A triangle_workflow
    triangle_workflow[branch.${branch_from}.merge]="refs/heads/${full_branch_name}"
    triangle_workflow[branch.${branch_from}.mergeoptions]="--ff-only"
    triangle_workflow[branch.${branch_from}.remote]=$remote
    for key in "${!triangle_workflow[@]}"; do
        git config --replace-all "$key" "${triangle_workflow[$key]}" || return
    done
}

git-worktree-set ()
{
    local key=$1;shift
    case $key in
        spec-ref | spec_ref)
            local value="$*"
            if [[ -z $value ]]; then
                value=$(prompt "Description, issue url, DRQS, JIRA, etc. Hit <return> for none:")
            fi
            if [[ -n $value ]]; then
                local wtname; wtname=$(git-worktree-get-name)
                git config --replace-all "worktree.${wtname}.${GIT_EXT_META_PREFIX}-spec-ref" "$value"
            fi
            ;;
        * )
            cmd-echo ${celn} $LINENO --id git-worktree --wc "'$key' is not settable"
            ;;
        esac
}

_git_worktree_was_fetched ()
{
    [[ -n $(git config --get "^worktree.$1.${GIT_EXT_META_PREFIX}-fetched" 2>/dev/null) ]]
}

_git_worktree_is_a_pull ()
{
    [[ $(git repo current-branch) =~ ^pull ]]
}

_git_worktree_info_add_from_branch_and_ref ()
{
    ## TODO: Check that basename works in all conditions. Probably not when the
    ## from branch has a / in it, as in Berg at Bloomberg.
    git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-from-ref" "$2"
    git config --replace-all "worktree.$1.${GIT_EXT_META_PREFIX}-from-branch" "$(basename "$2")"
    git config --replace-all "branch.$1.${GIT_EXT_META_PREFIX}-from-ref" "$2"
    git config --replace-all "branch.$1.${GIT_EXT_META_PREFIX}-from-branch" "$(basename "$2")"
}

_git_worktree_name_from_path ()
{
    local path=$1
    path="${path##*wt/}"
    local -a tmp
    asplit "$path" -s / -a tmp
    ajoin path -s / "${tmp[@]}"
    echo "$path"
}

git-worktree-ina ()
{
    local status=1 ## Not in a worktree
    local git_root
    if git_root=$(git root 2>/dev/null); then
        ## We are at least in a git repo
        local git_meta="${git_root}/.git"
        if [[ -f "$git_meta" ]] && grep -q '/worktrees/' "$git_meta"; then
            ## Then the repo root has a .git file with a worktree statement in
            ## it. Therefore we are in a worktree.
            true; status=$?
            if [[ "$1" = '-v' ]]; then
                grep  '/worktrees/' "$git_meta" | sed 's|.*worktrees/||'
            fi
        fi
    fi
    return $status
}

git-worktree-get-name ()
{
    git-worktree-ina -v
}
git-worktree-get-source-branch ()
{
    local current_branch
    current_branch=$(git repo current-branch)
    git config --get "worktree.${current_branch}.${GIT_EXT_META_PREFIX}-from-branch"
}

git-worktree-create ()
{
    local fetch_existing=0
    local status=0
    local comment=''
    local branch_from
    local branch_from_arg
    local remote=origin
    local localbranchname
    local pull_request=''
    local wtfullpath
    local moreopts
    moreopts=1
    local verbose
    verbose=1
    local opt_reset=1
    while [[ "$1" =~ ^- ]] && ((moreopts)); do
        ## Strip all leading dashes here so that -foo and --foo can both
        ## be processed as 'foo'.
        local original="$1"
        local option

        option=$(dashstripper "$original")
        shift ## That way you avoid endless loops on invalid options.

        case $option in
            pr | pull )
                pull_request="$1"; shift
                ## Not going to create a pull request via a worktree.
                ## Rather create, force a fetch.
                fetch_existing=1
                ;;
            no-reset | skip-reset) opt_reset=0 ;;
            f|fetch) fetch_existing=1 ;;
            c|comment) comment="$1"; shift ;;
            from | from-branch | branch-from)
                branch_from=$1; shift
                branch_from_arg="$option"
                ;;
            h|help) git-usage "$0"; true; return ;;
            r|remote) remote=$1; shift ;;
            orphan) echo "Sorry, cannot create orphans this way."
                    echo "First create the orphan, then create a"
                    echo "worktree for it using --fetch."
                    false; return
                    ;;
            l|local) localbranchname=$1; shift;;
            --) moreopts=0 ;; ## end of opts, remaining $*, if any, are args
            *) git-usage "$0" "Error getting options!"; false; return;;
        esac
    done

    ## Make sure we are in the right place to start making the work tree.
    ! _git_worktree_check_set_pwd create && { false; return; }

    ## Update repo with latest remote info.
    local -a git_remotes
    readarray -t git_remotes < <(git remote)
    for i in "${git_remotes[@]}"; do git fetch "$i"; git pull; done

    ## Start making the wt dir
    local wtroot
    wtroot="${PWD}"
    local repo
    repo="$(basename "$(dirname "${PWD}")")" ## We are in /wt when we do this.
    local wtname="$1"
    shift
    local add_name_to_wt=0
    if git repo named-branches && \
            [[ ! $(dirname "$wtname") == "$USER" ]] ; then
        cmd-echo ${celn} $LINENO --id git-worktree -- "This repo is using named branches."
        add_name_to_wt=1
    elif ! git repo is fork; then
        cmd-echo ${celn} $LINENO --id git-worktree -- "This repo is a clone, not a fork."
        add_name_to_wt=1
    fi
    if ((add_name_to_wt)); then
        local resp
        resp=$(yesno -q "Use $USER/$wtname as the branch name and worktree directory" y)
        [[ $resp == 'y' ]] && wtname="$USER/$wtname"
        [[ $resp == 'q' ]] && { false; return; }
    fi
    echo "$wtname"
    local pull_ref
    if [[ -z "${wtname}" ]]; then
        if [[ -z "$pull_request" ]]; then
            git-usage "$0" "Need a branch name to use for the worktree spec."
            false; return
        else
            pull_ref="pull/$pull_request/head"
            wtname="pull-$remote-$pull_request"
        fi
    else
        if [[ -n "$pull_request" ]]; then
            git-usage "$0" "Cannot specify both a worktree-name and pull request id."
            false; return
        fi
    fi
    [[ -z "$localbranchname" ]] && localbranchname="${wtname}"

    ## Check remote. Must be fetchable and pushable.
    local exists
    exists=$(git remote -v | \
                 sort -u | \
                 perl -ane \
                      'BEGIN{$tgt=shift}print $F[2] if $F[0] eq $tgt' "$remote"
          )
    if [[ ! "$exists" = '(fetch)(push)' ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Can't find remote '$remote' for fetch and push"
        git remote -v | while read -r line; do cmd-echo ${celn} $LINENO --id git-worktree -- -c -- "$line"; done
        false; return
    fi
    cmd-echo ${celn} $LINENO --id git-worktree -- "Using '$remote' as remote."

    ## Check worktree dir
    ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "Check for existing worktrees with same name."
    local wtdir
    wtdir="${PWD}/$localbranchname"
    if [[ -e "${wtdir}" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "${wtdir} already exists. Aborting."
        false; return
    fi

    ## Check for branch
    local wtsubdir=$localbranchname
    local wtbranch=$localbranchname

    ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "Check for existing branch."

    ## Make sure we do not have a local branch with the same name
    exists=$(${REALGIT} branch --list --format='%(refname)' | sed 's|refs/heads/||' | \
                 while read -r line; do
                     if [[ "$line" = "$localbranchname" ]]; then
                         echo "$localbranchname"
                         break
                     fi
                 done
          )
    if [[ -n "$exists" ]]; then
        if ((fetch_existing==1)) && [[ -n "$exists" ]]; then
            cmd-echo ${celn} $LINENO --id git-worktree -- "Branch $localbranchname already exists locally. Using it."
            if $REALGIT worktree add "$localbranchname" "$localbranchname"; then
                ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "cd ${wtsubdir}"
                ## dirlist, not builtin cd, to take advantage this cd enhancement
                dirlist "$localbranchname"
                wtfullpath=${PWD}
                cmd-echo ${celn} $LINENO --id git-worktree -dc -- "set wtfullpath to ${wtfullpath} at line $((LINENO-1)) in $0, func ${FUNCNAME[0]}"
            else
                return
            fi
        else
            cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Branch $localbranchname already exists locally. Cannot create it."
            false; return
        fi
    else
        if [[ -z "$pull_request" ]]; then
            ## Now see if branch exists remotely
            exists=$(${REALGIT} branch -r --list --format='%(refname)' | sed 's|refs/remotes/||' | \
                         while read -r line; do
                             if [[ "$line" == "$remote/${wtname}" ]]; then
                                 echo "$remote/${wtname}"
                                 break
                             fi
                         done
                  )
        else
            ## Here, the existence check also fetches and creates the branch,
            ## so we don't need to do that below.
            exists="$localbranchname"
            if ! git fetch "$remote" "$pull_ref:$localbranchname"; then
                cmd-echo ${celn} $LINENO --id git-worktree -ec -- "Pull $pull_ref not found in $remote"
                false; return
            fi
        fi

        ## Yes, I could nest conditions instead of repeating them. I prefer to
        ## be explicit here.
        if ((fetch_existing==1)) && [[ -z "$exists" ]]; then
            cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot find '$remote/${wtname}' to fetch"
            false; return
        elif ((fetch_existing==0)) && [[ -n "$exists" ]]; then
            cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Branch '${wtname}' already exists in remote '$remote'"
            false; return
        elif ((fetch_existing==1)) && [[ -n "$exists" ]]; then
            ## Fetch it, Dear Henry...
            local -a wtargs
            if [[ -z "$pull_request" ]]; then
                wtargs=('--track' '-b' "$localbranchname" )
            else
                cmd-echo ${celn} $LINENO --id git-worktree -wc -- \
                         "Pulling a PR directly will leave you with a branch" \
                         "that will not track the remote PR, and, therefore cannot be" \
                         "'git pull'ed to update it. " \
                         "" \
                         "If you think you're going to want to push new" \
                         "commits to the PR, or that you're going to have to" \
                         "pull updates to local copy of the PR, then you're" \
                         "probably better off cloning the repo where the PR" \
                         "originated, checking out the source branch of the" \
                         "PR, and working with that."
            fi
            $REALGIT worktree add "${wtargs[@]}" "$localbranchname" "$exists"
            status=$?
            if ((status)); then
                cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Aborting."
                false; return
            fi
            local respdbg
            respdbg=$(yesno "Continue" "n")
            [[ $respdbg == 'n' ]] && exit
            ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "cd ${wtsubdir}"
            ## dirlist, not builtin cd, to take advantage this cd enhancement
            dirlist "${wtsubdir}"
            wtfullpath=${PWD}
            cmd-echo ${celn} $LINENO --id git-worktree -dc -- "set wtfullpath to ${wtfullpath} at line $((LINENO-1)) in $0, func ${FUNCNAME[0]}"

            _git_worktree_info_add_fetched_date "$localbranchname"
        else ## ((fetch_existing==0)) && [[ -z "$exists" ]
            local -a branch_from_ref
            if [[ -n $branch_from ]]; then
                ## $branch_from is the branch name. We need the full branch ref
                ## here. Get it and check it.
                if [[ $branch_from =~ master|main ]]; then
                    # Typical default
                    branch_from="upstream/$branch_from"
                fi
                local -a all_refs
                all_refs=$("${REALGIT}" branch -a)
                readarray -t branch_from_ref < <("${REALGIT}" branch -a | grep -e "${branch_from}$" | sed -E 's/^\+{0,1}\s+//')
                case ${#branch_from_ref[@]} in
                    0 ) cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Branch '$branch_from' not found in refs list:" "${all_refs[@]}" "Aborting"
                        false; return;;
                    1 ) # Set up "triangle workflow'. Only need the branch
                        # specific pieces. The rest of it was set up when the
                        # fork was cloned.
                        local -a branch_parts
                        asplit "${branch_from_ref[0]}" -s '/' -a branch_parts
                        # branch parts will contain
                        # remote [origin|upstream] one-or-more-entries (depending on if slashes were used in the branch name)
                        if [[ ${branch_parts[0]} == 'remotes' ]]; then
                            ashift branch_parts
                        fi
                        local remote
                        ashift branch_parts remote
                        local full_branch_name
                        ajoin full_branch_name -s '/' "${branch_parts[@]}"

                        local -A triangle_workflow
                        triangle_workflow[branch.${branch_from}.merge]="refs/heads/${full_branch_name}"
                        triangle_workflow[branch.${branch_from}.mergeoptions]="--ff-only"
                        triangle_workflow[branch.${branch_from}.remote]=$remote
                        for key in "${!triangle_workflow[@]}"; do
                            git config --replace-all "$key" "${triangle_workflow[$key]}" || return
                        done
                        ;;
                    * ) cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Branch '$branch_from' found more than once in refs list:" "${branch_from_ref[@]}" \
                                 "Re-run and specify full reference for --$branch_from_arg"
                        false; return;;
                esac
            else
                branch_from_ref[0]="$(git-repo default-branch)"
            fi

            ## Now create the worktree and the branch.
            ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "$REALGIT worktree add -b ${wtsubdir} ${wtbranch} ${branch_from_ref[0]}"
            $REALGIT worktree add -b "${wtsubdir}" "${wtbranch}" "${branch_from_ref[0]}"
            status=$?
            if ((status)); then
                cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Aborting."
                false; return
            fi

            ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "cd ${wtsubdir}"
            ## dirlist, not builtin cd, to take advantage this cd enhancement
            dirlist "${wtsubdir}"
            wtfullpath=${PWD}
            ## cmd-echo ${celn} $LINENO --id git-worktree -dc -- "set wtfullpath to ${wtfullpath} at line $((LINENO-1)) in $0, func ${FUNCNAME[0]}"

            _git_worktree_info_add_created_date "${wtbranch}"
            _git_worktree_info_add_from_branch_and_ref "${wtbranch}" "${branch_from_ref[0]}"
            git-worktree-set 'spec_ref'
            ## Finally push the branch up as a tracking branch
            ((verbose)) && cmd-echo ${celn} $LINENO --id git-worktree -- "git push --set-upstream $remote ${wtbranch}"
            git push --set-upstream "$remote" "${wtbranch}"
        fi
    fi

    ## Convert the worktree's .git file to use a relative path to the default
    ## .git location. In that way, we can use the repo on machines where it may
    ## be mounted in a different place, so that the absolute path is different
    ## in those places.
    local wtroot
    wtroot=$(pwd)
    local -a relative_path_parts
    relative_path_parts=()
    while [[ $wtroot != '/' ]] && [[ $(basename "$wtroot") != 'wt' ]]; do
        relative_path_parts+=('..')
        wtroot=$(dirname "$wtroot");
    done
    if [[ $wtroot == '/' ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --wc -- "Cannot find a 'wt' parent dir; not making relative worktree .git entry"
    else
        relative_path_parts+=('..')
    fi
    local relative_path_part
    ajoin relative_path_part -s '/' "${relative_path_parts[@]}"
    sed -i 's|\(gitdir: \).*/\(.git/worktrees\)|\1'"${relative_path_part}"'/\2|' .git

    git-post-new

    [[ -n $comment ]] && git-worktree-comment "$comment"

    ## Add this repo to the list
    if ((opt_reset)); then
        cmd-echo ${celn} $LINENO --id git-worktree -- "Resetting git list..."
        git go-set
    else
        cmd-echo ${celn} $LINENO --id git-worktree -- "--skip-reset. Run 'git go-set' at some point."
    fi

    ## Show some info
    cmd-echo ${celn} $LINENO --id git-worktree -- "Branch and worktree metadata..."
    git-repo info --no-pulls

    ## Deal with the cd shenanigans
    if [[ -z "$doandcdfile" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree -- \
                 "Done. Execute" \
                 "    git go $repo/wt/${wtsubdir}" \
                 "to use."
    else
        ## cmd-echo ${celn} $LINENO --id git-worktree -dc -- "writting wtfullpath '$wtfullpath' into '$doandcdfile' at line $((LINENO+1)) in $0, func ${FUNCNAME[0]}"
        echo "dirlist $wtfullpath" > "$doandcdfile"
        cmd-echo ${celn} $LINENO --id git-worktree -n -- "Done. "
    fi
    true
}

git-worktree-delete ()
{
    local opt_yes=0
    local opt_yes_string
    local opt_force=0
    local opt_reset=1
    local opt_keep_branch=0
    local opt_current=0
    local wtname=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    local OPTSARGS
    local shortopts='yfhkc'
    local longopts='no-reset,skip-reset,yes,force,help,keep-branch,current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@") || return

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true; do
        local option=$1
        shift
        [[ "$option" != '--' ]] && option=${option##-} && option=${option##-}
        case "$option" in
            c | current) opt_current=1; wtname="$(_git_worktree_name_from_path "${PWD}")" ;;
            no-reset | skip-reset) opt_reset=0; ;;
            y|yes) opt_yes=1; opt_yes_string='--yes'; ;;
            f|force) opt_force=1; ;;
            h|help) git-usage "$0"; true; return ;;
            k|keep-branch) opt_keep_branch=1 ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo ${celn} $LINENO --id git-worktree -ec -- "$option is an invalid option. See $0 --help"
                false; return
                ;;
        esac
    done

    if ((opt_force + opt_yes + opt_keep_branch > 1 )); then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "--force, --keep-branch and --yes are mutex options"
        false; return
    fi

    ! _git_worktree_check_set_pwd delete $opt_current && { false; return; }
    local wtroot
    wtroot="${PWD}"

    if [[ -z "$wtname" ]]; then
        wtname="$1"; shift
    elif [[ -n "$1" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot specify a worktree and --current"
        false; return
    fi

    if [[ -z "$wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Worktree not specified"
        false; return
    fi
    if [[ ! -d "$wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot find worktree $wtname
$(ls -la)"
        false; return
    fi
    local wtpath
    wtpath="$wtroot/$wtname"

    builtin cd "$wtpath" || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd $wtpath"; false; return; }

    ## Make sure we are in a proper worktree.
    if ! git-worktree-ina; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "$wtname is not a proper worktree for deletion"
        false; return
    fi

    ## Check for cleanliness.
    if [[ "$(git status --porcelain | wc -l)" != '0' ]] || \
           [[ "$(git status | grep 'Your branch is' | grep -c -v 'up.to.date')" != '0' ]]; then
        if((!opt_force)); then
            git status
            echo
            cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Will not delete unclean worktree. Clean worktree or re-run command with --force."
            false; return
        fi
    fi

    ## Current branch
    local current_branch
    current_branch=$(git repo current-branch)

    ## Checking cleanliness and consistency
    local current_branch_dir
    current_branch_dir=$(_git_worktree_name_from_path "${PWD}")
    if [[ "$current_branch" != "$current_branch_dir" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Branch name '$current_branch' does not match current subdir name '$current_branch_dir'." \
                 "I'm bailing; you fix this mess."
            false; return
        false; return
    fi
    git status
    local rc=$?
    if ((rc)); then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "git status returned non-success value $rc." \
                    "I'm bailing; you fix this mess."
        false; return
    fi

    ## Whack it. Start with the current dir, which is the worktree.
    cmd-echo ${celn} $LINENO --id git-worktree -- "Deleting the worktree directory..."
    local delit
    delit=$(basename "${PWD}")
    builtin cd .. || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd .."; false; return ; }
    if ! rm -rf "$delit"; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Bad rm of ./$delit (from ${PWD}). Aborting."
        false; return
    fi

    ## Work our way up to the first non empty dir or the 'wt' dir, whichever we
    ## get to first, and stop deleting.
    while [[ "$(basename "${PWD}")" != 'wt' ]]; do
        if [[ -z "$(ls -A "${PWD}")" ]]; then
            #it's empty
            delit=$(basename "${PWD}")
            builtin cd .. || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd .."; false; return; }
            command rm -rf "$delit" || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Bad rm of ./$delit (from ${PWD}). Aborting."; false; return; }
        else
            builtin cd .. || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd .."; false; return; }
        fi
    done

    cmd-echo ${celn} $LINENO --id git-worktree -- "Worktree directory deleted."

    ## Now fix the administrative files.
    cmd-echo ${celn} $LINENO --id git-worktree -- "Cleaning worktree metadata..."
    $REALGIT worktree prune

    # Hold onto some info..
    local was_fetched
    was_fetched=$(_git_worktree_was_fetched "$current_branch"; echo $?)

    ## ...before we trash the metadata
    _git_worktree_info_remove "$current_branch"
    cmd-echo ${celn} $LINENO --id git-worktree -- "Worktree metadata cleaned."

    ## Now the take care of the branch.
    cmd-echo ${celn} $LINENO --id git-worktree -- "Cleaning branch..."
    local resp
    if ((opt_yes)); then
        resp='y'
    elif ((opt_keep_branch)); then
        resp='n'
    else
        true; if [[ $was_fetched == "?" ]]; then
            cmd-echo ${celn} $LINENO --id git-worktree -wc -- "This worktree's branch was fetched, not created. Be careful deleting the remote."
        fi
        resp=$(cmd-yesno --id git-worktree "Delete associated branch '$current_branch'" 'n')
    fi
    if [[ "$resp" = 'n' ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree -- "If you change your mind: git-branch --delete $current_branch"
    else
        ## Have to be in the git repo that the basis for the worktree.
        while [[ "$(basename "${PWD}")" != 'wt' ]]; do
            builtin cd .. || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd .." ; false; return; }
        done
        builtin cd .. || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd .." ; false; return; }
        if [[ "$resp" = 'y' ]]; then
            declare force
            ((opt_force)) && force="--force"
            git-branch --delete $force --no-go-set $opt_yes_string "$current_branch"
        fi
    fi
    cmd-echo ${celn} $LINENO --id git-worktree -- "Branch cleaned."

    ## Cleanup
    if ((opt_reset)); then
        cmd-echo ${celn} $LINENO --id git-worktree -- "Resetting git list..."
        git go-set
    else
        cmd-echo ${celn} $LINENO --id git-worktree -- "--skip-reset. Run 'git go-set' at some point."
    fi

    [[ -n "$doandcdfile" ]] && echo "dirlist $wtroot" > "$doandcdfile"

    cmd-echo ${celn} $LINENO --id git-worktree -- "Done."

    true
}

git-worktree-rename ()
{
    local opt_reset=1
    local opt_current=0
    local old_wtname=''

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    local OPTSARGS
    local shortopts='h'
    local longopts='no-reset,skip-reset,help,current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@") || return

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true; do
        local option=$1
        shift
        [[ "$option" != '--' ]] && option=${option##-} && option=${option##-}
        case "$option" in
            current) opt_current=1; old_wtname="$(_git_worktree_name_from_path "${PWD}")" ;;
            no-reset | skip-reset) opt_reset=0;;
            h|help) git-usage "$0"; true; return ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo ${celn} $LINENO --id git-worktree -ec -- "$option is an invalid option. See $0 --help"
                false; return
                ;;
        esac
    done

    if (( $# == 0 )) || ( (( $# == 1 )) && [[ -z "$old_wtname" ]] ); then
        git-usage "$0" "Missing arguments"
        false; return
    fi

    if (( $# > 2 )); then
        git-usage "$0" "Too many arguments"
        false; return
    fi

    local status

    ! _git_worktree_check_set_pwd rename $opt_current && { false; return; }
    local wtroot
    wtroot="${PWD}"

    if [[ -z "$old_wtname" ]]; then
        old_wtname="$1"
        shift
    fi

    if [[ ! -d "$old_wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot find worktree $old_wtname
$(ls -la)"
        false; return
    fi
    local old_wtpath="$wtroot/$old_wtname"

    local new_wtname="$1" ; shift
    if [[ -d "$new_wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Will not overwrite existing worktree $new_wtname
$(ls -la)"
        false; return
    fi
    local new_wtpath="$wtroot/$new_wtname"
    builtin cd "$old_wtpath" || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd $old_wtpath" ; false; return; }
    local cb
    cb="$(git repo current-branch)"
    if [[ "$cb" = "$old_wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree -- "Renaming the branch..."
        git-branch --rename "$old_wtname" "$new_wtname"
        status=$?
        if ((status != OK)); then
            false; return
        fi
    fi

    cmd-echo ${celn} $LINENO --id git-worktree -- "Updating metadata..."
    ## Get the metadata directory for this worktree
    local metadatadir
    metadatadir="$(grep -E '^gitdir:' .git | sed 's/.* //')"

    ## Get the metadata files for this worktree
    local heregit
    heregit=${PWD}/.git
    local theregit
    theregit=${metadatadir}/gitdir

    ## Change the metadata files
    perl -pi -e "s/$old_wtname/$new_wtname/g" "$heregit" "$theregit" || return

    ## Move the metadata dir
    local newmetadatadir
    newmetadatadir="$(dirname "$metadatadir")/$new_wtname"
    mv "$metadatadir" "$newmetadatadir" || return

    cmd-echo ${celn} $LINENO --id git-worktree -- "Moving the local files..."
    ## Move us
    builtin cd .. || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd .." ; false; return; }
    mv "$old_wtpath" "$new_wtpath" || return

    ## Register the rename
    local -a paths
    IFS='/' read -ra paths <<< "$new_wtpath"
    local sliceindex=$((${#paths[@]} - 4 ))
    local gitgoto
    gitgoto="$(printf "%s/" "${paths[@]:$sliceindex:3}")${paths[-1]}"
    if ((opt_reset)); then
        cmd-echo ${celn} $LINENO --id git-worktree -- "Resetting git list..."
        git go-set
        if ((opt_current)); then
            git go "$gitgoto"
        fi
    else
        cmd-echo ${celn} $LINENO --id git-worktree -- "--skip-reset. Run 'git go-set' at some point."
    fi

    if ((opt_current)); then
        if [[ -z "$doandcdfile" ]]; then
            cmd-echo ${celn} $LINENO --id git-worktree -- \
                     "Done. Execute" \
                     "    git go $gitgoto" \
                     "to use."
        else
            echo "dirlist $new_wtpath" > "$doandcdfile"
            cmd-echo ${celn} $LINENO --id git-worktree -n -- "Done. "
        fi
    else
        cmd-echo ${celn} $LINENO --id git-worktree -- "Done. "
    fi

    true
}

git-worktree-diff-to-root ()
{
    if ! git-worktree-ina; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Must be in a worktree"
        false; return;
    fi

    local moreopts
    moreopts=1
    local opt_reverse
    opt_reverse=0
    local opt_color
    opt_color='always'
    local -a diff_opts
    while [[ "$1" =~ ^- ]] && ((moreopts)); do
        ## Strip all leading dashes here so that -foo and --foo can both
        ## be processed as 'foo'.
        local original="$1"
        local option
        option=$(dashstripper "$original")
        shift ## That way you avoid endless loops on invalid options.

        case $option in
            reverse     ) opt_reverse=1 ;;
            color       ) opt_color=$1; shift ;;
            w|name-only ) diff_opts+=("$option") ;;
            l           ) diff_opts+=('--name-only') ;;
            help        ) echo "No documentation yet. Sorry."; true; return ;;
            debug | x   ) set -x ;;
            --          ) moreopts=0 ;;
            *           ) echo "$original is an invalid option. See $0 --help"; false; return;;
        esac
    done

    local -a files=("$@")
    if ((${#files[@]}==0)); then
        mapfile -t files < <(git ls-files)
        if ((${#files[@]}==0)); then
            cmd-echo ${celn} $LINENO --id git-worktree --ec -- "No git files found. Is current dir '${PWD}' a git repo?"
            false; return;
        fi
    fi

    local root
    root=${PWD};
    root=${root%%/wt*}
    [[ -t 1 ]] && opt_color=never ## No color if output redirected to a file, '1' is stdout.
    local i
    for i in "${files[@]}"; do
        local -a comp=("${root}/$i" "$i")
        if ((opt_reverse)); then
            comp=("$i" "${root}/$i")
        fi
        git --no-pager diff --no-index --color=$opt_color "${diff_opts[@]}" "${comp[@]}" 2>&1
    done | less -RE
}

git-worktree-diff-from-root ()
{
    git-worktree-diff-to-root --reverse "$@"
}

git-worktree-show-merged ()
{
    git config --get-regexp "${GIT_EXT_META_PREFIX}-markedmerged"
}

git-worktree-mm ()
{
    git-worktree-mark-merged "$@"
}

git-worktree-mark-merged ()
{
    local opt_current=0
    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    local OPTSARGS
    local shortopts='c'
    local longopts='current'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "${FUNCNAME[0]}" -- "$@") || return

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true; do
        local option=$1
        shift
        [[ "$option" != '--' ]] && option=${option##-} && option=${option##-}
        case "$option" in
            c | current) opt_current=1; wtname="$(_git_worktree_name_from_path "${PWD}")" ;;
            --) break ;; ## VITAL!!! Exits the while loop, no more options,
                         ## remaining $*, if any, are args
            *)
                cmd-echo ${celn} $LINENO --id git-worktree -ec -- "$option is an invalid option. See $0 --help"
                false; return
                ;;
        esac
    done

    ! _git_worktree_check_set_pwd "mark merged" $opt_current && { false; return; }
    local wtroot
    wtroot="${PWD}"

    if [[ -z "$wtname" ]]; then
        wtname="$1"; shift
    elif [[ -n "$1" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot specify a worktree and --current"
        false; return
    fi

    if [[ -z "$wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Worktree not specified"
        false; return
    fi
    if [[ ! -d "$wtname" ]]; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot find worktree $wtname
$(ls -la)"
        false; return
    fi
    local wtpath
    wtpath="$wtroot/$wtname"

    builtin cd "$wtpath" || { cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Cannot cd $wtpath" ; false; return; }

    if ! git-worktree-ina; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "$wtname is not a proper worktree for marking merged"
        false; return;
    fi

    local worktreename
    worktreename="$(_git_worktree_name_from_path  "${PWD}")"
    local worktreekey="worktree.$worktreename.${GIT_EXT_META_PREFIX}-markedmerged"

    local branchname
    branchname="$(git repo current-branch)"
    local branchkey="branch.$branchname.${GIT_EXT_META_PREFIX}-markedmerged"

    local markdate
    markdate="$(date "$GIT_EXT_META_DATE_FMT")"

    git config --replace-all "$worktreekey" "$markdate" || return
    git config --replace-all "$branchkey" "$markdate" || return

    cmd-echo ${celn} $LINENO --id git-worktree "Worktree $worktreename, branch $branchname marked merged at $markdate"
}

git-worktree-purge()
{
    local -a wts
    wts=("$@")
    [[ -z ${wts[0]} ]] && readarray -t wts < <(git go --listfull --wto)
    local wt
    for wt in "${wts[@]}"; do
        (
            builtin cd "$wt" || exit
            echo
            cmd-echo ${celn} $LINENO --id git-worktree --title --color BLUE -- "$wt"
            local ok_to_purge=1
            local pr
            pr=$(git repo pr-get --open)
            local prstat=$?
            cmd-echo ${celn} $LINENO --id git-worktree -- "Pull Request: $pr"
            if [[ $prstat == '0' ]] || \
                   ! git repo is pristine -v; then
                ok_to_purge=0
            fi
            if ((ok_to_purge==1)); then
                local resp
                resp=$(cmd-yesno --id git-worktree -q -dc "Worktree is pristine. Delete it" n)
                [[ $resp == 'y' ]] && git wt del --current --yes
                [[ $resp == 'q' ]] && exit 37 # random, otherwise unlikely
                                              # status, to break the for loop
            fi
        )
        (( $? == 37 )) && break;
    done
}

git-worktree-comment ()
{
    if ! git-worktree-ina; then
        cmd-echo ${celn} $LINENO --id git-worktree --ec -- "Must be in a worktree"
        false; return;
    fi
    if [[ $1 =~ -(show|get) ]]; then
        git comment --get --worktree "$@"
    else
        git comment --branch --worktree "$@"
    fi
}

main ()
{
    local action=$1

    if [[ "$action" =~ --doandcd ]]; then
        doandcdfile=$2
        shift; shift;
        action=$1
    fi

    if [[ "$action" =~ ^-+h ]]; then
        git-usage "$0"
        true; return
    fi

    ## abbrevs
    for abbrevable in 'create' 'delete'; do
        if [[ $abbrevable =~ $action ]]; then
            action=$abbrevable
            break
        fi
    done

    action_func_name="git-worktree-${action}"
    if local -F "$action_func_name" >/dev/null; then
        shift ## the $action
        "$action_func_name" "$@"
    else
        case $action in
            add | list | lock | move | prune | remove | unlock )
                ## Dispatch to real git worktree
                "${REALGIT}" worktree "$@"
                ;;
            * )
                cmd-echo ${celn} $LINENO --id git-worktree --wc -- "unknown git worktree action '$action'."
                if [[ $(yesno "Do you want to create a worktree with that name?" "n") == 'y' ]]; then
                    git-worktree-create "$action" "$@"
                else
                    false
                fi
                ;;
        esac
    fi
    return
}

main "$@"
exit

:<<'__PODUSAGE__'
=head1 NAME

git-worktree - git extention of git worktree

=head1 SYNOPSIS

 git-worktree create
 git-worktree delete [--current]
 git-worktree rename [--current]

 git-worktree get-root
 git-worktree diff-from-root
 git-worktree diff-to-root
 git-worktree ina
 git-worktree get-name
 git-worktree mark-merged|mm
 git-worktree show-merged
 git-worktree comment

 git-worktree purge [worktree-dir [worktree-dir]... ]

=head1 DESCRIPTION

Extensions to the 'git worktree' command that understand and enforce our
worktree conventions. To wit:

o We do development on feature branches, using a clone of a forked repo.

o We create a worktree for each feature branch.

o We locate the worktree in the 'wt' subdir of the corresponding repo.

o We add the worktree location to the list of repos reachable by the 'git go'
  command.

We now have a consistent environment to execute multiple lines of development
in a given repo without the need to constantly checkout branches over and over
into the same repo location.

Any action not described here will be passed onto the actual 'git worktree'
command.

All extentions take a -h or --help option to display this manpage.

=head1 EXTENSIONS

=over 4

=item create

A synonymn for 'add' but one that respects our conventions.

For branches:

 git worktree cre[ate] [-f] [-r remote] [-c 'comment'] \
              [--[branch-from|from-branch] somebranch] [-l localbranchname] \
              worktree-name
       -f|--fetch
           - Do not create the branch, but fetch an existing branch.
       -r|--remote
           - Use 'remote' as the source; the default is 'origin'.
       -c|--comment
           - Record a short description readable with git-st-ext.
       --branch_from
           - use 'somebranch' as the worktree basis. The default is read from the repo.
       -l localbranchname
           - When fetching an existing remote branch 'X', use 'localbranchname'
             as the tracking branch name instead of 'X'. Most useful if you are
             fetching someone else's default branch.
       worktree-name
           - the name of the branch and worktree to create

For pull requests:

 git worktree cre[ate] [-r remote] [-c 'comment'] [-l localbranchname] --pull ID
       -r|--remote
           - Use 'remote' as the source; the default is 'origin'.
       -c|--comment
           - Record a short description readable with git-st-ext.
       -l  localbranchname
           - When fetching an existing pull request 'ID', use 'localbranchname'
             as the tracking branch name instead of pull-<remote>-<ID>.
       --pull ID
           - The pull request #

Note that there is no worktree-name argument for the pull request form. Unless
overriden withe the '-l' flag, the worktree name will be 'pull-<remote>-<ID>'.

=item delete

A synonym for 'remove', but one that respects our conventions.

 git worktree delete [-y] [-f] [--current | worktree-name ]
       -y|--yes     - Assume 'yes' to all prompts
       -f|--force   - Delete even if the repo is not 'clean'
       --current    - delete the worktree that is the current directory.
                      Otherwise, the current directory should be 'wt/'
                      and specify the worktree sub directory to delete.

=item rename

Changes the worktree name and the corresponding directory and branch.

 git worktree rename [--current | current-worktree-name] new-worktree-name
       --current    - rename the worktree that is the current directory.
                      Otherwise, the current directory should be 'wt/'
                      and specify the worktree sub directory to rename.


=item get-root

Get the root directory for the current worktree.

 git worktree get-root

=item diff-to-root

Perform a diff betweeen the default branch and the current worktree for a given
set of files or all the git-known files in the current worktree.

 git worktree diff-to-root [--reverse] [--color] [-w]
       --reverse - Perform the diff in the reverse order, i.e, betweeen the
                   current worktree and the default branch.
       --color   - Common git color options: always, never, or auto.
       -w        - Perform the diff ignoring whitespace.

=item diff-from-root

Perform a diff betweeen the current worktree and the default branch for a given
set of files or all the git-known files in the current worktree. A synonymn for

 git worktree diff-to-root --reverse

=item ina

Is the current working directory in a worktree? Adding the -p option will print
the worktree root.

<B>Note</B>: This is NOT the same as <C>git rev-parse --in-a-work-tree</C>.
That command tells you if you are in a working tree (with code) as opposed to a
bare repo (no code). Our command tells you if you are in a directory created
with 'git worktree'.

=item get-name

If the current working directory is in a worktree, print the name of the
worktree and exit 0. Otherwise print nothing and exit non-0. Really, this is a
synonym for <C>get worktree ina -v</C>.

=item mark-merged

Write configs 'worktree.<worktreename>.${GIT_EXT_META_PREFIX}-markmerged' and
'branch.<branchname>.${GIT_EXT_META_PREFIX}-markmerged' as the current date and time. Use this if
the worktree has been merged and can be deleted by some periodic sweep process.

=item show-merged

Show the '${GIT_EXT_META_PREFIX}-markmerged' entries for the current repo.

=item comment

Add a comment that can be retrieved later.

 git worktree --comment "some text explaining where you left off, maybe?"

The current time is added to the end of the comment when retrieved if [--date] is used.

 git worktree --comment --get
 worktree: some text explaining where you left off, maybe?

 git worktree --comment --get --date
 worktree: some text explaining where you left off, maybe? (2022-11-29.21:49:27-0500)

=item purge

This command is different. It does not work on the current worktree. It loops
over a list of worktrees or, if no list is provided, all the worktrees. If a
worktree has no open pulls and is completely clean (as determined by 'git repo
is pristine') then it prompts to accept deleting the worktree.

**NOTE:** Need 'worktrees' command or make this an offshoot of 'git repos'.

=back


=cut

__PODUSAGE__
