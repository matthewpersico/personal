#!/usr/bin/env bash

# git-clone

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

cmd_echo_id='git-clone'

## Before we even start, make sure that the underlying client hasn't changed
## under us. Otherwise we can have issues with the passthough options, either
## new ones we don't handle or deprecated ones we have not removed.

realgit_verified_version_string='git version 2.19.2'
if [ ! "$($REALGIT --version)" = "$realgit_verified_version_string" ]
then
    cmd-echo -id "$cmd_echo_id" -e -- \
             "Verified to $realgit_verified_version_string," \
             "but $($REALGIT --version) is installed." \
             "Please investigate."
    exit 1
fi

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        echo "** Extended actions **"
        script-usage
        echo
        echo "** Standard actions **"
        "$REALGIT" clone --help
    ) 2>&1 | ${PAGER:-less}
}

_git_clone_record_created_date ()
{
    git config --replace-all em.git-clone.created "$(date "$GIT_EXT_META_DATE_FMT")" || exit $?
}

_git-clone-set-triangle()
{
    declare githosturl
    githosturl=$1
    declare githostkeycheck
    githostkeycheck=$(kvstore keys gitfuncs_gitsvcs | grep -E "^$githosturl$")
    if [ -n "$githostkeycheck" ] ; then
        echo "Supposed to provide a URL, not a service name. Converting..."
        githosturl=$(kvstore get gitfuncs_gitsvcs "$githostkeycheck")
        if [ -z "$githosturl" ]
        then
            echo "No url found for githost '$1'";
            exit 1
        fi
    fi

    declare upstream_namespace
    upstream_namespace=$2
    declare origin_namespace
    origin_namespace=$3
    declare repo
    repo=$4

    declare -A triangle_workflow
    triangle_workflow[branch.master.merge]="refs/heads/master"
    triangle_workflow[branch.master.mergeoptions]="--ff-only"
    triangle_workflow[branch.master.remote]="upstream"

    triangle_workflow[remote.origin.url]="${githosturl}${origin_namespace}/${repo}"
    triangle_workflow[remote.pushdefault]="origin"
    triangle_workflow[remote.upstream.url]="${githosturl}${upstream_namespace}/${repo}"

    declare key
    for key in "${!triangle_workflow[@]}"
    do
        git config --replace-all "$key" "${triangle_workflow[$key]}" || exit $?
    done

    ##
    ## These are special because they repeat
    ##
    key='remote.origin.fetch'

    git config --replace-all $key "+refs/heads/*:refs/remotes/origin/*" || exit $?
    git config --add         $key "+refs/pull/*/head:refs/pull/origin/*" || exit $?
    ## ^ allows git checkout -b 3 pull/origin/3

    key='remote.upstream.fetch'
    git config --replace-all $key "+refs/heads/*:refs/remotes/upstream/*" || exit $?
    git config --add         $key "+refs/pull/*/head:refs/pull/upstream/*" || exit $?
    git config --add         $key "+refs/notes/*:refs/notes/*" || exit $?
    ## ^ allows git checkout -b 3 pull/upstream/3

    ## Our own metadata
    git config --replace-all em.git-clone.triangle-remote "${origin_namespace}" || exit $?

    return 0
}

declare opt_y=0
declare opt_t=0
declare opt_triangle_namespace=''
declare opt_worktree=1
declare opt_worktree_name=''
declare opt_worktree_fetch=''
declare opt_use_githost_dir=0
declare opt_make_fork=0
declare dispatch_to_real_git=1
declare githost
declare moreopts
declare namespace
declare repo
declare -a orig_args=("$@")
declare -a git_clone_opts
moreopts=1
while [[ "$1" =~ ^- ]] && ((moreopts))
do
    declare original="$1"
    declare option
    option=$(dashstripper "$original")
    shift ## That way you avoid endless loops on invalid options.
    ## This bit deals with --foo=bar instead of --foo bar
    declare okey
    declare ovalue=''
    if [[ "$option" =~ = ]]
    then
        okey=${option%%=*}
        ovalue=${option#*=}
        option="$okey"
    fi

    case $option in
        ##
        ## Our options
        ##
        tree )
            ## Use our gitgo tree. This allows us to say
            ## git clone --tree bbgithub:/org/repo (use the gitgo tree)
            ## instead of
            ## git clone --githost bbgithub org/repo (oh, you have one of our options, you probably want to use the gitgo tree)
            dispatch_to_real_git=0
            opt_use_githost_dir=1;;
        y | yes )
            dispatch_to_real_git=0; opt_y=1;;
        t | timestamp )
            dispatch_to_real_git=0; opt_t=1;;
        forkof | fo)
            opt_make_fork=1
            dispatch_to_real_git=0
            opt_use_githost_dir=1 ## if we are using triangle, we most want trees too
            opt_worktree=1 ## and worktrees.
            declare tmp_otn=${ovalue:-$1}
            [ -z "$ovalue" ] && shift ## If ovalue is blank, we used $1
            if [[ "$tmp_otn" =~ ^- ]]
            then
                ## we got the next option, not an arg to this one
                cmd-echo -id "$cmd_echo_id" -e -- "Fork org ($tmp_otn) cannot start with a '-'."
                exit 1
            fi
            opt_triangle_namespace=${tmp_otn%/*}
            if [ ! "$tmp_otn" = "$opt_triangle_namespace" ]
            then
                cmd-echo -id "$cmd_echo_id" -w -- \
                    "--$option takes an upstream namespace specification," \
                    "not a full upstream repo specification." \
                    "We will use" \
                    "    $opt_triangle_namespace" \
                    "not" \
                    "    $tmp_otn"
            fi
            ;;
        wt | worktree | wtf | worktree-fetch )
            dispatch_to_real_git=0
            opt_worktree=1
            opt_worktree_name="${ovalue:-$1}"
            [ -z "$ovalue" ] && shift ## If ovalue is blank, we used $1
            if [[ "$opt_worktree_name" =~ ^- ]]
            then
                ## we got the next option, not an arg to this one
                cmd-echo -id "$cmd_echo_id" -e -- "Worktree name ($opt_worktree_name) cannot start with a '-'."
                exit 1

            fi
            if [[ "$option" =~ f ]]
            then
                opt_worktree_fetch='--fetch'
            fi

            ;;
        h | help )
            usage; exit 0 ;;
        debug | x )
            dispatch_to_real_git=0; set -x; add_on_exit set +x;;
        --)
            moreopts=0 ;;
        ##
        ## Options to pass onto real git clone
        ##
        l | s | q | n \
            | no-hardlinks \
            | bare \
            | mirror \
            | no-tags \
            | dissociate \
            | *single-branch \
            | *shallow-submodules \
            | quiet )
            ## Options that do not take args
            git_clone_opts+=("$option")
            ;;

        template \
            | o \
            | b \
            | u \
            | reference \
            | separate-git-dir \
            | depth \
            | jobs \
            | shallow-since)
            git_clone_opts+=("$option")
            ## Options taking mandatory args. If we don't have one with
            ## --foo=bar syntax, then we just assume the next arg is for this
            ## option and let the real 'git clone' sort it out.
            if [ -n "$ovalue" ]
            then
                ovalue="$1"
                shift
            fi
            git_clone_opts+=("$ovalue")
            ;;

        recurse-submodules )
            git_clone_opts+=("$original")
            ## Options taking optional args. If we don't have one with
            ## --foo=bar syntax, then we just take the next arg IFF it does not
            ## look like an option.
            if [ -z "$ovalue" ]
            then
                if [[ ! "$1" =~ ^- ]]
                then
                    ovalue="$1"
                    shift
                fi
            fi
            [ -n "$ovalue" ] && git_clone_opts+=("$ovalue")
            ;;
        * )
            cmd-echo -id "$cmd_echo_id" -e -- "$original is an invalid option. Also, we have disabled option ganging. See $0 --help"
            exit 1
    esac
done

if ((dispatch_to_real_git))
then
    ## There are no options specified that make us think we want to run our
    ## clone code; go run system git clone.
    "$REALGIT" clone "${orig_args[@]}"
    exit $?
fi

cmd-echo -- "Extended git clone functionality..."

[ -z "$1" ] && usage "Missing arguments" && exit 1

if [ -z "${githost}" ]
then
    declare -a tmpa
    asplit tmpa : "$1"
    if [ "${tmpa[0]}" = "$1" ]
    then
        cmd-echo -id "$cmd_echo_id" -e -- "githost specified and no 'githost:' found in '$1'"
        exit 1
    fi
    githost="${tmpa[0]}"
    namespace="${tmpa[1]}"
else
    namespace=$1
fi
shift

declare githost_url
githost_url="$(kvstore get gitfuncs_gitsvcs "$githost")"
if [ -z "$githost_url" ]
then
    cmd-echo -id "$cmd_echo_id" -- "$githost is unknown. Valid githosts are:$(kvstore vals gitfuncs_gitsvcs)"
    exit 1
fi

if [[ "$namespace" == */* ]]
then
    declare -a tmpa
    asplit tmpa / "$namespace"
    namespace=${tmpa[0]}
    repo=${tmpa[1]}
else
    repo=$1;shift
fi

declare cwpath
cwpath="$(realpath "$(pwd)")"
declare local_githost
local_githost="$(basename "$cwpath")"
if [ "$local_githost" != "$githost" ]
then
    if ((opt_use_githost_dir == 1))
    then
        cmd-echo -- "You must be in a directory path ending in"\
                    "   $githost" \
                    "You are in $cwpath"
        # gitfuncs_root set externally
        # shellcheck disable=SC2154
        declare shouldbein="$gitfuncs_gitroot/$githost"
        if [ ! -d "$shouldbein" ]
        then
            cmd-echo -e -- "Cannot find '$shouldbein'." "Correct and re-execute."
            exit 1
        else
            declare resp
            if ((opt_y))
            then
                cmd-echo -- "Going to $shouldbein"
                resp='y'
            else
                resp=$(cmd-yesno "cd to $shouldbein")
            fi
            if [ "$resp" = 'n' ]
            then
                cmd-echo -- "Correct and re-execute."
                exit 1
            else
                _git-cd-to "$shouldbein"
            fi
        fi
    else
        cmd-echo  -id "$cmd_echo_id" -- "Neither --githost nor --tree were specified. Cloning right here ($(pwd)/$repo)"
    fi
fi

declare tgt="$namespace/$repo"
if [ -e "$tgt" ]
then
    declare resp
    if ((opt_y))
    then
        resp='y'
        ##resp='r'
    else
        resp=$(cmd-yesno "'$tgt' exists. Will not clone over it. Remove it" n)
        ##resp=$(cmd-pick "'$tgt' exists. Will not clone over it. Remove it, keep it, abort" "r/k/a" "a")
    fi
    [ "$resp" = 'n' ] && exit 1
    rm -rf "$tgt"
    ##[ "$resp" = 'a' ] && exit 1
    ##[ "$resp" = 'r' ] && rm -rf "$tgt"
fi

if ((opt_make_fork))
then
    cmd-echo -- "github-api --server $githost --wait fork $opt_triangle_namespace $repo..."
    if ! github-api --server "$githost" --wait fork "$opt_triangle_namespace" "$repo"
    then
        exit $?
    fi
fi
cmd-echo -- "$REALGIT clone ${git_clone_opts[*]} ${githost_url}$namespace/$repo $namespace/$repo ..."
if ! $REALGIT clone "${git_clone_opts[@]}" "${githost_url}$namespace/$repo" "$namespace/$repo"
then
    exit $?
fi

(
    builtin cd "$namespace/$repo" || exit $?
    _git_clone_record_created_date
)

if ((opt_t))
then
    cmd-echo -- 'Setting timestamps...'
    (
        if builtin cd "$namespace/$repo"
        then
            git-retimestamp
        else
            cmd-echo -id "$cmd_echo_id" -e -- "Cannot cd $namespace/$repo" && return 1
        fi
    )
    cmd-echo -- 'Done'
fi

## dirlist, not builtin cd, to take advantage this cd enhancement
dirlist "$namespace/$repo"
if [ -n "$opt_triangle_namespace" ]
then
    cmd-echo -- "Setting up triangle workflow with ${githost_url}$opt_triangle_namespace/${repo}..."
    _git-clone-set-triangle "${githost_url}" "$opt_triangle_namespace" "$namespace" "$repo"
    git pull # To refresh from the upstream
else
    declare key='remote.origin.fetch'
    git config --replace-all $key "+refs/heads/*:refs/remotes/origin/*" || exit $?
    git config --add         $key "+refs/pull/*/head:refs/pull/origin/*" || exit $?
    ## ^ allows git checkout -b 3 pull/origin/3
fi
git remote -v

if ((opt_worktree))
then
    cmd-echo -- "Setting up for worktrees..."
    mkdir wt
    ls -ld "$(pwd)/wt"
fi

if ((opt_use_githost_dir))
then
    ## Add this repo to the list
    git-go-set
fi

if [ -n "$opt_worktree_name" ]
then
    git-go "$namespace/$repo"
    git worktree create $opt_worktree_fetch "$opt_worktree_name"
else
    if ((opt_use_githost_dir))
    then
        cmd-echo -- "Done. Execute" "    gitgo $namespace/$repo" "to use."
    else
        cmd-echo -- "Done."
        echo
    fi
fi

exit 0

## You can add sections with =head1, but stick to =item for section breakdowns,
## not =head2/3/etc/. If you want just plain text, get rid of pod tags and the
## 'POD' in __PODUSAGE__.

:<<'__PODUSAGE__'
=head1 NAME

git-clone - extension to git clone

=head1 SYNOPSIS

 git-clone [--tree] \
           [--forkof org] \
           [[--wt|--worktree] new-worktree [--fetch]] \
           [--yes|y] [--timestamp|-t] \
           repoURL

=head1 DESCRIPTION

Adds a few options to git clone. Without any of these options, just calls the real git clone. Otherwise, calls git clone with some additional actions.

B<Note:> We have disabled option ganging in order to be able to properly handle options being passed to the real 'git clone'; each single option requires its own '-'.

=head1 ARGUMENTS

=over 4

=item repoURL

The URL of the repo to clone in githost:org/repo format.

=back

=head1 OPTIONS

=over 4

=item --tree

Use the githost of the repoURL to determine where in the ~/gits tree to place this clone.

=item --fork org

Create a fork in your namespce of the same-named repo in the 'org' namespace, clone the fork locally, establish the 'origin' and 'upstream' remotes as the fork and the fork source, respectively. If the fork exists, we use it and continue.

=item --worktree new-worktree

Create a wt subdir, the requested worktree, a branch named 'new-worktree' and set it up as a tracking branch in the remote repo.

=item --fetch

Only used with --worktree, tries to fetch the existing remote branch 'new-worktree' instead of creating it  .

=item --yes

Answer yes to all prompts.

=item --timestamp

Read the git log of the repo and reset the timestamps on all the files to the date of the last commit of the file. Otherwise all files have the timestamp of when the repo is cloned.

=back

=cut

__PODUSAGE__
