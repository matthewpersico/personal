#!/usr/bin/env bash

# git-clone

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

if ! git-version-verify 'git-clone'
then
    exit 1
fi

cmd_echo_id='git-clone'

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        echo "** Extended actions **"
        bash-usage "$0"
        echo
        echo "** Standard actions **"
        "$REALGIT" clone --help
    ) 2>&1 | ${PAGER:-less}
}

_git_clone_record_created_date ()
{
    git config --replace-all extmeta.git-clone.created "$(date "$GIT_EXT_META_DATE_FMT")" || return $?
}

_git-clone-set-triangle()
{
    declare githost_url
    githost_url=$1
    declare githostkeycheck
    githostkeycheck=$( git kv --key-only --section svcs | grep -E "^$githost_url$")
    if [ -n "$githostkeycheck" ] ; then
        echo "Supposed to provide a URL, not a service name. Converting..."
        githost_url=$(git kv --get "svcs.githostkeycheck")
        if [ -z "$githost_url" ]
        then
            echo "No url found for githost '$1'";
            return 1
        fi
    fi
    declare upstream_namespace
    upstream_namespace=$2
    declare origin_namespace
    origin_namespace=$3
    declare repo
    repo=$4

    declare default_branch
    default_branch=$(git repo default-branch)

    declare -A triangle_workflow
    triangle_workflow[branch.${default_branch}.merge]="refs/heads/${default_branch}"
    triangle_workflow[branch.${default_branch}.mergeoptions]="--ff-only"
    triangle_workflow[branch.${default_branch}.remote]="upstream"

    triangle_workflow[remote.origin.url]="${githost_url}${origin_namespace}/${repo}"
    triangle_workflow[remote.pushdefault]="origin"
    triangle_workflow[remote.upstream.url]="${githost_url}${upstream_namespace}/${repo}"

    declare key
    for key in "${!triangle_workflow[@]}"
    do
        git config --replace-all "$key" "${triangle_workflow[$key]}" || return $?
    done

    ##
    ## These are special because they repeat
    ##
    key='remote.origin.fetch'

    git config --replace-all $key "+refs/heads/*:refs/remotes/origin/*" || return $?
    git config --add         $key "+refs/pull/*/head:refs/pull/origin/*" || return $?
    ## ^ allows git checkout -b 3 pull/origin/3

    key='remote.upstream.fetch'
    git config --replace-all $key "+refs/heads/*:refs/remotes/upstream/*" || return $?
    git config --add         $key "+refs/pull/*/head:refs/pull/upstream/*" || return $?
    git config --add         $key "+refs/notes/*:refs/notes/*" || return $?
    ## ^ allows git checkout -b 3 pull/upstream/3

    ## Our own metadata
    git config --replace-all extmeta.git-clone.triangle-remote "${upstream_namespace}" || return $?

    return 0
}

main ()
{
    declare opt_y=0
    declare opt_t=0
    declare opt_triangle_namespace=''
    declare opt_worktree=1
    declare opt_worktree_name=''
    declare opt_worktree_fetch=''
    declare opt_use_githost_dir=0
    declare opt_make_fork=0
    declare opt_make_triangle=0
    declare dispatch_to_real_git=1
    declare githost
    declare namespace
    declare repo
    declare doandcdfile

    ## --------
    ## DO NOT attempt to convert this to a 'getopt' implementation; it would
    ## require specifying and handling every existing option in 'git clone'
    ## and it is just not necessary.
    declare -a pass_on

    while (( $# ))
    do
        declare option=$1
        shift ## That way you avoid endless loops on invalid options.

        ## This bit deals with --foo=bar instead of --foo bar...
        declare okey
        declare ovalue=''
        ## but only deal with it if we really have an option. Otherwise you
        ## misinterpret items like this git clone option: --config
        ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
        if [[ $option =~ ^- ]]
        then
            if [[ "$option" =~ = ]]
            then
                okey=${option%%=*}
                ovalue=${option#*=}
                option="$okey"
            fi
        fi
        case $option in
            ##
            ## Our options
            ##
            --doandcd )
                doandcdfile=${ovalue:-$1}
                [ -z "$ovalue" ] && shift ## If ovalue is blank, we used $1
                ;;
            --tree )
                dispatch_to_real_git=0
                opt_use_githost_dir=1;;
            -y | --yes )
                dispatch_to_real_git=0; opt_y=1;;
            -t | --timestamp )
                dispatch_to_real_git=0; opt_t=1;;
            --triangle )
                dispatch_to_real_git=0
                opt_make_triangle=1;;
            --fo | --forkof )
                opt_make_fork=1
                dispatch_to_real_git=0
                declare tmp_otn=${ovalue:-$1}
                [ -z "$ovalue" ] && shift ## If ovalue is blank, we used $1
                if [[ "$tmp_otn" =~ ^- ]]
                then
                    ## we got the next option, not an arg to this one
                    cmd-echo -id "$cmd_echo_id" -e -- "Fork org ($tmp_otn) cannot start with a '-'."
                    return 1
                fi
                opt_triangle_namespace=${tmp_otn%/*}
                if [ ! "$tmp_otn" = "$opt_triangle_namespace" ]
                then
                    cmd-echo -id "$cmd_echo_id" -w -- \
                             "--$option takes an upstream namespace specification," \
                             "not a full upstream repo specification." \
                             "We will use" \
                             "    $opt_triangle_namespace" \
                             "not" \
                             "    $tmp_otn"
                fi
                ;;
            --wt | --worktree | --wtf | --worktree-fetch )
                dispatch_to_real_git=0
                opt_worktree=1
                opt_worktree_name="${ovalue:-$1}"
                [ -z "$ovalue" ] && shift ## If ovalue is blank, we used $1
                if [[ "$opt_worktree_name" =~ ^- ]]
                then
                    ## we got the next option, not an arg to this one
                    cmd-echo -id "$cmd_echo_id" -e -- "Worktree name ($opt_worktree_name) cannot start with a '-'."
                    return 1
                fi
                if [[ "$option" =~ f ]]
                then
                    opt_worktree_fetch='--fetch'
                fi
                ;;
            --help | -h )
                usage; return 0 ;;
            --debug | -x )
                dispatch_to_real_git=0; set -x; do-on-exit set +x;;
            * )
                ## Eventually, you call the real command with "${pass_on[@]}"
                pass_on+=("$option");
                [ -n "$ovalue" ] && pass_on+=("$ovalue")
                ;;
        esac
    done

    if ((dispatch_to_real_git))
    then
        ## There are no options specified that make us think we want to run our
        ## clone code; go run system git clone.
        "$REALGIT" clone "${pass_on[@]}"
        return $?
    fi

    cmd-echo -- "Extended git clone functionality..."
    if ((opt_make_fork)) && ((opt_make_triangle))
    then
        cmd-echo --wc -- "Option '--triangle' ignored with option '--fork-of'; the latter implies the former."
        opt_make_triangle=0
    fi

    [ -z "${pass_on[0]}" ] && usage "Missing arguments" && return 1

    if [ -z "${githost}" ]
    then
        declare -a tmpa
        asplit "${pass_on[0]}" -s : -a tmpa
        if [ "${tmpa[0]}" = "${pass_on[0]}" ]
        then
            cmd-echo -id "$cmd_echo_id" -e -- "githost specified and no 'githost:' found in '${pass_on[0]}'"
            return 1
        fi
        githost="${tmpa[0]}"
        namespace="${tmpa[1]}"
    else
        namespace=${pass_on[0]}
    fi
    ashift pass_on

    declare githost_url
    githost_url="$(git kv --get "urls.${githost}")"
    if [ -z "$githost_url" ]
    then
        cmd-echo -id "$cmd_echo_id" -- "$githost is unknown. Valid githosts are:$(git kv --key-only --section svcs)"
        return 1
    fi
    if [[ "$namespace" == */* ]]
    then
        declare -a tmpa
        asplit "$namespace" -s / -a tmpa
        namespace=${tmpa[0]}
        repo=${tmpa[1]}
    else
        ashift pass_on repo
    fi

    if [[ -z $namespace ]] || [[ -z $repo ]]
    then
        cmd-echo -id "$cmd_echo_id" -e -- "Missing one or both of namespace and repo args."
        return 1
    fi

    declare cwpath
    cwpath="$(realpath "${PWD}")"
    declare local_githost
    local_githost="$(basename "$cwpath")"
    if [ "$local_githost" != "$githost" ] && ((opt_use_githost_dir == 1))
    then
        cmd-echo -- "You must be in a directory path ending in"\
                 "   $githost" \
                 "You are in $cwpath"
        declare shouldbein
        shouldbein="$(git config --get --expand git-repo-root.root)/$githost"
        if [ ! -d "$shouldbein" ]
        then
            cmd-echo -ec -- "Cannot find '$shouldbein'." "Correct and re-execute."
            return 1
        else
            cmd-echo -- "Going to $shouldbein"
            builtin cd "$shouldbein" || exit $?
        fi
    else
        cmd-echo -id "$cmd_echo_id" -- "Neither --githost nor --tree were specified. Cloning right here (${PWD}/$repo)"
    fi

    declare tgt="$namespace/$repo"
    if [ -e "$tgt" ]
    then
        declare resp
        if ((opt_y))
        then
            resp='y'
            ##resp='r'
        else
            resp=$(cmd-yesno "'$tgt' exists. Will not clone over it. Remove it" n)
        fi
        if [ "$resp" = 'n' ]
        then
            cmd-echo -- "Keeping."
            if ((opt_use_githost_dir))
            then
                if [ -n "$doandcdfile" ]
                then
                    cmd-echo -c -- " Going to $namespace/$repo..."
                    echo "git go $namespace/$repo" > "$doandcdfile"
                else
                    cmd-echo -c -- " Execute" "    git go $namespace/$repo" "to use."
                fi
            else
                echo
            fi
            return 0
        else
            rm -rf "$tgt"
        fi
    fi

    if ((opt_make_fork))
    then
        ## Then try to make a fork of the repo from the upstream org
        ## supplied. If the fork exists, no harm no foul; we just continue on
        ## with what we found.
        cmd-echo -- "github-api --server $githost --data-mode --wait fork $opt_triangle_namespace $repo..."
        declare forked_repo
        forked_repo=$(github-api --server "$githost" --data-mode --wait fork "$opt_triangle_namespace" "$repo")
        declare dq="$?"
        if [[ $dq != '0' ]]
        then
            return $?
        fi
        if [[ $forked_repo != "$repo" ]]
        then
            cmd-echo -wc -- "Forked repo of $repo is named $forked_repo. Will use $forked_repo going forward."
            repo="$forked_repo"
            tgt="$namespace/$repo"
            if [ -e "$tgt" ]
            then
                declare resp
                if ((opt_y))
                then
                    resp='y'
                    ##resp='r'
                else
                    resp=$(cmd-yesno "'$tgt' exists. Will not clone over it. Remove it" n)
                fi
                if [ "$resp" = 'n' ]
                then
                    cmd-echo -n -- "Keeping."
                    if ((opt_use_githost_dir))
                    then
                        if [ -n "$doandcdfile" ]
                        then
                            cmd-echo -c -- " Going to $namespace/$repo..."
                            echo "git go $namespace/$repo" > "$doandcdfile"
                        else
                            cmd-echo -c -- " Execute" "    git go $namespace/$repo" "to use."
                        fi
                    else
                        echo
                    fi
                    return 1
                else
                    rm -rf "$tgt"
                fi
            fi
        fi
    fi

    ## Do the clone
    cmd-echo -- "$REALGIT clone ${pass_on[*]} ${githost_url}$namespace/$repo $namespace/$repo ..."
    if ! $REALGIT clone "${pass_on[@]}" "${githost_url}$namespace/$repo" "$namespace/$repo"
    then
        return $?
    fi

    ## Our own metadata
    (
        builtin cd "$namespace/$repo" || exit $?
        _git_clone_record_created_date
    )

    if ((opt_t))
    then
        cmd-echo -- 'Setting timestamps...'
        (
            if builtin cd "$namespace/$repo"
            then
                git-retimestamp
            else
                cmd-echo -id "$cmd_echo_id" -e -- "Cannot cd $namespace/$repo" && return 1
            fi
        )
        cmd-echo -- 'Done'
    fi

    if ((opt_make_triangle))
    then
        ## If we didn't explicitly ask to make a fork, let's see if this clone
        ## is a fork anyway and set up the triangle workflow if so.
        declare upstream
        upstream=$(builtin cd "$namespace/$repo" || exit $?
                   git repo is a fork --print)
        if [[ -n $upstream ]]
        then
            cmd-echo -- "$namespace/$repo is a fork of $upstream"
            opt_triangle_namespace=$(dirname "$upstream")
        fi
    fi

    ## dirlist, not builtin cd, to take advantage this cd enhancement
    dirlist "$namespace/$repo"
    if [ -n "$opt_triangle_namespace" ]
    then
        cmd-echo -- "Setting up triangle workflow with ${githost_url}${opt_triangle_namespace}/${repo}..."
        _git-clone-set-triangle "${githost_url}" "$opt_triangle_namespace" "$namespace" "$repo" || return $?
        git pull || return $? # To refresh from the upstream
    else
        declare key='remote.origin.fetch'
        git config --replace-all $key "+refs/heads/*:refs/remotes/origin/*" || return $?
        git config --add         $key "+refs/pull/*/head:refs/pull/origin/*" || return $?
        ## ^ allows git checkout -b 3 pull/origin/3
    fi
    set +x
    git remote -v

    if ((opt_worktree))
    then
        cmd-echo -- "Setting up for worktrees..."
        mkdir wt
        ls -ld "${PWD}/wt"
    fi

    if ((opt_use_githost_dir))
    then
        ## Add this repo to the list
        git-go-set
    fi

    if [ -n "$opt_worktree_name" ]
    then
        git go "$namespace/$repo"
        git worktree create $opt_worktree_fetch "$opt_worktree_name"
    else
        if ((!opt_use_githost_dir))
        then
            cmd-echo -- \
                     "Done. Execute" \
                     "    git go $namespace/$repo" \
                     "to use."
        else
            [ -n "$doandcdfile" ] && echo "go ${PWD}" > "$doandcdfile"
            cmd-echo -- "Done."
        fi
    fi
}

main "$@"
exit $?

## You can add sections with =head1, but stick to =item for section breakdowns,
## not =head2/3/etc/. If you want just plain text, get rid of pod tags and the
## 'POD' in __PODUSAGE__.

:<<'__PODUSAGE__'
=head1 NAME

git-clone - extension to git clone

=head1 SYNOPSIS

 git-clone [--tree] \
           [--forkof org] \
           [[--wt|--worktree] new-worktree [--fetch]] \
           [--yes|y] [--timestamp|-t] \
           repoURL

=head1 DESCRIPTION2

Adds a few options to git clone. Without any of these options, just calls the real git clone. Otherwise, calls git clone with some additional actions.

B<Note:> We have disabled option ganging in order to be able to properly handle options being passed to the real 'git clone'; each single option requires its own '-'.

=head1 ARGUMENTS

=over 4

=item repoURL

The URL of the repo to clone in githost:org/repo format.

=back

=head1 OPTIONS

=over 4

=item --tree

Use the githost of the repoURL to determine where in the ~/gits tree to place this clone.

=item --fork org

Create a repo in your namespce that is a form of the same-named repo in the 'org' namespace. Clone the fork locally. Establish the 'origin' and 'upstream' remotes as the fork and the fork source, respectively. If the fork exists, we use it and continue.

=item --worktree new-worktree

Create a wt subdir, the requested worktree, a branch named 'new-worktree' and set it up as a tracking branch in the remote repo.

=item --fetch

Only used with --worktree, tries to fetch the existing remote branch 'new-worktree' instead of creating it  .

=item --yes

Answer yes to all prompts.

=item --timestamp

Read the git log of the repo and reset the timestamps on all the files to the date of the last commit of the file. Otherwise all files have the timestamp of when the repo is cloned.

=back

=cut

__PODUSAGE__
