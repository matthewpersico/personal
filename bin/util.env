#!/usr/bin/env bash

# util.env

## 0-as-success is the correct way to return from commands and functions in
## UNIX so that the typical 0-success-from-UNIX-commands paradigm "just works"
## in statements like the following (assuming xxx is some program exiting 0 or
## function returning 0):
##
##    xxx && echo xxx worked
##
## What you CAN'T do are these
##    if [ xxx ]       ## won't execute
##    if [ $(xxx) ]    ## the value that [] sees is the output from stdout
##
## What you CAN do is this
##    if xxx; then...
##
## However, to allow older code to continue to work, we keep the following
## definition:
##
TRUE=$(true;echo $?)
export TRUE
##
## so that you can use
##    xxx; if [ "$?" = "${TRUE}" ]
##
## Now, we also define
##
FALSE=$(false;echo $?)
export FALSE
##
## but since that's only a single value, you are probably better off using
##    xxx; if [ ! "$?" = "${TRUE}" ]
## instead.
##
## Remember when you were told in CS 101 not to assume that logic values were
## integers and not to mix logic evals with math? :-)
##
## The easiest way to enforce this is to return $(true) and $(false) instead of
## 0 and 1 from functions.
##
## And we should ALWAYS use SOME value when returning; do not use naked
## returns, which usually happens when return is used to bail early from a deep
## control structure. Do not depend on the return value of the last command
## executed; return it explicitly or return $(true) if you don't care.
##

## These make checking function returns read more naturally.
OK=$TRUE
export OK
NOT_OK=$FALSE
export NOT_OK
NOOK=$FALSE
export NOOK
NOK=$FALSE
export NOK

###################
## Interactivity ##
###################
STDIN=0;export STDIN
STDOUT=1;export STDOUT
STDERR=2;export STDERR

##########################
## Bash array functions
## References and notes:
##
## http://www.tech-recipes.com/rx/911/queue-and-stack-using-array/
## http://stackoverflow.com/questions/12691121/bash-array-expansion-using-variable-indirection-expansion
## http://stackoverflow.com/questions/23819839/assign-to-a-bash-array-variable-indirectly-by-dynamically-constructed-variable
##     bash 4.3+: use declare -n to effectively create an alias ('nameref') of another variable
########################################

########################################
## Bash hash (assoc. array) functions
## References and notes:
##
## The perl loop
##    foreach (my ($k,$v) = each(%hash)) { ...
## can be had in shell with
##    heach hash | while read -r k v; do...
########################################

## includes (source) for bash
BASH_INC_DIR=$PERSONALBIN; export BASH_INC_DIR

## Guard variable
UTILENV_LOADED=1
export UTILENV_LOADED
