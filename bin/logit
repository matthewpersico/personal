#!/usr/bin/env bash
#
# logit
#

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

# Inits
declare logfile=''
declare logdir=''
declare teeit=0
declare zenityit=0
declare teeit=0
declare tsit=0
declare edit=''
declare edit_echo=''
declare edit_on_fail=''
declare purge=''
declare notimestamp=''
declare attime=''
declare isat=0
declare -a noctrlfilter=(cat)
declare opt_logonly=0

declare -a original_argv
original_argv+=("$0" "$@")

# Read the options and args from command line. Note that the long and short
# don't have to match up.
declare OPTSARGS
declare shortopts='k'
declare longopts='isat,at:,tee,zenity,log:,dir:,edit,edit-on-fail,edit-echo,purge,purgeprior,notimestamp,tpe,ts,help,logonly'

# Process the command line.
OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@")
declare status=$?
if ((status != 0))
then
    cmd-echo -ec -- \
             "If the error was" \
             "     logit: unrecognized option..." \
             "then logit read an option to your program" \
             "as its own. Add -- as the last logit option" \
             "right before your command." \
             "Exiting."
    exit $status
fi

# Reset the command line ($@).
eval set -- "$OPTSARGS"
declare opts_count=0

# Reprocess the command line, extracting options and their arguments into
# variables.
while true
do
    declare option=$1
    shift
    [ "$option" != '--' ] && option=${option##-} && option=${option##-}
    case "$option" in
        at )
            if ((opts_count))
            then
                echo "--at must be first option"
                exit 1
            fi
            attime="$1"
            shift
            atfile=$(mktemp -t tmp.logit.at.XXXXXXXXXX)
            echo "logit --isat $*" > "$atfile"
            chmod +x "$atfile"
            at -f "$atfile" "$attime"
            exit 0
            ;;
        logonly )
            opt_logonly=1
            ;;
        isat)
            isat=1
            ;;
        h|help)
            set -x
            bash-usage "$0"; exit 0 ;;
        log)
            logfile="$1"
            shift ;;
        dir)
            logdir="$1"
            shift ;;
        tee)
            teeit=1
            ;;
        zenity)
            zenityit=1
            ;;
        edit-echo)
            edit_echo=1
            ;& ## unconditional dropthrough
        edit)
            edit="$LOGIT_EDITOR"
            [ -z "$edit" ] && edit="$EDITOR"
            ;;
        edit-on-fail)
            edit_on_fail="$LOGIT_EDITOR"
            [ -z "$edit_on_fail" ] && edit_on_fail="$EDITOR"
            ;;
        purge)
            purge=all
            ;;
        purgeprior)
            purge=prior
            ;;
        notimestamp)
            notimestamp=1
            ;;
        noctrl)
            noctrlfilter=(tr -cd '\11\12\40-\176')
            ;;
        tpe)
            teeit=1
            purge=all
            edit="$LOGIT_EDITOR"
            [ -z "$edit" ] && edit="$EDITOR"
            ;;
        tpef)
            teeit=1
            purge=all
            edit_on_fail="$LOGIT_EDITOR"
            [ -z "$edit_on_fail" ] && edit_on_fail="$EDITOR"
            ;;
        ts)
            tsit=1
            shift ;;
        --) break ;; ## VITAL!!! Exits the while loop, no more options,
                     ## remaining $*, if any, are args
        *)
            cmd-echo -ec -- "$option is an invalid option; you probably forgot to add a -- option between the logit options and the command to run. See $0 --help"
            exit 1 ;;
    esac
done

if ((isat)) \
       && { (( teeit+zenityit )) \
                || \
                [ -n "${edit}${edit_on_fail}" ]; }
then
    echo "Cannot use --at with any of --teeit, --zenityit, --edit, --edit_on_fail"
    bash-usage "$0"; exit 1
fi

# Arg checking
if [ -z "$1" ]
then
    echo "Command required."
    bash-usage "$0"; exit 1
fi

before_command=1
after_command=0
declare -a envs
command=''
declare -a cmdargs

for arg in "$@"
do
    if [[ "$arg" =~ = ]] && ((before_command))
    then
        envs+=("$arg")
    else
        before_command=0
        if ((after_command))
        then
            cmdargs+=("$arg")
        else
            command="$arg"
            after_command=1
        fi
    fi
done

if [ ! -x "$command" ]
then
    fullcommand=$(type -P "$command" 2>/dev/null)
    if [ -z "$fullcommand" ]
    then
        isafunc=$(type -t "$command")
        if [ "$isafunc" != "function" ]
        then
            echo "'$command' is not a function or not found or not executable."
            bash-usage "$0"; exit 1
        fi
    fi
fi

# Log file setup
[ -z "$logfile" ] && logfile=$(basename "$command")
logfileroot="${logfile}.logit"
now=$(date +%Y_%m_%dT%H_%M_%S)
logfile="${logfileroot}"
if [ "$notimestamp" = '' ]
then
    logfile="${logfile}.${now}.$$"
fi
today=${now%%T*}

if [ -z "$logdir" ]
then
    if [[ $logfile =~ / ]]
    then
        logdir=$(dirname "$logfile")
        logfile=$(basename "$logfile")
    else
        logdir=${PWD}
        [ -d ./logit ] && logdir=${PWD}/logit
    fi
fi

logspec="$logdir/$logfile"
logspecroot="$logdir/$logfileroot"
if [ -n "$purge" ]
then
    if [ "$purge" = 'all' ]
    then
        echo "Purging ${logspecroot}*"
        rm -f "${logspecroot}"*
    else
        ## prior day
        echo "Purging ${logspecroot}*, keeping $today"
        declare rmlist
        # shellcheck disable=SC2010 ## Yeah, yeah ls|grep is bad. It's also simple.
        rmlist=$(ls "${logspecroot}"* 2>/dev/null | grep -v "logit.${today}")
        [ -n "$rmlist" ] && rm -f "$rmlist"
    fi
fi

touch "$logspec" ## Critical for tee below
logmsg="Logfile is: $logspec"
if ((! isat))
then
    echo "$logmsg"
    echo "Working..."
fi

if ((opt_logonly))
then
    echo '--logonly specified. Run these commands:'
    # shellcheck disable=SC2016 #https://github.com/koalaman/shellcheck/wiki/SC2016
    echo "${envs[*]} $command ${cmdargs[*]}" '2>&1 | tee ' "$logspec"
    exit 0
fi

if ((teeit || zenityit))
then
    declare termer=''

    declare -a terms
    ((zenityit)) && terms+=('zenity')
    terms+=(xterm rxvt mrxvt)
    for i in "${terms[@]}"
    do
        # shellcheck disable=SC2230
        [ -z "$termer" ] && [ -n "$(type -P "$i" 2>/dev/null)" ] && termer=$(type -P "$i")
    done

    termheight=$(x-current-root --height)
    if ((termheight >1024)); then termheight=40; else termheight=20; fi

    declare -a colors
    if [[ $termer =~ xterm ]]
    then
         if type -P xterm_Xground 2>/dev/null 1>/dev/null
         then
             colors=('-fg' "$(xterm_foreground)" '-bg' "$(xterm_background)")
         fi
    fi

    declare title
    title="logit tee of '$command ${cmdargs[*]}' on $(hostname)"
    if [[ $termer =~ zenity ]]
    then
        tail -f "$logspec" | \
            $termer --text-info --auto-scroll \
                    --width=1320 --height=800 \
                    --title "$title [log is $logspec]" \
            &
    else
        $termer -g 132x${termheight}+100+100 \
                -title "$title [log is $logspec]" \
                "${colors[@]}" \
                -e tail -f "$logspec" \
            &
    fi
    sleep 2 ## Give the $termer a chance to come up and start tailing so we
            ## see the whole log in the tail

    tailpid=$(pstree | grep "$logspec" | grep 'tail -f' | grep -v "$termer" | perl -an -e 'for(@F){/[0-9]+/ && do {print $_; exit}}')
    termerpid=$(pstree | grep "$termer" | grep "$logspec" | perl -an -e 'for(@F){/[0-9]+/ && do {print $_; exit}}')
    if [[ $termer =~ zenity ]]
    then
        ## Ending the zenity process doesn't end the tail and exiting this
        ## program doesn't end the tail either. We must arrange for it to
        ## explicitly end when this program exits. Otherwise, the tails pile up
        ## in the process table. Also make sure that we flush the log and wait
        ## before we kill that tail so that all the output ends up in the log.
        do-on-exit "echo >> $logspec;sleep 2;kill $tailpid"
    fi
fi

(
    echo "********************"
    echo "  logit invocation"
    echo "********************"
    echo "${original_argv[@]}"
    echo

    echo "********************"
    echo "     log file"
    echo "********************"
    echo "$logspec"
    echo

    if [ -n "$(git rev-parse --git-dir 2>/dev/null)" ]
    then
        echo "********************"
        echo "      git info"
        echo "********************"
        echo
        echo "Latest log entry:"
        git log -1
        echo
        echo "Status:"
        git status
        echo

        tmpf=$(mktemp -t tmp.logit.XXXXXXXXXX)
        rm-on-exit "$tmpf"
        git stash list >"$tmpf" 2>&1
        if [ -s "$tmpf" ]
        then
            echo "Stashes:"
            cat "$tmpf"
            echo
        fi
    fi

    echo "********************"
    echo "        cwd"
    echo "********************"
    pwd
    echo

    echo "********************"
    echo "      command"
    echo "********************"
    echo "${envs[*]} $command ${cmdargs[*]}"
    echo

    echo "********************"
    echo "     execution"
    echo "start time: $(date)"
    eval "${envs[@]}"
    echo "********************"
    ##) >> "$logspec" 2>&1

    if((tsit))
    then
        $command "${cmdargs[@]}" | perl -pe 'use POSIX strftime; use Time::HiRes gettimeofday;
                    $|=1;
                    select((select(STDERR), $| = 1)[0]);
                    ($s,$ms)=gettimeofday();
                    $ms=substr(q(000000) . $ms,-6);
                    print strftime "[%Y-%m-%d %H:%M:%S.$ms]", localtime($s)' ##>> "$logspec" 2>&1
    else
        $command "${cmdargs[@]}" ##>> "$logspec" 2>&1
    fi
    status=${PIPESTATUS[0]}

##(
    echo "********************"
    echo "$logmsg"
    echo "exit status: $status"
    echo "end time: $(date)"
    echo "********************"
    exit "$status"
    ###) | "${noctrlfilter[@]}" >> "$logspec" 2>&1
) >> "$logspec" 2>&1
status=$?
if (( !isat))
then
    echo "$logmsg"
    echo "Exit status: $status"
fi

declare -a editcmd
if [ -n "$edit" ]
then
    read -r -a editcmd < <(echo "$edit")
elif [ ! "$status" = '0' ] && [ -n "$edit_on_fail" ]
then
    read -r -a editcmd < <(echo "$edit_on_fail")
fi

if [[ "${editcmd[0]}" =~ emacs\  ]]
then
    width=$(perl -n -e 'length($_)>$x and $x=length($_);END{print $x}' "$logspec");
    lineheight=$(( ($(x-current-root --height)-100) / 30 ))
    logheight=$(wc -l < "$logspec")
    if (( lineheight <= logheight ))
    then
        height=$lineheight
    else
        height=$logheight
    fi
    editcmd+=('-g' "${width}x${height}+100+100")
fi
if [ -n "${editcmd[0]}" ]
then
    if [ -n "$edit_echo" ]
    then
        echo "${editcmd[@]}" "$logspec"
    else
        "${editcmd[@]}" "$logspec" &
        [ -n "$tailpid" ] && kill "$tailpid"
        [ -n "$termerpid" ] && kill "$termerpid"
    fi
fi
exit $status

:<<'__USAGE__'
[FOO=BAR [ FOO2=BAR2... ] ] \\
logit [--at time] \\
      [ --tee | --zenity ] \\
      [ --log log_basename ] \\
      [ --notimestamp ] \\
      [ --noctrl ] \\
      [ --dir log_directory ] \\
      [ [--edit ] || [ --edit-echo ] || [ --edit-on-fail ]] \\
      [ --purge | --purgeprior ] \\
      [ --tpe[f] ] \\
      [ --ts ] \\
      [ -- ] \\
      command [arg ..]

logit [ --help | -h ]

Capture all the output of the command and some information about the executing
environment into a log file.

Tip: For command

  logit somecommand --options args

you can use 'nohup' and backgrounding (&) to execute it so that exiting the
terminal you started the command with does not kill your command:

  nohup logit somecommand --options args &

OPTIONS:
      --at     - Run the command on an 'at' queue at the
                 specified time. '--at' must be the first option,
                 if specified.

      --tee    - Spin up a terminal and show the log
                 output in it as it is generated.

      --zenity - Spin up a zenity text dialog and show the log
                 output in it as it is generated. If zenity
                 is not available, we fall back to --tee.

      --log    - Provide a root name for the log if
                 the command is generic.

      --notimestamp
               - Do not add a timestamp or the pid of the logit process to the
                 log name.  Use if the log name provided by --log is unique or
                 you don't care about overwriting logs.

      --noctrl
               - Filter out all the coloring and other control characters. Makes
                 a log easier to read after the fact.

      --dir    - Put the logs in specifed directory. If not
                 specfied, logs will be placed in the './logit' subdir,
                 if it exists. Otherwise, logs will be placed in the current
                 directory.

      --edit   - Look for \$LOGIT_EDITOR (\$LOGIT_EDITOR), then
                 \$EDITOR ($EDITOR). Run the first one found in order
                 to edit log file when the command exits.

      --edit-echo -
                 Look for \$LOGIT_EDITOR (\$LOGIT_EDITOR), then
                 \$EDITOR ($EDITOR). Echo the command that would have
                 been generated for --edit. This allows you to decide
                 whether or not to edit the log.

      --edit-on-fail -
                 Look for \$LOGIT_EDITOR (\$LOGIT_EDITOR), then
                 \$EDITOR ($EDITOR). Run the first one found in order
                 to edit the log file if the command fails.

      --purge  - Remove all similarly named log files before
                 running the command.

      --purgeprior -
                 Remove all similarly named log files before
                 running the command, but keep those with
                 today's date in the log name.

      --tpe[f]   - A shortcut for --tee --purge --edit, the three most
                 commonly used switches. Adding the 'f' makes it
                 behave as if --edit-on-fail was set instead of --edit.

      --ts     - Use the 'ts' command to prepend a time stamp to each
                 output line.

      --       - Ends options to logit. Command and its options
                 follow. Only needed if one or more logit options
                 are specified.

      --help   - show this text.

      FOO=BAR  - Any environment variables you want to set before
                 running your command should be set before calling
                 logit.

__USAGE__
