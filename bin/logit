# -*- sh -*-

#
# logit
#

# Take args, treat as a command + args and run all output to a file.

usage ()
{
    cat <<EOUSAGE
logit [ --tee | -t ] \\
      [ --log | -l log_basename ] \\
      [ --dir | -d log_directory ] \\
      [ --edit | -e ] [ --purge | -p ] \\
      [ -- ] \\
      command [arg ..]

logit [ --help | -h ]

      --tee   - Spin up a terminal and show the log
                output in it as it is generated.

      --log   - Provide a name for the log if the command is
                generic.

      --dir   - Put the logs in specifed directory, not
                current working directory. If not specified
                and there is a 'logit' subdir of the current
                working directory, logs will be placed in './logit'.

      --edit  - Run $EDITOR on the log file when complete.

      --purge - Remove all similarly named log files before
                running the command.

      --      - Ends options to logit. Command and its options
                follow. Only needed if one or more logit options
                are specified.

      --help  - show this text.
EOUSAGE
    exit $1
}

# Inits
logfile=''
logdir=''
teeit=0
edit=0
purge=0

# Read the options and args from command line.
GETOPTOUT=`getopt -o h -l tee,log:,dir:,edit,purge,help -n 'logit' -- "$@"`

# Reset the command line.
eval set -- "$GETOPTOUT"

# Reprocess the command line, extracting options and their arguments into
# variables.
while true ; do
    case "$1" in
        -h|--help)
            usage 0 ;;
        --log)
            logfile="$2"
            shift 2 ;;
        --dir)
            logdir="$2"
            shift 2 ;;
        --tee)
            teeit=1
            shift ;;
        --edit)
            edit=1
            shift ;;
        --purge)
            purge=1
            shift ;;
        --) shift ; break ;; ## VITAL!!! Exits the while loop, no more options
        *) echo "Internal error!" ; usage 1 ;;
    esac
done

# Arg checking
if [ -z "$1" ]
then
    echo "Command required."
    usage 1
fi

command=$1
shift
args="$@"

if [ ! -x $command ]
then
    fullcommand=$(which $command 2>/dev/null)
    if [ -z "$fullcommand" ]
    then
        isafunc=$(type $command | head -1)
        if [ "$isafunc" != "$command is a function" ]
        then
            echo "'$command' is not a function or not found or not executable."
            usage 1
        fi
    fi
fi

# Log file setup
if [ -z "$logfile" ]
then
    logfile=$(basename $command)
fi
logfileroot="${logfile}.logit"
logfile="${logfile}.logit.$(date +%Y_%m_%d_%H_%M_%S)"

if [ -z "$logdir" ]
then
    logdir=$(pwd)
    if [ -d ./logit ]
    then
        logdir=$(pwd)/logit
    fi
fi

logspec="$logdir/$logfile"
logspecroot="$logdir/$logfileroot"
if (( purge ))
then
    echo "Purging ${logspecroot}*"
    rm -f ${logspecroot}*
fi

touch $logspec ## Critical for tee below
logmsg="Logfile is: $logspec"
echo $logmsg

# And off we go...
echo "Working..."

if ((teeit))
then
    termer=''
    for i in xterm rxvt mrxvt
    do
        if [ -z "$termer" ] && [ -n "$(which $i 2>/dev/null)" ]
        then
            termer=$(which $i)
        fi
    done
    $termer -g 132x40 -e tail -f $logspec &
    sleep 2 ## Give the terminal a chance to come up and start tailing so we
            ## see the whole log in the tali
fi

(
    if [ -n "$(git rev-parse --git-dir 2>/dev/null)" ]
    then
        echo "********************"
        echo "      git info      "
        echo "********************"
        git log -1
        git status
        echo
    fi

    echo "********************"
    echo "      Command       "
    echo "********************"
    echo $command $args
    echo

    echo "********************"
    echo "       Output       "
    echo "********************"
    $command $args
    status=$?
    echo

    echo "********************"
    echo $logmsg
    echo "Exit status: $status"
    echo "********************"
    exit $status
) >> $logspec 2>&1
status=$?
echo "$logmsg"
echo "Exit status: $status"

if ((edit))
then
    $EDITOR $logspec &
fi

exit $status
