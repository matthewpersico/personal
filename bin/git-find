#!/usr/bin/env bash

echo "$(date): git-find" >> "$HOME/.gitaudit"

# git-find

# shellcheck disable=SC2034
declare DEBUG__this_script=$0

declare opt_untracked_only=0
declare opt_all=0
declare opt_conflicts=0
declare opt_deleted=0
declare opt_last_existed=0
declare opt_git_dir=0
declare -a opt_grep_opts=("-E")
declare opt_grep_opts_verbose=''
declare -a opt_grep_opts_exclude
declare opt_edit=0
declare opt_abspath=0
declare opt_ls=0
declare opt_files_only=0
declare timecompfile=''
declare timecomp=''
declare moreopts=1
while [[ "$1" =~ ^- ]] && ((moreopts))
do
    declare original="$1"
    option=$(dashstripper "$original")
    shift

    case $option in
        i ) opt_grep_opts+=(-"$option");;
        l | n ) opt_grep_opts_verbose=-"$option";;
        e | edit) opt_edit=1;;
        x ) opt_grep_opts_exclude+=('-x' "$1"); shift;;
        untracked_only|u) opt_untracked_only=1;;
        all|a) opt_all=1;;
        conflict*) opt_conflicts=1;;
        deleted) opt_deleted=1;;
        last-existed) opt_last_existed=1;;
        git-dir) opt_git_dir=1;;
        h|help) bash-usage "$0"; exit 0 ;;
        newer) timecomp='-nt';timecompfile=$1;shift ;;
        older) timecomp='-ot';timecompfile=$1;shift ;;
        abspath) opt_abspath=1 ;;
        ls) opt_ls=1 ;;
        files-only | fo ) opt_files_only=1 ;;
        --) moreopts=0;;
        *) cmd-echo -- "$original is an invalid option. See $0 --help"
           exit 1 ;;
    esac
done

if [ -n "$timecomp" ]
then
    if [ ! -f "$timecompfile" ]
    then
        cmd-echo -- "Cannot find file '$timecompfile' for $timecomp comparison"
        exit 1
    fi

    declare exitval=1 ## bad - no files found
    for gitfile in $(git ls-files)
    do

        if ((opt_files_only)) && [[ ! -f $gitfile ]]
        then
            continue
        fi
        declare timecompstat
        test  "$gitfile" "$timecomp" "$timecompfile"; timecompstat=$?
        if ((timecompstat==0))
        then
            exitval=0 ## good - at least one file found
            if (( opt_abspath ))
            then
                ## Preserve symlinks; do not resolve through to the underlying
                ## file.
                realpath -s "$gitfile"
            else
                echo "$gitfile"
            fi
        fi
    done
    exit $exitval
fi

if ((opt_conflicts))
then
    declare -a conflict_files
    mapfile -t conflict_files < <(git grep "${opt_grep_opts[@]}" '^<<<<<<<' | sed 's/:<<<<<<<.*//g')
    declare cf
    for cf in "${conflict_files[@]}"
    do
        if [ "$opt_grep_opts_verbose" = '-l' ]
        then
            echo "$cf"
        else
            cmd-echo -head -- "Conflicts in $cf"
            # shellcheck disable=SC2086 # we want $opt_grep_opts_verbose to "disappear" if empty.
            perl -ne '
BEGIN{
$n=0;
if ($ARGV[0] eq q(-n) ) {
$n=1;
shift @ARGV
}
}
if(/^</ .. /^>/) {
if ($n) {
printf ( q(%6d:%s), $., $_)
} else {
print $_
}
my $dummy = 6;
} ' -- -n "$cf"
        fi
    done
    if (( opt_edit ))
    then
        if [ -z "$EDITOR" ]
        then
            cmd-echo -- "No EDITOR env variable found"
            exit 1
        fi
        $EDITOR "${conflict_files[@]}"
    fi
    (( ${#conflict_files[@]} )) && exit 1
    exit 0
fi

if ((opt_deleted))
then
    git rev-list -n 1 HEAD -- "$1"
    exit $?
fi

if ((opt_last_existed))
then
    git rev-list -n 1 "$(git rev-list -n 1 HEAD -- "$1")"^ -- "$1"
    exit $?
fi

if ((opt_git_dir))
then
    declare dotgit
    dotgit=$(git root)/.git
    if [ -f "$dotgit" ]
    then
        ## Must be a worktree. Go find the source.
        dotgit="$(realpath "$(sed 's/gitdir: //' < "$dotgit")" | sed 's/.git\/.*/.git/')"
    fi
    if [ -d "$dotgit" ]
    then
        echo "$dotgit"
        exit 0
    else
        exit 1
    fi
fi

if [ "$opt_untracked_only" = 1 ] && [ "$opt_all" = 1 ]
then
    echo "--untracked_only and --all are mutually exclusive"
    bash-usage "$0"
    exit 1
fi

declare -a ls_files_opts=('-c')
if [ "$opt_untracked_only" = 1 ]
then
    ls_files_opts=('-o')
elif [ "$opt_all" = 1 ]
then
    ls_files_opts+=('-o')
fi

declare -a to_find
if (($# == 0))
then
    ## No args, find everything
    to_find=('.')
else
    to_find=("$@")
fi

declare -a output
for f in "${to_find[@]}"
do
    for ff in $(git ls-files "${ls_files_opts[@]}" "$(git rev-parse --show-toplevel)" | grep "${opt_grep_opts[@]}" "$f" | sort -u )
    do
        if ((opt_files_only)) && [[ ! -f $gitfile ]]
        then
            continue
        fi

        ffb=$(basename "$ff")
        if [[ $ffb =~ $f ]]
        then
            output+=("$ff")
        fi
    done
done

if [ -n "${opt_grep_opts_exclude[0]}" ]
then
    mapfile -t output < <(perl -e '
$res=0;
$re=0;
for ($i=0; $i<@ARGV; $i++) {
    if ($ARGV[$i] eq q(-x) ) {
        push @x, split(/,/,$ARGV[++$i])
    } else {
        if(!$res) {
            $res = join(q(|), @x);
            $re = qr($res);
        }
        $ARGV[$i] !~ m/$re/ && print qq($ARGV[$i]\n);
    }
}
' -- "${opt_grep_opts_exclude[@]}" "${output[@]}"
                         )
fi

if (( opt_edit ))
then
    if [ -z "$EDITOR" ]
    then
        cmd-echo -- "No EDITOR env variable found"
        exit 1
    fi
    $EDITOR "${output[@]}"
else
    if ((opt_ls))
    then
        # shellcheck disable=SC2012 #https://github.com/koalaman/shellcheck/wiki/SC2012
        # we want an ls here, not a find
        ls -la "${output[@]}" | uniq
    else
        declare i
        for i in  "${output[@]}"
        do
            echo "$i"
        done | uniq
        fi
fi

if ((${#output[@]}))
then
    exit 0 ## found at at least one, success
else
    exit 1
fi


:<<'__PODUSAGE__'
=head1 NAME

git-find - run a 'find'-like command on the current repo

=head1 SYNOPSIS

 git-find [-ls] [-i] [-x exclude_pattern[,exclude_pattern...] \
          [--untracked_only|-u] [--all|-a] [--edit|-e] [--files-only] \
          pattern [pattern...] \

 git-find --conflicts [-n|-l] [--edit|-e]
 git-find [--deleted|--last-existed] file
 git-find --git-dir
 git-find --newer markerfile [--abspath] [--files-only]
 git-find --older markerfile [--abspath] [--files-only]
 git-find [--help|-h]

=head1 DESCRIPTION

Tries hard to find files (or directories) in the current repo that are members
of the repo with names matching the patterns presented. By default, we ignore
untracked files.

=head1 ARGUMENTS

=over 4

=item pattern

A regular expression to match against paths. Unlike the 'find' provided with
*N*X systems, we match against the full directory+file and we match
'.*pattern.*' by default, so that /a/booboo/far will match 'boo' - a partial
match and matched the directory.

=back

=head1 OPTIONS

=over 4

=item -ls

Run ls -la on the found items instead of just printing them.

=item -i

Case insensitive matching.

=item -n|-l

Print matches with line number or just print filename containing a
match. Mutually exclusive.

=item -x exclude_pattern

Files that match the regular expression given are excluded. Multiple patterns
can be comma separated and multiple -x options can be specified.

=item --untracked-only

Consider only those files that are NOT objects in the repo.

=item --all

Look at all files; those that are repo objects and those that are not (untracked).

=item --edit|-e

For searches or conflicts, edit the files found using the editor defined in $EDITOR.

=item --files-only | -fo

For searches, only show files. Sometimes 'git ls-files' will show directories too.

=item --conflicts

Find files with git conflict markers in them.

=item --deleted|--last-existed

Print the commit id in which the given file was deleted from git or last
existed in git, respectively.

=item --git-dir

Find the .git directory for the repo, even in a worktree.

=item --newer

Find all the git files newer than the file given.

=item --older

Find all the git files older than the file given.

=item --abspath

Print the full path to any files found with --newer or --older.

=item --help

This help page.

=back

=cut

__PODUSAGE__
