#!/usr/bin/env bash

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

github-api-echo ()
{
    cmd-echo "$@" >&2
}

curl-cat ()
{
    cmd-echo --title Headers
    cat "$curlheaders"
    cmd-echo --title Data
    cat "${curldata}"*
}

main ()
{
    declare usage_cmd="script-usage"
    ## If there's any chance that this will be in a script that will be dotted in,
    ## remove the explicit out_cmd calls.
    declare out_cmd="exit"
    declare moreopts=1
    declare server='github'
    declare token_file="$HOME/.github"
    declare verbose=0
    declare silent=0
    declare synchronous=0
    declare keep_data=0
    declare scope='all'
    declare pullId
    declare stream_data=0
    declare doexec=1
    declare -a otherparams

    ##
    ## options parsing
    ##
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        if [[ "$option" =~ = ]]
        then
            okey=${option%%=*}
            ovalue=${option#*=}
            option="$okey"
        fi

        case $option in
            stream-data ) stream_data=1 ;;

            keep-data ) keep_data=1 ;;

            server )
                server=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                ;;

            wait ) synchronous=1 ;;

            all | public | private | list-forks | sources | member | contents )
                scope=$option ;;

            pull )
                pullId=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                ;;

            h | help )
                $usage_cmd
                $out_cmd 0
                ;;

            v | verbose )
                verbose=1
                silent=0
                ;;

            s | silent )
                verbose=0
                silent=1
                ;;

            noexec)
                doexec=0
                verbose=1
                ;;
            --)
                moreopts=0
                ;;

            * )
                github-api-echo -- "$original is an invalid option. See $0 --help"
                $out_cmd 1
                ;;
        esac
    done

    declare server_url
    server_url="$(kvstore get gitfuncs_git_api_urls "$server")/"
    if [ -z "$server_url" ]
    then
        github-api-echo -- "'$server' is an in valid --server option"
        return 1
    fi

    declare token_file
    token_file="$HOME/$(kvstore get gitfuncs_git_token_file "$server")"

    if [ ! -r "$token_file" ]
    then
        github-api-echo -- "Credentials file '$token_file' not found. Do you have the right server?"
        exit 1
    fi

    ##
    ## action parsing
    ##
    declare action=$1
    shift

    case $action in
        fork | list-forks | exists | ping | pulls | contents )
            ## Requires a repo
            if [ -z "$1" ]
            then
                github-api-echo -- "No org/repo specified"
                return 1;
            fi
            if [[ "$1" =~ / ]]
            then
                org=${1%/*}
                repo=${1#*/}
            else
                org=$1; shift
                repo=$1; shift
            fi
            [ -z "$org" ] && github-api-echo -- "No org specified" && bail=1
            [ -z "$repo" ] && github-api-echo -- "No repo specified" && bail=1
            ((bail)) && return 1

            if [[ $action == 'contents' ]]
            then
                contents="$1"; shift
            fi
            ;;

        orgs | repos )
            ## Requires an org
            if [ -z "$1" ]
            then
                github-api-echo -- "No org specified"
                return 1;
            fi
            if [[ "$1" =~ / ]]
            then
                org=${1%/*}
                repo=${1#*/}
                github-api-echo -- "org only, repo $repo ignored"
            else
                org=$1; shift
                if [ -n "$1" ]
                then
                    repo=$1; shift
                    github-api-echo -- "org only, repo $repo ignored"
                fi
            fi
            ;;

        raw )
            raw="$1"; shift
            ;;

        filename )
            filename="$1"; shift
            otherparams=("$@");
            [[ -n ${otherparams[0]} ]] && \
                [[ ! ${otherparams[0]} =~ ^\+ ]] &&
                otherparams[0]="+${otherparams[0]}"
            ;;

        * )
            if [ -n "$1" ]
            then
                github-api-echo -- "$1 is not supported"
            else
                github-api-echo -- "No action provided"
            fi
            return 1;
    esac

    if [ -n "$org" ]
    then
        # shellcheck disable=SC2034
        declare dummy
        ## todo make sure org exists
    fi

    ##
    ## URL fixup, action normalization
    ##
    declare -a curlopts
    case $action in
        exists | ping )
            action='exists'
            url="repos/$org/$repo"
            ;;

        fork )
            url="repos/$org/$repo/forks"
            curlopts=('-X' 'POST')
            ;;

        list-forks )
            url="repos/$org/$repo/forks"
            ;;

        orgs)
            url="orgs/$org"
            ;;

        repos)
            url="orgs/$org/repos?type=$scope"
            ;;

        raw)
            server_url=''
            url="$raw"
            ;;

        filename)
            url="search/code?q=$filename+in:path"
            ;;

        pulls)
            url="repos/$org/$repo/pulls"
            [ -n "$pullId" ] && url="${url}/$pullId"
            ;;

        contents)
            url="repos/$org/$repo/contents/$contents"
            ;;

    esac

    declare curlheaders
    curlheaders=$(mktemp -t tmp.github-api.curlheaders.$$.XXXXXXXXXX)
    curlopts+=('-D' "$curlheaders")

    declare curldata
    curldata=$(mktemp -t tmp.github-api.curldata.$$.XXXXXXXXXX)

    declare perldata
    perldata=$(mktemp -t tmp.github-api.perldata.$$.XXXXXXXXXX)

    if ((keep_data))
    then
        github-api-echo -- "Header and data files are" "$curlheaders" "$curldata"
    else
        rm_on_exit "$curlheaders" "$curldata" "$perldata"
    fi

    if((verbose))
    then
        github-api-echo -- 'curl \ ' \
                 "    --header \"Authorization: <redacted>\" \\ " \
                 "    ${curlopts[*]} \\ " \
                 "    ${server_url}${url}${otherparams[*]} -s"
    fi

    if ((doexec))
    then
        curl \
            --header "Authorization: token$(grep token "$token_file" | cut -d= -f2)" \
            "${curlopts[@]}" \
            "${server_url}${url}${otherparams[*]}" -s > "$curldata" 2>&1
        declare status=$?

        if ((status))
        then
            github-api-echo -- "curl returned with error :$status"
            curl-cat
            return $status
        fi

        declare -a pagenums
        declare page_links
        page_links=$(grep -E '^Link: ' "$curlheaders" )
        if [[ -n $page_links ]]
        then
            # shellcheck disable=SC2207
            pagenums=($(perl -e '$ARGV[0] =~ m/.*?page=(\d+).*?page=(\d+)/;print "$1 $2\n";' "$page_links"))
            declare pagenum=1
            declare pagenumfmt
            pagenumfmt="%0${#pagenums[1]}d"
            declare pageprint
            # shellcheck disable=SC2059
            pageprint="$(printf "$pagenumfmt" $pagenum)"
            mv "$curldata" "${curldata}.${pageprint}"
            ((pagenum+=1))
            # shellcheck disable=SC2004
            github-api-echo "1 of ${pagenums[1]} pages of data fetched..."
            while (( pagenum <= "${pagenums[1]}" ))
            do
                github-api-echo "Page ${pagenum}..."
                # shellcheck disable=SC2059
                pageprint="$(printf "$pagenumfmt" $pagenum)"
                curl \
                    --header "Authorization: token$(grep token "$token_file" | cut -d= -f2)" \
                    "${curlopts[@]}" \
                    "${server_url}${url}${otherparams[*]}&page=$pagenum" -s > "${curldata}.${pageprint}" 2>&1
                declare status=$?

                if ((status))
                then
                    github-api-echo -- "curl returned with error :$status"
                    curl-cat
                    return $status
                fi
                ((pagenum+=1))
            done
        fi

        declare htmlstatus
        htmlstatus=$(grep "Status:" "$curlheaders" | sed -e 's/Status: //' -e 's/ .*//')
        case $action in
            contents)
                case $htmlstatus in
                    200 )
                        # shellcheck disable=SC2016 # Yes, I know I have a '$' in single quotes.
                        echo '$VAR1=' > "$perldata"
                        json_xs -t dumper < "$curldata" >> "$perldata"
                        perl -MMIME::Base64 -e 'do $ARGV[0]; print decode_base64($VAR1->{content})' "$perldata"
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            exists )
                case $htmlstatus in
                    200 )
                        github-api-echo -- "Repo exists."
                        ;;
                    404 )
                        github-api-echo -e -- "'${server}:$org/$repo' not found."
                        return 1;
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            list-forks )
                case $htmlstatus in
                    200 )
                        # shellcheck disable=SC2016 # Yes, I know I have a '$' in single quotes.
                        echo '$VAR1=' > "$perldata"
                        json_xs -t dumper < "$curldata" >> "$perldata"
                        perl -e 'do $ARGV[0]; print join(qq(\n), sort map {$_->{full_name}} @$VAR1)' "$perldata"
                        ;;
                    404 )
                        github-api-echo -e -- "'${server}:$org/$repo' not found."
                        return 1;
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            pulls )
                case $htmlstatus in
                    200 )
                    ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            fork )
                case $htmlstatus in
                    200 )
                        github-api-echo -- "Fork created."
                        ;;
                    202 )
                        github-api-echo -- "Fork found."
                        ;;
                    404 )
                        github-api-echo -e -- "either organization '$org' or repo '$repo' does not exist on '$server'."
                        return 1;
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac

                if ((synchronous))
                then
                    declare waiting='Waiting for fork creation...'
                    declare remaining=60
                    while github-api --server "$server" list-forks "$org" "$repo" | grep -E -q '"message":\s*"Not Found"'
                    do
                        [ -n "$waiting" ] && github-api-echo -- "'$waiting'" && waiting=''
                        sleep 1
                        ((remaining-=1))
                        ((remaining)) || break
                    done
                    if github-api --server "$server" list-forks "$org" "$repo" | grep -E -q '"message":\s*"Not Found"'
                    then
                        github-api-echo -w -- "Fork not yet created"
                        return 1
                    else
                        return 0
                    fi
                fi
                ;;
        esac
    fi

    if ((stream_data))
    then
        cat "${curldata}".*
    elif ((!silent))
    then
        curl-cat
    fi

    if ((keep_data))
    then
        github-api-echo -- "Header and data files are" "$curlheaders" "$curldata"
    fi
    return 0
}

main "$@"
exit $?

## You can add sections with =head1, but stick to =item for section breakdowns,
## not =head2/3/etc/. If you want just plain text, get rid of pod tags and the
## 'POD' in __PODUSAGE__.

:<<'__PODUSAGE__'
=head1 NAME

github-api - Wrapper around curl calls to the github api

=head1 SYNOPSIS

 github-api [--server server] [--keep-data] [--wait] [--verbose|--silent--noexec] \
     org <orgname> |
     repos <orgname> |
     exists[|ping] <orgname> <reponame> |
     list-forks <orgname> <reponame> |
     fork <orgname> <reponame> |
     filename <filename-to-search-for> |
     [--pullId N] pulls |
     contents path/to/file/from/repo/root[?ref=id]
     raw <url-of-api-call>

=head1 DESCRIPTION

Run some specific github apis. Uses your own OAuth credentials so you may not
be able to see everything. Prints its messages to stderr, all data to stdout so
you can filter the output with pipes and still see the progress messages.

=head1 ARGUMENTS

=over 4

=item orgs

Runs orgs api call. Requires an orgname. Returns metadata about that org.

=item repos

Runs repos api call. Requires an orgname. Returns metadata about all the repos
in that org.

=item exists|ping

Runs repos api call. Requires an orgname and a repo. Returns metadata repo
specified. Exits 0 if repo found, 1 if not.

=item list-forks

Lists the forks of a repo. Requires an orgname and a repo.

=item fork

Create a fork, in your org, a repo. Requires an orgname and a repo.

=item filename

Find a file in all orgs/repos. Requires an filename to search for.

-item contents

Get a file. Specify the path to the file relative to the repo root. The optional parameter 'ref' is the commit/branch/tag for the version you want. Default is the version at the head of branvh 'master'.

=item raw

Run any api call, expressed as the raw api.

=back

=head1 OPTIONS

=over 4

=item --server

Default: 'github'. Also accepts 'bbgithub'.

=item --keep-data

Header and data are sent to a file for display. This options doesn't clean up after execution allowing you to use them. Filenames will be shown.

=item --wait

Whe creating a fork, wait for the fork to create before exiting. Default is to send off the command and exit, as the fork creation is async by default.

=item [--verbose|--silent|--noexec]

'verbose' shows steps and the full curl command, sans authentication info.

'silent' represses the header and data output when you just want the return code.

'noexec' show the full curl command, sans authentication info, but does not execute it.

=back

=cut

__PODUSAGE__
