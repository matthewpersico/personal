#!/usr/bin/env bash

echo "$(date): github-api" >> "$HOME/.gitaudit"

# github-api

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

github-api-echo ()
{
    cmd-echo "$@" >&2
}

curl-cat ()
{
    cmd-echo --title Headers
    cat "$curlheaders"
    cmd-echo --title Data
    cat -v "${curldata}"*
}

main ()
{
    ## If there's any chance that this will be in a script that will be dotted in,
    ## remove the explicit out_cmd calls.
    declare out_cmd="exit"
    declare moreopts=1
    declare server='github'
    declare token_file="$HOME/.github"
    declare verbose=0
    declare silent=0
    declare synchronous=0
    declare keep_data=0
    declare scope='all'
    declare pullId
    declare stream_data=0
    declare perl_data=0
    declare doexec=1
    declare -a otherparams
    declare opt_data_mode=0
    declare override_url
    declare -a override_args
    declare -a re_exec
    declare no_fork=0

    re_exec=("$@")

    ##
    ## options parsing
    ##
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        ## but only deal with it if we really have an option. Otherwise you
        ## misinterpret items like this git clone option: --config
        ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
        if [[ $option =~ ^- ]]
        then
            if [[ "$option" =~ = ]]
            then
                okey=${option%%=*}
                ovalue=${option#*=}
                option="$okey"
            fi
        fi

        case $option in
            override-url )
                override_url=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                ;;

            no-fork ) no_fork=1 ;;

            data-mode ) opt_data_mode=1 ;;

            stream-data ) stream_data=1 ;;

            perl-data ) stream_data=1; perl_data=1 ;;

            keep-data ) keep_data=1 ;;

            server )
                server=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                ;;

            wait ) synchronous=1 ;;

            all | public | private | list-forks | sources | member | contents )
                scope=$option ;;

            pull )
                pullId=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                ;;

            h | help )
                bash-usage "$0"
                $out_cmd 0
                ;;

            v | verbose )
                verbose=1
                silent=0
                ;;

            s | silent )
                verbose=0
                silent=1
                ;;

            noexec)
                doexec=0
                verbose=1
                ;;
            --)
                moreopts=0
                ;;

            * )
                github-api-echo -- "$original is an invalid option. See $0 --help"
                $out_cmd 1
                ;;
        esac
    done

    declare server_url
    server_url="$(kvstore get gitfuncs_git_api_urls "$server")/"
    if [ -z "$server_url" ]
    then
        github-api-echo -- "'$server' is an in valid --server option"
        return 1
    fi

    declare token_file
    token_file="$HOME/$(kvstore get gitfuncs_git_token_file "$server")"

    if [ ! -r "$token_file" ]
    then
        github-api-echo -- "Credentials file '$token_file' not found. Do you have the right server?"
        exit 1
    fi

    ##
    ## action parsing
    ##
    declare org_is_user=0
    declare action=$1
    shift

    case $action in
        fork | list-forks | exists | ping | pulls | contents )
            ## Requires a repo
            if [ -z "$1" ]
            then
                github-api-echo -- "No org/repo specified"
                return 1
            fi
            if [[ "$1" =~ / ]]
            then
                org=${1%/*}
                repo=${1#*/}
            else
                org=$1; shift
                repo=$1; shift
            fi
            [ -z "$org" ] && github-api-echo -- "No org specified" && bail=1
            [ -z "$repo" ] && github-api-echo -- "No repo specified" && bail=1
            ((bail)) && return 1

            if [[ $action == 'contents' ]]
            then
                contents="$1"; shift
            fi
            ;;

        orgs | repos )
            ## Requires an org
            if [ -z "$1" ]
            then
                github-api-echo -- "No org specified"
                return 1
            fi
            if [[ $1 =~ -user ]]
            then
                org_is_user=1
                shift
            fi
            if [[ "$1" =~ / ]]
            then
                org=${1%/*}
                repo=${1#*/}
                github-api-echo -- "org only, repo $repo ignored"
            else
                org=$1; shift
                if [ -n "$1" ]
                then
                    repo=$1; shift
                    github-api-echo -- "org only, repo $repo ignored"
                fi
            fi
            ;;

        raw )
            raw="$1"; shift
            ;;

        url )
            url="$1"; shift
            ;;

        filename )
            filename="$1"; shift
            otherparams=("$@")
            [[ -n ${otherparams[0]} ]] && \
                [[ ! ${otherparams[0]} =~ ^\+ ]] &&
                otherparams[0]="+${otherparams[0]}"
            ;;

        text )
            text="$1"; shift
            otherparams=("$@")
            [[ -n ${otherparams[0]} ]] && \
                [[ ! ${otherparams[0]} =~ ^\+ ]] &&
                otherparams[0]="+${otherparams[0]}"
            ;;

        * )
            if [ -n "$1" ]
            then
                github-api-echo -- "$1 is not supported"
            else
                github-api-echo -- "No action provided"
            fi
            return 1
    esac

    if [ -n "$org" ]
    then
        # shellcheck disable=SC2034
        declare dummy
        ## todo make sure org exists
    fi

    ##
    ## URL fixup, action normalization
    ##
    declare -a curlopts
    case $action in
        exists | ping )
            action='exists'
            url="repos/$org/$repo"
            ;;

        fork )
            url="repos/$org/$repo/forks"
            curlopts=('-X' 'POST')
            ;;

        list-forks )
            url="repos/$org/$repo/forks"
            ;;

        orgs)
            url="orgs/$org"
            ;;

        repos)
            if ((org_is_user))
            then
                url="users/$org/repos?type=$scope"
            else
                url="orgs/$org/repos?type=$scope"
            fi
            ;;

        raw)
            server_url=''
            url="$raw"
            ;;

        url)
            url="$url"
            ;;

        filename)
            url="search/code?q=$filename+in:path"
            ;;

        text)
            url="search/code?q=${text}&type=Code"
            ;;

        pulls)
            url="repos/$org/$repo/pulls"
            [ -n "$pullId" ] && url="${url}/$pullId"
            ;;

        contents)
            url="repos/$org/$repo/contents/$contents"
            ;;

    esac
    ## Override on re-exec
    if [[ -n $override_url ]]
    then
        ## Get rid of the option since we may have to use it again. We know we
        ## made it the first option in the command.
        re_exec=("${re_exec[@]:2}")

        ## Use it
        url="${override_url}"
        override_args=('--override-url' "${url}")
    fi

    declare curlheaders
    curlheaders=$(mktemp -t tmp.github-api.curlheaders.$$.XXXXXXXXXX)
    curlopts+=('-D' "$curlheaders")

    declare curldata
    curldata=$(mktemp -t tmp.github-api.curldata.$$.XXXXXXXXXX)

    declare perldata
    perldata=$(mktemp -t tmp.github-api.perldata.$$.XXXXXXXXXX)

    if ((keep_data))
    then
        github-api-echo -- "Header and data files are" "$curlheaders" "$curldata"
    else
        rm-on-exit "$curlheaders" "$curldata" "$perldata"
    fi

    if((verbose))
    then
        github-api-echo -- "curl --header \"Authorization: token\$(grep token $token_file | cut -d= -f2)\" ${curlopts[*]} ${server_url}${url}${otherparams[*]} -s"
    fi

    if ((doexec))
    then
        curl \
            --header "Authorization: token$(grep token "$token_file" | cut -d= -f2)" \
            "${curlopts[@]}" \
            "${server_url}${url}${otherparams[*]}" -s > "$curldata" 2>&1
        declare status=$?
        if ((status))
        then
            github-api-echo -- "curl returned with error :$status"
            curl-cat
            return $status
        fi

        declare -a pagenums
        declare page_links
        page_links=$(grep -E '^Link: ' "$curlheaders" )
        if [[ -n $page_links ]]
        then
            # shellcheck disable=SC2207
            pagenums=($(perl -e '$ARGV[0] =~ m/.*?page=(\d+).*?page=(\d+)/;print "$1 $2\n";' "$page_links"))
            declare pagenum=1
            declare pagenumfmt
            pagenumfmt="%0${#pagenums[1]}d"
            declare pageprint
            # shellcheck disable=SC2059
            pageprint="$(printf "$pagenumfmt" $pagenum)"
            # shellcheck disable=SC2004
            github-api-echo "$pagenum of ${pagenums[1]} pages of data fetched..."
            ((pagenum+=1))
            while (( pagenum <= "${pagenums[1]}" ))
            do
                github-api-echo "Page ${pagenum}..."
                # shellcheck disable=SC2059
                pageprint="$(printf "$pagenumfmt" $pagenum)"
                curl \
                    --header "Authorization: token$(grep token "$token_file" | cut -d= -f2)" \
                    "${curlopts[@]}" \
                    "${server_url}${url}${otherparams[*]}&page=$pagenum" -s > "${curldata}.${pageprint}" 2>&1
                declare status=$?

                if ((status))
                then
                    github-api-echo -- "curl returned with error :$status"
                    curl-cat
                    return $status
                fi

                declare htmlstatus
                htmlstatus=$(grep "Status:" "$curlheaders" | sed -e 's/Status: //' -e 's/ .*//')
                case $htmlstatus in
                    200 )
                        ## Consoldate paged data
                        cat "${curldata}.${pageprint}" >> "$curldata"
                        ;;
                    403 )
                        ## Forbidden. Probably hit a query limit.
                        cat "$curlheaders"
                        ;;
                    404 )
                        ## Sometimes, even though pagination of the returned
                        ## data is indicated, the data is not paginated. If we
                        ## got here and got a 404, let's assume all the data is
                        ## in the prior set of data (there must have been at
                        ## least one good set or we wouldn't have even gotten
                        ## into this pagination-handing loop) and move on.

                        ## Fake a good header
                        echo "Status: 200 OK" > "$curlheaders"

                        break ## while
                        ;;
                    * )
                        cat "$curlheaders"
                        exit
                        ;;
                esac
                ((pagenum+=1))
            done
        fi

        declare htmlstatus
        htmlstatus=$(grep "Status:" "$curlheaders" | sed -e 's/Status: //' -e 's/ .*//')
        case $action in
            contents)
                case $htmlstatus in
                    200 )
                        # shellcheck disable=SC2016 # Yes, I know I have a '$' in single quotes.
                        echo '$VAR1=' > "$perldata"
                        json_xs -t dumper < "$curldata" >> "$perldata"
                        echo ';'
                        perl -MMIME::Base64 -e 'do $ARGV[0]; print decode_base64($VAR1->{content})' "$perldata"
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            exists )
                case $htmlstatus in
                    200 )
                        ((opt_data_mode==0)) && github-api-echo -- "Repo exists."
                        ;;
                    404 )
                        github-api-echo -e -- "'${server}:$org/$repo' not found."
                        return 1
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            list-forks )
                case $htmlstatus in
                    200 )
                        # shellcheck disable=SC2016 # Yes, I know I have a '$' in single quotes.
                        echo '$VAR1=' > "$perldata"
                        json_xs -t dumper < "$curldata" >> "$perldata"
                        perl -e 'do $ARGV[0]; print join(qq(\n), sort map {$_->{full_name}} @$VAR1)' "$perldata"
                        return 1
                        ;;
#                    301 )
#                        declare newurl
#                        newurl=$(perl -d:ptkdb -MJSON::XS -e '
#open IH, q(<), $ARGV[0];
#$data = join(q(),<IH>);
#close(IH);
#$json = decode_json($data);
#$url = $json->{url};
#$url =~ s|$ARGV[1]||;
#print qq($url);' "${curldata}" "${server_url}")
#                        cmd-echo -- "Need a --no-fork option below...Re-directing..."
#                        cmd-echo --dc -- "exec $0 --override-url \"$newurl\" \"${re_exec[@]}\""
#                        pause
#                        exec $0 --override-url "$newurl" "${re_exec[@]}"
#                        ;;
                    404 )
                        github-api-echo -e -- "'${server}:$org/$repo' not found."
                        return 1
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            pulls )
                case $htmlstatus in
                    200 )
                    ;;
                    404 )
                        github-api-echo -e -- "'${server}:$org/$repo' not found."
                        return 1
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac
                ;;

            fork )
                case $htmlstatus in
                    200 | 202 )
                        if ((opt_data_mode==0))
                        then
                            [[ $htmlstatus == '200' ]] && github-api-echo -- "Fork created."
                            [[ $htmlstatus == '202' ]] && github-api-echo -- "Fork found."
                            ## In the 202 case one or both of the repos could have
                            ## been renamed after the fork was originally created.
                        else
                            echo $(perl -MJSON::XS -e '
open IH, q(<), $ARGV[0];
$data = join(q(),<IH>);
close(IH);
$json = decode_json($data);
print $json->{name};' "${curldata}" )
                        fi
                        ;;

                    307 )
                        declare newurl
                        newurl=$(perl -MJSON::XS -e '
open IH, q(<), $ARGV[0];
$data = join(q(),<IH>);
close(IH);
$json = decode_json($data);
$url = $json->{url};
$url =~ s|$ARGV[1]||;
print qq($url);' "${curldata}" "${server_url}")
                        cmd-echo -- "Re-directing..."
                        exec $0 --override-url "$newurl" "${re_exec[@]}"
                        ;;
                    404 )
                        github-api-echo -e -- "either organization '$org' or repo '$repo' does not exist on '$server'."
                        return 1
                        ;;
                    * )
                        github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                        curl-cat
                        return 1
                        ;;
                esac

                if ((synchronous))
                then
                    declare waiting='Waiting for fork creation...'
                    declare remaining=60
                    while github-api "${override_args[@]}" --server "$server" list-forks "$org" "$repo" | grep -E -q '"message":\s*"Not Found"'
                    do
                        [ -n "$waiting" ] && github-api-echo -- "'$waiting'" && waiting=''
                        sleep 1
                        ((remaining-=1))
                        ((remaining)) || break
                    done
                    if github-api "${override_args[@]}" --server "$server" list-forks "$org" "$repo" | grep -E -q '"message":\s*"Not Found"'
                    then
                        github-api-echo -w -- "Fork not yet created"
                        return 1
                    else
                        return 0
                    fi
                fi
                ;;
        esac
    fi

    if ((stream_data))
    then
        if((perl_data))
        then
            # shellcheck disable=SC2016 # We know the variable will not expand.
            echo '$VAR1='
            json_xs -t dump < "${curldata}"
        else
            cat -v "${curldata}"
        fi
    elif ((!silent))
    then
        curl-cat
    fi

    if ((keep_data))
    then
        github-api-echo -- "Header and data files are" "$curlheaders" "$curldata"
    fi
    return 0
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

github-api - Wrapper around curl calls to the github api

=head1 SYNOPSIS

 github-api [--server server] [--stream-data|--perl-data] [--keep-data] ] [--wait] [--verbose|--silent|--noexec] \
     org <orgname> |
     repos [--user] <orgname> |
     exists[|ping] <orgname> <reponame> |
     list-forks <orgname> <reponame> |
     fork <orgname> <reponame> |
     filename <filename-to-search-for> |
     text <text-to-search-for> |
     [--pullId N] pulls |
     contents path/to/file/from/repo/root[?ref=id] |
     url <serverless-url-of-api-call> |
     raw <full-url-of-api-call>

=head1 DESCRIPTION

Run some specific github apis. Uses your own OAuth credentials so you may not
be able to see everything. Prints its messages to stderr, all data to stdout so
you can filter the output with pipes and still see the progress messages.

=head1 ARGUMENTS

=over 4

=item orgs

Runs orgs api call. Requires an orgname. Returns metadata about that org.

=item repos

Runs repos api call. Requires an orgname. Returns metadata about all the repos
in that org. If the 'org' is a person, add the '--user' flag.

=item exists|ping

Runs repos api call. Requires an orgname and a repo. Returns metadata repo
specified. Exits 0 if repo found, 1 if not.

=item list-forks

Lists the forks of a repo. Requires an orgname and a repo.

=item fork

Create a fork, in your org, a repo. Requires an orgname and a repo.

=item filename

Find a file in all orgs/repos. Requires an filename to search for.

=item text

Find a text string in all orgs/repos. Requires an string to search for. Special characters must be provided as URL escapes (%20 for a space, %3D for an equals sign, etc.)

=item pulls

Find information about **open** pull requests.

=item contents

Get a file. Specify the path to the file relative to the repo root. The optional parameter 'ref' is the commit/branch/tag for the version you want. Default is the version at the head of branvh 'master'.

=item url

Run any api call, expressed as the raw api, assuming the https://, server and api point portions.

=item raw

Run any api call, expressed as the raw api, starting with the https://, server and api point portions.

=back

=head1 OPTIONS

=over 4

=item --server

Default: 'github'. Also accepts 'bbgithub'.

=item --stream-data

All headers and titles are suppressed. Only the JSON data structure is sent to stdout for display. Use this if you want to ingest the output in a program.

=item --perl-data

All headers and titles are suppressed. Only the JSON data structure is converted to a Perl Data::Dumper format and sent to stdout for display. The output should be stored to a file X so it can then used via a

 do $ARGV[0];

statement in a Perl script where X is the first arg to the script.

=item --keep-data

Header and data are sent to a file for display. This options doesn't clean up after execution allowing you to use them. Filenames will be shown.

=item --wait

Whe creating a fork, wait for the fork to create before exiting. Default is to send off the command and exit, as the fork creation is async by default.

=item [--verbose|--silent|--noexec]

'verbose' shows steps and the full curl command, sans authentication info.

'silent' supresses the header and data output when you just want the return code.

'noexec' show the full curl command, sans authentication info, but does not execute it.

=back

=cut

__PODUSAGE__
