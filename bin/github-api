#!/usr/bin/env bash

echo "$(date): github-api" >> "$HOME/.gitaudit"

# github-api

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

github-api-echo ()
{
    cmd-echo "$@" >&2
}

curl-cat ()
{
    cmd-echo --title Headers
    cat "$curlheaders"
    cmd-echo --title Data
    cat -v "${curldata}"*
}

print-progress ()
{
    declare verbose=$1; shift
    declare no_progress=$1; shift
    declare progress=$1; shift
    declare pagenum=$1; shift
    declare last=0
    [[ $1 == 'last' ]] && last=1
    declare print_it=0
    if ((verbose))
    then
        if ((!no_progress))
        then
            ## verbose and we didn't shut off progress
            print_it=1
        fi
    else
        ## Not verbose...
        ## ...but we asked for printing anyway
        if ((progress))
        then
            ## If the current page matches the print page modulo number or it is the last page
            if ((pagenum % progress == 0)) \
                   || ((last))
            then
                print_it=1
            fi
        fi
    fi
    ((print_it)) &&  github-api-echo "Page ${pagenum}..."
}

declare G_next_link
declare G_last_link

parse-next-last ()
{
    declare curlheaders="$1"; shift
    declare page_link_string
    page_link_string=$(grep -E '^Link: ' "$curlheaders" )
    if [[ -n $page_link_string ]]
    then
        ## There is more than one page of data to fetch.

        ## Parse the link for first/prev/next/last urls
        declare -a plitmp
        read -r -a plitmp < \
             <(perl -e'
use strict; use warnings;
my @pieces =
map {
     s/^<(.*)>;$/$1/;
     s/^rel="([a-z]+)",*/$1/;
     $_
    }
  grep { ! m/^Link:$/}
    split(/\s+/,$ARGV[0]);
for (my $i=0;$i<@pieces;$i+=2){
    print( "@pieces[$i+1,$i] " )
}
' "$page_link_string"
                  )
        # Set the globals appropriately
        declare idx=0
        G_next_link=''
        G_last_link=''
        while((idx < "${#plitmp[@]}"))
        do
            if [[ ${plitmp[$idx]} == 'next' ]]
            then
                G_next_link=${plitmp[((idx+1))]}
            elif [[ ${plitmp[$idx]} == 'last' ]]
            then
                G_last_link=${plitmp[((idx+1))]}
            fi
            ((idx+=2))
        done
    fi
}

main ()
{
    declare opt_override_url ## Only used by re-exec
    declare opt_server='github'
    declare opt_page_limit=0

    declare opt_data_mode=0
    declare opt_stream_data=0
    declare opt_keep_data=0
    declare opt_perl_data=0

    declare -a fields
    declare opt_keyed_fields
    declare opt_record_fields

    declare synchronous=0

    declare opt_verbose=0
    declare opt_silent=0
    declare opt_no_progress=0
    declare opt_progress=0

    declare moreopts=1

    ## If there's any chance that this will be in a script that will be dotted
    ## in, remove the explicit out_cmd calls.
    declare out_cmd="exit"
    declare token_file="$HOME/.github"

    declare scope='all'
    declare pullId
    declare doexec=1
    declare -a otherparams
    declare per_page
    declare -a override_args
    declare -a re_exec
    declare user
    re_exec=("$@")

    ##
    ## options parsing
    ##
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        ## but only deal with it if we really have an option. Otherwise you
        ## misinterpret items like this git clone option: --config
        ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
        if [[ $option =~ ^- ]]
        then
            if [[ "$option" =~ = ]]
            then
                okey=${option%%=*}
                ovalue=${option#*=}
                option="$okey"
            fi
        fi

        case $option in
            override-url \
                | server \
                | page-limit \
                | progress )
                declare var="opt_${option//-/_}"
                eval "${var}"="${ovalue:-$1}"
                [ -z "$ovalue" ] && shift
                ;;

            data-mode \
                | stream-data \
                | keep-data \
                | perl-data \
                | no-progress )
                declare var="opt_${option//-/_}"
                eval "${var}"=1
                [[ $var == 'opt_perl_data' ]] && opt_stream_data=1
                ;;

            *fields )
                eval opt_${option//-/_}=1
                ;&
            fields )
                declare -a some_fields
                IFS=, read -ra some_fields <<<"$1"; shift
                fields+=("${some_fields[@]}")
                opt_stream_data=1
                ;;

            wait ) synchronous=1 ;;

            all | public | private | list-forks | sources | member | contents )
                scope=$option ;;

            h | help )
                bash-usage "$0"
                $out_cmd 0
                ;;

            v | verbose )
                opt_verbose=1
                opt_silent=0
                ;;

            s | silent )
                opt_verbose=0
                opt_silent=1
                ;;

            noexec)
                doexec=0
                opt_verbose=1
                ;;
            --)
                moreopts=0
                ;;

            * )
                github-api-echo -- "$original is an invalid option. See $0 --help"
                $out_cmd 1
                ;;
        esac
    done

    declare server_url
    server_url="$(git kv --get "api-urls.$opt_server")/"
    if [ -z "$server_url" ]
    then
        github-api-echo -- "'$opt_server' is an in valid --server option"
        return 1
    fi

    declare token_file
    token_file="$HOME/$(git kv --get "token-file.$opt_server")"
    if [ ! -r "$token_file" ]
    then
        github-api-echo -- "Credentials file '$token_file' not found. Do you have the right server?"
        exit 1
    fi


    ##
    ## action parsing
    ##
    declare org_is_user=0
    declare action=$1
    shift

    case $action in
        fork | list-forks | exists | ping | pulls | contents | repo )
            ## Requires a repo
            if [ -z "$1" ]
            then
                github-api-echo -- "No org/repo specified"
                return 1
            fi
            if [[ "$1" =~ / ]]
            then
                org=${1%/*}
                repo=${1#*/}
                shift
            else
                org=$1; shift
                repo=$1; shift
            fi
            [ -z "$org" ] && github-api-echo -- "No org specified" && bail=1
            [ -z "$repo" ] && github-api-echo -- "No repo specified" && bail=1
            ((bail)) && return 1

            if [[ $action == 'contents' ]]
            then
                contents="$1"; shift
            fi
            ;;

        org | repos )
            ## Requires an org
            if [ -z "$1" ]
            then
                github-api-echo -- "No org specified"
                return 1
            fi
            if [[ $1 =~ -user ]]
            then
                org_is_user=1
                shift
            fi
            if [[ "$1" =~ / ]]
            then
                org=${1%/*}
                repo=${1#*/}
            else
                org=$1; shift
                if [ -n "$1" ]
                then
                    repo=$1; shift
                fi
            fi
            if [[ $action == 'org' ]] && [[ -n $repo ]]
            then
                github-api-echo --wc -- "Repo ignore for action org"
                repo=''
            fi

            ;;

        raw )
            raw="$1"; shift
            ;;

        url )
            url="$1"; shift
            ;;

        filename )
            filename="$1"; shift
            otherparams=("$@")
            [[ -n ${otherparams[0]} ]] && \
                [[ ! ${otherparams[0]} =~ ^\+ ]] &&
                otherparams[0]="+${otherparams[0]}"
            ;;

        text )
            text="$1"; shift
            otherparams=("$@")
            [[ -n ${otherparams[0]} ]] && \
                [[ ! ${otherparams[0]} =~ ^\+ ]] &&
                otherparams[0]="+${otherparams[0]}"
            ;;

        users)
            user='*'
            ;;

        user)
            user="$1"; shift
            ;;

        * )
            if [ -n "$1" ]
            then
                github-api-echo -- "$1 is not supported"
            else
                github-api-echo -- "No action provided"
            fi
            return 1
    esac

    if [ -n "$org" ]
    then
        # shellcheck disable=SC2034
        declare dummy
        ## todo make sure org exists
    fi

    ##
    ## URL fixup, action normalization
    ##
    declare -a curlopts
    case $action in
        exists | ping )
            action='exists'
            url="repos/$org/$repo"
            ;;

        fork )
            url="repos/$org/$repo/forks"
            curlopts=('-X' 'POST')
            ;;

        list-forks )
            url="repos/$org/$repo/forks"
            ;;

        org)
            url="orgs/$org"
            ;;

        repos)
            if ((org_is_user))
            then
                url="users/$org/repos?type=$scope"
            else
                url="orgs/$org/repos?type=$scope"
            fi
            ;;

        repo )
            action='exists'
            url="repos/$org/$repo"
            ;;

        raw)
            server_url=''
            url="$raw"
            ;;

        url)
            url="$url"
            ;;

        filename)
            url="search/code?q=$filename+in:path"
            ;;

        text)
            url="search/code?q=${text}&type=Code"
            ;;

        pulls)
            url="repos/$org/$repo/pulls"
            [ -n "$pullId" ] && url="${url}/$pullId"
            ;;

        contents)
            url="repos/$org/$repo/contents/$contents"
            ;;

        users )
            url="users"
            per_page='per_page=100'
            ;;

        user )
            url="users/$user"
            ;;
    esac
    ## Override on re-exec
    if [[ -n $opt_override_url ]]
    then
        ## Get rid of the option since we may have to use it again. We know we
        ## made it the first option in the command.
        re_exec=("${re_exec[@]:2}")

        ## Use it
        url="${opt_override_url}"
        override_args=('--override-url' "${url}")
    fi

    declare curlheaders
    curlheaders=$(mktemp -t tmp.github-api.curlheaders.$$.XXXXXXXXXX)
    curlopts+=('-D' "$curlheaders")

    declare curldata
    curldata=$(mktemp -t tmp.github-api.curldata.$$.XXXXXXXXXX)

    declare perldata
    perldata=$(mktemp -t tmp.github-api.perldata.$$.XXXXXXXXXX)

    if ((opt_keep_data))
    then
        github-api-echo -- "Header and data files are" "$curlheaders" "$curldata"
    else
        rm-on-exit "$curlheaders" "$curldata" "$perldata"
    fi

    if((opt_verbose))
    then
        github-api-echo -- "curl --header \"Authorization: token\$(grep token $token_file | cut -d= -f2)\" ${curlopts[*]} ${server_url}${url}${otherparams[*]} -s"
    fi

    if ((!doexec))
    then
        return 0
    fi

    curl \
        --header "Authorization: token$(grep token "$token_file" | cut -d= -f2)" \
        "${curlopts[@]}" \
        "${server_url}${url}${otherparams[*]}" -s > "$curldata" 2>&1
    declare status=$?
    if ((status))
    then
        github-api-echo -- "curl returned with error :$status"
        curl-cat
        return $status
    fi

    ## pagination
    declare pagenum=1 ## We just fetched page # 1

    parse-next-last "$curlheaders"
    if [[ -n $G_next_link ]]
    then
        declare totalpages=0
        declare pageprint_ext_size=5
        if [[ -n $G_last_link ]]
        then
            ## If there is a 'last' link, we know the number of pages we are going to get.
            # shellcheck disable=SC2207
            totalpages=$(perl -e '$ARGV[0] =~ m/.*?page=(\d+)/;print "$1\n";' "${G_last_link}")
        fi

        if ( ((opt_verbose)) && ((!opt_no_progress)) ) \
               || ((opt_progress))
        then
            declare msg="Page $pagenum of"
            if ((totalpages))
            then
                msg="$msg $totalpages pages"
            else
                msg="$msg an unknown number of pages"
            fi
            msg="$msg of data to be fetched"
            if ((opt_page_limit)) && \
                   ( ((!totalpages)) \
                         || ((opt_page_limit < totalpages)) )
            then
                msg="$msg (limiting to $opt_page_limit)"
            fi
            github-api-echo "${msg}..."
        fi

        while [[ -n $G_next_link ]] && \
                  ( ((opt_page_limit==0)) || \
                        ((pagenum < opt_page_limit)) )
        do
            ((pagenum+=1))
            print-progress "$opt_verbose" "$opt_no_progress" "$opt_progress" "$pagenum"
            declare pageprint_ext
            pageprint_ext="$(printf "%0${pageprint_ext_size}d" "$pagenum")"
            curl \
                --header "Authorization: token$(grep token "$token_file" | cut -d= -f2)" \
                "${curlopts[@]}" \
                "${G_next_link}&${per_page}" -s > "${curldata}.${pageprint_ext}" 2>&1
            declare status=$?

            if ((status))
            then
                github-api-echo -- "curl returned with error :$status"
                curl-cat
                return $status
            fi

            declare htmlstatus
            htmlstatus=$(grep "Status:" "$curlheaders" | sed -e 's/Status: //' -e 's/ .*//')
            case $htmlstatus in
                200 )
                    ## Consolidate paged data.
                    if (( $(wc -l < "${curldata}.${pageprint_ext}") > 3))
                    then
                        ## The file is not empty
                        echo ',' >> "$curldata"
                        if cat "${curldata}.${pageprint_ext}" >> "$curldata"
                        then
                            rm -f "${curldata}.${pageprint_ext}"
                        else
                            github-api-echo --ec -- "Paging consolidation error. Exiting."
                            return 1
                        fi
                    fi
                    ;;
                403 )
                    ## Forbidden. Probably hit a query limit.
                    cat "$curlheaders"
                    ;;
                404 )
                    ## Sometimes, even though pagination of the returned
                    ## data is indicated, the data is not paginated. If we
                    ## got here and got a 404, let's assume all the data is
                    ## in the prior set of data (there must have been at
                    ## least one good set or we wouldn't have even gotten
                    ## into this pagination-handing loop) and move on.

                    ## Fake a good header
                    echo "Status: 200 OK" > "$curlheaders"

                    break ## while
                    ;;
                * )
                    cat "$curlheaders"
                    exit
                    ;;
            esac
            parse-next-last "$curlheaders"
        done
        ## Print the last progress, maybe
        print-progress "$opt_verbose" "$opt_no_progress" "$opt_progress" "$pagenum" 'last'

        ## $curldata is invalid json because each page is a list instead of
        ## all the data in one list. We added the commas above. Now we pull
        ## out the superfluous ][ here:
        declare curldata_relist
        curldata_relist=$(mktemp -t tmp.github-api.curldata_relist.$$.XXXXXXXXXX)
        perl -e '
BEGIN { print(qq([\n)); }
while(<>){
  chomp;
  print qq($_\n) if($_ ne q([) and $_ ne q(]));
}
END { print(qq(]\n)); }
' "$curldata" > "$curldata_relist"
        mv "$curldata_relist" "$curldata"
    fi
    declare htmlstatus
    htmlstatus=$(grep "Status:" "$curlheaders" | sed -e 's/Status: //' -e 's/ .*//')
    case $action in
        repos )
            if [[ -n $repo ]]
            then
                declare curldata_filter
                curldata_filter=$(mktemp -t tmp.github-api.curldata_filter.$$.XXXXXXXXXX)
                perl -MJSON::XS -e '
open IH, q(<), $ARGV[0];
$data = join(q(),<IH>);
close(IH);
$json = decode_json($data);
my @js;
my $re = qr/$ARGV[1]/;
for my $j (@{$json}) {
  if ( $j->{name} =~ m/$re/ ) {
    push @js, $j;
  }
}
print(JSON::XS->new->pretty(1)->encode(\@js));
' "${curldata}" "$repo" > "$curldata_filter" || exit $?
                mv "$curldata_filter" "$curldata"
            fi
            ;;
        contents)
            case $htmlstatus in
                200 )
                    # shellcheck disable=SC2016 # Yes, I know I have a '$' in single quotes.
                    echo '$VAR1=' > "$perldata"
                    json_xs -t dumper < "$curldata" >> "$perldata"
                    echo ';'
                    perl -MMIME::Base64 -e 'do $ARGV[0]; print decode_base64($VAR1->{content})' "$perldata"
                    ;;
                * )
                    github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                    curl-cat
                    return 1
                    ;;
            esac
            ;;

        exists )
            case $htmlstatus in
                200 )
                    ((opt_data_mode==0)) && github-api-echo -- "Repo exists."
                    ;;
                404 )
                    github-api-echo -e -- "'${opt_server}:$org/$repo' not found."
                    return 1
                    ;;
                * )
                    github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                    curl-cat
                    return 1
                    ;;
            esac
            ;;

        list-forks )
            case $htmlstatus in
                200 )
                    # shellcheck disable=SC2016 # Yes, I know I have a '$' in single quotes.
                    echo '$VAR1=' > "$perldata"
                    json_xs -t dumper < "$curldata" >> "$perldata"
                    perl -e 'do $ARGV[0]; print join(qq(\n), sort map {$_->{full_name}} @$VAR1)' "$perldata"
                    return 1
                    ;;
#               301 )
#                   declare newurl
#                   newurl=$(perl -MJSON::XS -e '
#open IH, q(<), $ARGV[0];
#$data = join(q(),<IH>);
#close(IH);
#$json = decode_json($data);
#$url = $json->{url};
#$url =~ s|$ARGV[1]||;
#print qq($url);' "${curldata}" "${server_url}")
#                   github-api-echo -- "Need a --no-fork option below...Re-directing..."
#                   github-api-echo --dc -- "exec $0 --override-url \"$newurl\" \"${re_exec[@]}\""
#                   pause
#                   exec $0 --override-url "$newurl" "${re_exec[@]}"
#                   ;;
                404 )
                    github-api-echo -e -- "'${opt_server}:$org/$repo' not found."
                    return 1
                    ;;
                * )
                    github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                    curl-cat
                    return 1
                    ;;
            esac
            ;;

        pulls )
            case $htmlstatus in
                200 )
                ;;
                301 )
                    declare newurl
                    newurl=$(perl -MJSON::XS -e '
open IH, q(<), $ARGV[0];
$data = join(q(),<IH>);
close(IH);
$json = decode_json($data);
$url = $json->{url};
$url =~ s|$ARGV[1]||;
print qq($url);' "${curldata}" "${server_url}")
                    exec "$0" --override-url "$newurl" "${re_exec[@]}"
                    ;;
                404 )
                    github-api-echo -e -- "'${opt_server}:$org/$repo' not found."
                    return 1
                    ;;
                * )
                    github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                    curl-cat
                    return 1
                    ;;
            esac
            ;;

        fork )
            case $htmlstatus in
                200 | 202 )
                    if ((opt_data_mode==0))
                    then
                        [[ $htmlstatus == '200' ]] && github-api-echo -- "Fork created."
                        [[ $htmlstatus == '202' ]] && github-api-echo -- "Fork found."
                        ## In the 202 case one or both of the repos could have
                        ## been renamed after the fork was originally created.
                    else
                        perl -MJSON::XS -e '
open IH, q(<), $ARGV[0];
$data = join(q(),<IH>);
close(IH);
$json = decode_json($data);
print $json->{name};' "${curldata}"
                    fi
                    ;;

                307 )
                    declare newurl
                    newurl=$(perl -MJSON::XS -e '
open IH, q(<), $ARGV[0];
$data = join(q(),<IH>);
close(IH);
$json = decode_json($data);
$url = $json->{url};
$url =~ s|$ARGV[1]||;
print qq($url);' "${curldata}" "${server_url}")
                    github-api-echo -- "Re-directing..."
                    exec "$0" --override-url "$newurl" "${re_exec[@]}"
                    ;;
                404 )
                    github-api-echo -e -- "either organization '$org' or repo '$repo' does not exist on '$opt_server'."
                    return 1
                    ;;
                * )
                    github-api-echo -e -- "HTML status $(grep "Status:" "$curlheaders")"
                    curl-cat
                    return 1
                    ;;
            esac

            if ((synchronous))
            then
                declare waiting='Waiting for fork creation...'
                declare remaining=60
                while github-api "${override_args[@]}" --server "$opt_server" list-forks "$org" "$repo" | grep -E -q '"message":\s*"Not Found"'
                do
                    [ -n "$waiting" ] && github-api-echo -- "'$waiting'" && waiting=''
                    sleep 1
                    ((remaining-=1))
                    ((remaining)) || break
                done
                if github-api "${override_args[@]}" --server "$opt_server" list-forks "$org" "$repo" | grep -E -q '"message":\s*"Not Found"'
                then
                    github-api-echo -w -- "Fork not yet created"
                    return 1
                else
                    return 0
                fi
            fi
            ;;
        user*)
            echo "No special processing for '$action' yet" >/dev/null
            ;;
    esac

    if ((opt_stream_data))
    then
        if((opt_perl_data))
        then
            # shellcheck disable=SC2016 # We know the variable will not expand.
            echo '$VAR1='
            json_xs -t dump < "${curldata}"
        elif(("${#fields[@]}"))
        then
            declare -a fields_json
            declare f
            for f in "${fields[@]}"
            do
                if((opt_keyed_fields))
                then
                    fields_json+=("$f")
                else
                    fields_json+=(".$f")
                fi
            done
            declare fields_string
            ajoin fields_string -s ', ' "${fields_json[@]}"
            if((opt_keyed_fields))
            then
                fields_string=".[] | {$fields_string}"
            else
                fields_string=".[] | $fields_string"
            fi
            if ((opt_verbose))
            then
                github-api-echo -- "Field filter command: jq -r '$fields_string' '${curldata}'"
            fi
            if ((opt_record_fields))
            then
                ##jq -r "$fields_string" "${curldata}" > "${curldata}.torecord"
                perl -ne '
BEGIN { $count = shift };
my $idx=$count;
my @output;
do {
    chomp;
    if(!$idx) {
        print(qq(@{output}\n));
        @output=();
        $idx=$count;
    }
    push @output,$_;
    $idx--;
} while (<>);' "${#fields[@]}" < <(jq -r "$fields_string" "${curldata}")
            else
                jq -r "$fields_string" "${curldata}"
            fi
        else
            cat -v "${curldata}"
        fi
    elif ((opt_verbose))
    then
        curl-cat
    fi

    if ((opt_keep_data))
    then
        github-api-echo -- "Header and data files are" "$curlheaders" "$curldata"
    fi
    return 0
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

github-api - Wrapper around curl calls to the github api

=head1 SYNOPSIS

 github-api [--server server] [--stream-data|--perl-data] [--keep-data] [--wait] [--verbose|--silent|--noexec] \
     [[--fields | --keyed-fields | --record-fields ] field[,field...]]... \
     org <orgname> |
     repos [--user] <orgname> [<reponamepattern>] |
     exists[|ping] [--data-mode] <orgname> <reponame> |
     repo <orgname <reponame> |
     list-forks <orgname> <reponame> |
     fork [--data-mode] <orgname> <reponame> |
     filename <filename-to-search-for> |
     text <text-to-search-for> |
     [--pullId N] pulls |
     contents <orgname> <reponame> path/to/file/from/repo/root[?ref=id] |
     url <serverless-url-of-api-call> |
     users | user <user-to-search-for>
     raw <full-url-of-api-call>

=head1 DESCRIPTION

Run some specific github apis. Uses your own OAuth credentials so you may not
be able to see everything. Prints its messages to stderr, all data to stdout so
you can filter the output with pipes and still see the progress messages.

Any time you are required to provide and orgname and reponame, you can provide
them as one arg: orgname/reponame.

=head1 ARGUMENTS

=over 4

=item org

Runs orgs api call. Requires an orgname. Returns metadata about that org.

=item repos

Runs repos api call. Requires an orgname. Returns metadata about all the repos
in that org. If the 'org' is a person, add the '--user' flag. Add a regular expression and
the output is limited to that repos whose names match.

=item exists|ping

Runs repos api call. Requires an orgname and a repo. Prints "Repo exists." and
exits 0 if repo found. Prints nothing and exists 1 if not. If you specify
'--data-mode', skips the print on success.

=item repo

Runs repo api call. Requires an orgname and a repo. Returns metadata for the repo
specified. More efficient than 'repos' for a single exact repo.

=item list-forks

Lists the forks of a repo. Requires an orgname and a repo.

=item fork

Create a fork, in your org, of a repo. Requires an orgname and a repo. Prints
"Fork created." or "Fork found." as appropriate. If you specify '--data-mode',
skips the print of the meessages and prints the JSON returned by the
call. Handles renames and redirections (status 307) properly.

=item filename

Find a file in all orgs/repos. Requires an filename to search for.

=item text

Find a text string in all orgs/repos. Requires an string to search for. Special characters must be provided as URL escapes (%20 for a space, %3D for an equals sign, etc.)

=item pulls

Find information about **open** pull requests.

=item contents

Get a file. Specify the path to the file relative to the repo root. The optional parameter 'ref' is the commit/branch/tag for the version you want. Default is the version at the head of the default branch.

=item url

Run any api call, expressed as the raw api, assuming the https://, server and api point portions.

=item raw

Run any api call, expressed as the raw api, starting with the https://, server and api point portions.

=back

=head1 OPTIONS

=over 4

=item --server

Default: 'github'. Also accepts 'bbgithub'.

=item --stream-data

All headers and titles are suppressed. Only the JSON data structure is sent to stdout for display. Use this if you want to ingest the output in a program.

=item --perl-data

All headers and titles are suppressed. Only the JSON data structure is converted to a Perl Data::Dumper format and sent to stdout for display. The output should be stored to a file X so it can then used via a

 do $ARGV[0];

statement in a Perl script where X is the first arg to the script.

=item --keep-data

Header and data are sent to a file for display. This options doesn't clean up after execution allowing you to use them. Filenames will be shown.

=item --wait

Whe creating a fork, wait for the fork to create before exiting. Default is to send off the command and exit, as the fork creation is async by default.

=item [--verbose|--silent|--noexec]

'verbose' shows steps and the full curl command, sans authentication info.

'silent' supresses the header and data output when you just want the return code.

'noexec' show the full curl command, sans authentication info, but does not execute it.

=item [--fields | --keyed-fields | --record-fields ]

Limits the output to only those fields you ask for in each record. Multiple
fields are separated by commas and/or you can specify multiple instances of the
same option; these two lines are equivilent:

 --fields a,b --fields c
 --fields a,b,c

The differences in the options are in the output. For a record (in JSON):

 {"name": "matt", "age": "29"}

--fields prints

 matt
 29

--keyed-fields prints

  {
    "name": "matt",
    "age"": "29"
  }

--record-fields prints

  matt 29

The last one is problematic for further field parsing if any of the data has spaces in it.

=back

=cut

__PODUSAGE__
