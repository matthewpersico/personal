#!/opt/bb/bin/perl

use strict;
use warnings;
use File::Basename;
use DateTime;
use File::Slurp;
use List::MoreUtils qw(uniq);
use Getopt::Long;
use FindBin qw($RealBin);
use File::Spec::Functions qw(catfile);

my @stdmail=(qw(mpersico5@bloomberg.net
                dbillings1@bloomberg.net));

my %next = (
    ## Key is the last monitor. Data is the next monitor.
    druoso    => {
        who => 'mpersico5',
        whonice => 'Matthew',
        mail => mkmail('mpersico5@bloomberg.net'),
    },
    mpersico5 => {
        who => 'jbonney4',
        whonice => 'Jeremiah',
        mail => mkmail('jbonney4@bloomberg.net'),
    },
    jbonney4  => {
        who => 'druoso',
        whonice => 'Daniel',
        mail => mkmail('druoso@bloomberg.net')
    },
);

my %opt= (cat => 0,
          who => 0,
          predict => 0,
          mail => 0,
          help => 0,
          datadir => catfile($RealBin, '../data'),
          ## do not init options with optional arg
          ## forward
      );

GetOptions(\%opt,
           "cat|list",
           "who|keep",
           "predict|next",
           "mail!",
           "forward:s",
           "datadir=s",
           "help");

my ($name,$path,$suffix) = fileparse($0,'.cron');
my $log = catfile($opt{datadir}, "${name}.log");
my @lines;
if ( -e $log ) {
    @lines = reverse(read_file($log, {chomp => 1}));
    ## Stored new to old, want to work old -> new
}

if ($opt{cat}) {
    print join("\n",reverse(@lines));
    exit 0;
}

if ($opt{who}) {
    print $lines[-1];
    exit 0;
}

my $now;
if( ! exists $opt{forward} ) {
    $now = DateTime->now;
} else {
    my @d;
    if( length($opt{forward}) ){
        @d = split(/\//, $opt{forward});
        $now = DateTime->new(
            year       => $d[0],
            month      => $d[1],
            day        => $d[2]);
    } else {
        @d = split(/\//, (split(/\s+/, $lines[-1]))[-1]);
        $now = DateTime->new(
            year       => $d[0],
            month      => $d[1],
            day        => $d[2]);
        $now->add( days => 1 );
    }
}
exit 0 if ($now->day_of_week() > 5);
my $hol = catfile($opt{datadir}, "${name}.holidays");
my $tdays = catfile($opt{datadir}, "${name}.tdays");
my $today = $now->ymd('/');
my %holidays = map { $_->[0] => $_->[1] } map { [ split(/-/,$_) ]} read_file($hol, {chomp => 1});
if( defined $holidays{$today} ) {
    if( $opt{mail} ) {
        qx(mailx -s '1381 Monitoring - Holiday' @{[mkmail()]} <<EOM
No 1381 Monitoring today. $today is $holidays{$today}.
EOM
);
    }
    exit 0;
}

my %tdays = (
    map { $_->[0] => $_->[1] }
      map { [split(/-/,$_)] }
      read_file($tdays, {chomp => 1})
  );
my @x;
for my $k (keys %tdays) {
    @x = split(/,/, $tdays{$k});
    $tdays{$k} = { map { $_ => 1 } @x };
}

my @data;
if( @lines ) {
    @data = split(/\s+/, $lines[-1]);
} else {
    $data[0] = 'jbonney4';
}

my $limit = scalar(keys(%next));
my @mailmsg;

while($limit>0) {
    my $n = $next{$data[0]}->{who};
    if (!exists($tdays{$today}->{$n})) {
        push @lines, "$n $today";
        $limit = -1;
    } else {
        push @mailmsg, "$n has a T day\n";
        $data[0]=$n;
        $limit--;
    }
}

if($limit == 0) {
    print "Cannot find a monitor for $today: " . Data::Dumper->Dump([$tdays{$today}],[qw(*tdays_today)]);
    exit 1;
}

if( $opt{predict} ) {
    print "The next monitor is $next{$data[0]}->{who}\n";
} else {
    write_file($log, join("\n", reverse @lines));
    push @mailmsg, "$next{$data[0]}->{whonice} is today's ($today) 1381 bucket monitor.";
    if( $opt{mail} && $next{$data[0]}->{mail} ) {
        qx(mailx -s '1381 Monitoring' $next{$data[0]}->{mail} <<EOM
@mailmsg
EOM
);
    } else {
        print "@mailmsg\n";
    }
}

sub mkmail {
    return join(' ', uniq(@_,@stdmail));
}
