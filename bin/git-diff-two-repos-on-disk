#!/usr/bin/env bash

# git-diff-two-repos-on-disk

declare OPTSARGS
OPTSARGS=$(getoptp -o h --long nocolor,help,exclude:,side-by-side -n "${FUNCNAME[@]}" -- "$@")
declare status=$?
((status != 0)) && script-usage && exit $status

declare nocolor=0
declare exclude=''
declare side_by_side='-u'
eval set -- "$OPTSARGS"
while true
do
    case "$1" in
        -h|--help)
            script-usage
            exit 0 ;;
        --nocolor)
            nocolor=1 ; shift ;;
        --exclude)
            exclude=$2; shift; shift ;;
        --side-by-side)
            side_by_side='-y --suppress-common-lines'; shift;;
        --)
            shift; break ;; ## end of opts, remaining $*, if any, are args
        *)
            cmd-echo "Internal error!"; script-usage ; exit 1 ;;
    esac
done

declare -A repo
if [ -n "$2" ]
then
    repo[left]=$(realpath "$1")
    repo[right]=$(realpath "$2")
elif [ -n "$1" ]
then
    repo[left]=$(pwd)
    repo[right]=$(realpath "$1")
else
    cmd-echo "Need at least one directory"
    script-usage; exit 1 ;
fi

if [ "${repo[left]}" = "${repo[right]}" ]
then
    cmd-echo "Other dir is this dir. Whoops! Bye."
    exit 1
fi

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"
declare -A list
list[left]=$(mktemp -t tmp.git-diff-two-repos-on-disk.left.XXXXXXXXXX)
list[right]=$(mktemp -t tmp.git-diff-two-repos-on-disk.right.XXXXXXXXXX)
rm_on_exit "${list[left]}" "${list[right]}"

# Get lists of files from each repo
declare which
declare -A leftfiles
declare -A rightfiles
for which in left right
do
    perl -e 'chdir $ARGV[0];
             print qx(git ls-files)' "${repo[$which]}" > "${list[$which]}"
    if [ -n "$exclude" ]
    then
        grep -v "$exclude" "${list[$which]}" > "${list[$which]}.filt"
        mv "${list[$which]}.filt" "${list[$which]}"
    fi
    declare line
    declare key
    while IFS='' read -r line || [[ -n "$line" ]]
    do
        ## Because for some unknown reason a directory spec with a '/' in it
        ## was giving me some weird error.
        key=${line//\//%2F}

        ## Yes, there's some indirect referencing here. Not my fault there are
        ## no multi-level arrays/hashes in bash.
        eval "${which}files[$key]=${repo[$which]}/$line"
    done < "${list[$which]}"
done

declare -A missingright
for key in "${!leftfiles[@]}"
do
    if [ -z "${rightfiles[$key]}" ]
    then
        missingright[$key]=${key//%2F/\/}
        unset leftfiles["$key"]
    fi
done
[ "${#missingright[@]}" != '0' ] &&  cmd-echo "These files do not exist in ${repo[right]}" "${missingright[@]}"

declare -A missingleft
for key in "${!rightfiles[@]}"
do
    if [ -z "${leftfiles[$key]}" ]
    then
        missingleft[$key]=${key//%2F/\/}
        unset rightfiles["$key"]
    fi
done
[ "${#missingleft[@]}" != '0' ] &&  cmd-echo "These files do not exist in ${repo[left]}" "${missingleft[@]}"

for key in "${!leftfiles[@]}"
do
    declare output
    declare leftf
    leftf=${leftfiles["$key"]}
    declare rightf=${rightfiles["$key"]}
    output=$(diff -q "$leftf" "$rightf" 2>&1 | grep -v 'Common subdirectories')
    if [ -n "$output" ]
    then
        cmd-echo -- '-----'
        declare diffcmd
        # shellcheck disable=SC2230
        diffcmd=$(which colordiff 2>/dev/null)
        # shellcheck disable=SC2209 # We don't want to run diff, just
        # prepare the command
        ( [ -z "$diffcmd" ] || ((nocolor)) ) && diffcmd=diff
        $diffcmd "$side_by_side" "${leftf}" "${rightf}"
        echo
    fi
done

exit 0

## You can add sections with =head1, but stick to =item for section breakdowns,
## not =head2/3/etc/. If you want just plain text, get rid of pod tags and the
## 'POD' in __PODUSAGE__.

:<<'__USAGE__'

Usage: git-diff-two-repos-on-disk [--nocolor] [src] tgt
       git-diff-two-repos-on-disk [-h|-help]

       Compare two repos on disk. If only one repo is specified,
       'src' is taken as the current directory, which should be
       a repo root.

__USAGE__
