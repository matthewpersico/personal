#!/usr/bin/env bash

echo "$(date): git-commit" >> "$HOME/.gitaudit"

# git-commit

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

if ! git-version-verify 'git-commit'
then
    exit 1
fi

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        echo "** Extended actions **"
        bash-usage "$0"
        echo
        echo "** Standard actions **"
        "$REALGIT" commit --help
    ) 2>&1 | ${PAGER:-less}
}

## Functions that encapsulate the enhanced functionality. main() is defined
## last and called last.
git-commit-scl()
{
    git-commit-with-source-ctrl-log-guts "$@"
    return $?
}

main ()
{
    declare opt_scl=0
    declare moreopts=1
    declare -a pass_on_args
    declare -a opt_message
    declare opt_extref=''
    declare do_push=0
    declare opt_pr=''

    ## This hunk of processing was written after git-clone and is an attempt to
    ## NOT have to duplicate all existing arg process, as is done in git-clone,
    ## because we only need to pick specific options.
    while [ -n "$1" ] && ((moreopts))
    do
        declare original="$1"
        shift
        if [[ "$original" =~ ^- ]]
        then
            declare option
            option=$(dashstripper "$original")
            ## This bit deals with --foo=bar instead of --foo bar
            declare okey=''
            declare ovalue=''
            ## but only deal with it if we really have an option. Otherwise you
            ## misinterpret items like this git clone option: --config
            ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
            if [[ $option =~ ^- ]]
            then
                if [[ "$option" =~ = ]]
                then
                    okey=${option%%=*}
                    ovalue=${option#*=}
                    option="$okey"
                fi
            fi

            case $option in
                h | help )
                    usage ''
                    exit 0
                    ;;
                wc | wscl )
                    cmd-echo -- "--$option is deprecated. Use --scl in the future."
                    ;& ## bash fall through and unconditionally execute next case
                scl )
                    opt_scl=1
                    ## no pass_on_args here, we use the flag as a switch later
                    continue
                    ;;
                sclonly )
                    opt_scl=1
                    ## We DO pass this arg on
                    ;;
                eref )
                    opt_extref=" - ${ovalue:-$1}"
                    [ -z "$ovalue" ] && shift
                    ## no pass_on_args here, this is added to the message
                    continue
                    ;;
                dref )
                    opt_extref=" - $(basename "$(git root)")"
                    ## no pass_on_args here, this is added to the message
                    continue
                    ;;
                m* )
                    message=${ovalue:-$1}
                    [ -z "$ovalue" ] && shift

                    ## Amend the message
                    case $option in
                        mnew)
                            message="NEW: $message"
                            ;;
                        mimp)
                            message="IMPROVE: $message"
                            ;;
                        mfix)
                            message="FIX: $message"
                            ;;
                        mrel)
                            message="RELEASE: $message"
                            ;;
                        mdoc)
                            message="DOC: $message"
                            ;;
                        mtst)
                            message="TEST: $message"
                            ;;
                        mjira)
                            ## Currently formatted so that it's really easy to
                            ## cut 'n paste in the PR on GitHub.
                            declare limidx=49
                            message="${message:0:$limidx}
${message:$limidx} - $(git worktree get-name)"
                            pass_on_args+=('-e')
                            ;;
                    esac
                    opt_message=('-m' "$message")
                    ## no pass_on_args here, we'll build the message later
                    continue
                    ;;
                ammend )
                    cmd-echo "Can you please learn how to spell 'amend'?"
                    original='--amend'
                    ## pass this on, updated
                    ;;
                no-hooks | nohooks | noverify )
                    cmd-echo -- "$original => --no-verify"
                    original='--no-verify'
                    ## pass this on, updated
                    ;;
                push )
                    do_push=1
                    ## no pass_on_args here, processed after commit
                    continue
                    ;;
                pr )
                    do_push=1
                    opt_pr='--pr'
                    ## no pass_on_args here, processed after commit
                    continue
                    ;;
                ## No '*)' case needed; anything else just gets passed on
            esac
        fi

        ## If we are here, pass it on
        pass_on_args+=("$original")
    done

    ((do_push)) && cmd-echo -- 'Committing...'
    if ((opt_scl))
    then
        git-commit-scl "${pass_on_args[@]}"
    else
        if [ -n "${opt_message[1]}" ]
        then
            opt_message[1]="${opt_message[1]}$opt_extref"
        fi
        "${REALGIT}" commit "${opt_message[@]}" "${pass_on_args[@]}"
    fi
    status=$?

    if ((status== 0 && do_push))
    then
        cmd-echo -- 'Pushing...'
        git push $opt_pr
        status=$?
    fi

    return $status
}

main "$@"

exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-commit - git extention of git commit

=head1 SYNOPSIS

 git commit -scl
 git commit -sclonly
 git commit -m[emojid] "message" [-eref reference |-dref]
 git commit --no-hooks
 git commit --push

=head1 DESCRIPTION

Extensions to the 'git commit' command. Any action not described here will be passed onto the actual 'git commit' command.

=head1 EXTENSIONS

=over 4

=item --scl

Use the local $GITFUNCS_SOURCE_CTRL_LOG_NAME file for commit
messages.

=item --sclonly

Only process files that have entries in $GITFUNCS_SOURCE_CTRL_LOG_NAME. The
default is to fail if a file to be considered is missing an entry in
$GITFUNCS_SOURCE_CTRL_LOG_NAME. In general, do not specify particlar files when
using this flag. Let the contents of the file determine which files to
commit. **Note** - you still need to use the '-a' flag to consider files that
have been modifed but not yet added to the index.

=item -m[emjoid]

Add a text tag to the start of the commit message. There is supposed to be an
associated emoji, but I think they are UTF 16 and the current OS settings are
using UTF 8 at best.

 mnew - NEW:

 mimp - IMPROVE:

 mfix - FIX:

 mrel - RELEASE:

 mdoc - DOC:

 mtst - TEST:


=item -eref reference

Add the text "- reference" to the end of the commit message.

=item -dref

Add the text "- $(basename $(git root))" to the end of the commit message. Good
if your repo dirs are worktrees whose names correspond to the workflow system
item id related to this work.

=item --no-hooks

Alias for --no-verify.

=item --push

After a successful commit, run 'git push' using all the defaults for remote and
other push options.

=back

=cut

__PODUSAGE__
