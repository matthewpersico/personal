#!/usr/bin/env bash

echo "$(date): git-commit" >> "$HOME/.gitaudit"

# git-commit

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

if ! git-version-verify 'git-commit'
then
    exit 1
fi

## Functions that encapsulate the enhanced functionality. main() is defined
## last and called last.

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        echo "** Extended actions **"
        bash-usage "$0"
        echo
        echo "** Standard actions **"
        "$REALGIT" commit --help
    ) 2>&1 | ${PAGER:-less}
}

git-commit-with-source-ctrl-log ()
{
    declare opt_a
    declare opt_v
    declare -a opt_edit
    declare -A opt_exclude
    declare opt_skip
    declare opt_debug
    declare opt_confirm=''
    declare -a opt_scl_pick
    declare moreopts=1
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        declare option
        option=$(dashstripper "$original")
        shift

        case $option in
            a ) opt_a='-a';;
            v ) opt_v='-v';;
            e ) opt_edit=(--edit --editor "$EDITOR");;
            editor ) opt_edit=(--edit --editor "$1"); shift;;
            s ) opt_skip='--skip-no-source-ctrl-log';;
            sclpick ) opt_scl_pick=("$original" "$1"); shift;;
            sclonly ) opt_skip='--sclonly' ;;
            nosclonly ) opt_skip='--nosclonly' ;;
            c | confirm ) opt_confirm='--confirm';;
            exclude | ex) opt_exclude["$(realpath "$1")"]=1; shift;;
            h | help )
                bash-usage "$0"
                exit 0 ;;
            debug | x ) set -x; opt_debug='-x'; trap 'set +x' EXIT ;;
            --)
                moreopts=0
                ;;
            * )
                cmd-echo -- "$original is an invalid option. See $0 --help"; exit 1;;
        esac
    done

    ## Locate all the files to process
    declare -a filenames
    if (($#))
    then
        ## Process what's specified
        filenames=("$@")
    else
        if [ -z "$opt_a" ]
        then
            ## We want to mimic the same behavior as git commit with no filenames
            ## (default to only staged files), but we need to pass files into
            ## git-process-source-ctrl-log, so we grab the staged files.
            mapfile -t filenames < <(git what is staged)
        else
            ## This mimics git commit -a; commit staged and unstaged files that are
            ## modified.
            mapfile -t filenames < <(git what is modified)
        fi
    fi

    ## Process any exclusions
    if (( ${#opt_exclude[@]} > 0 ))
    then
        declare -a included
        declare i
        for i in $(seq 0 $((${#filenames[@]}-1)))
        do
            declare filepath
            filepath="$(realpath "${filenames[$i]}")"
            if [ "${opt_exclude[$filepath]}" = '' ]
            then
                included+=("$filepath")
            fi
        done
        filenames=("${included[@]}")
    fi
    git-process-source-ctrl-log --commit \
                                $opt_confirm $opt_v $opt_debug "${opt_edit[@]}" \
                                $opt_skip "${opt_scl_pick[@]}" "${filenames[@]}"
    status=$?
    return $status
}

main ()
{
    declare opt_scl=0
    # This is a shellcheck bug. Reported https://github.com/koalaman/shellcheck/issues/1913
    # shellcheck disable=SC2178 #https://github.com/koalaman/shellcheck/wiki/SC2178
    declare opt_scl_pick=0
    declare moreopts=1
    declare -a pass_on_args
    declare -a opt_message
    declare opt_extref=''
    declare do_push=0
    declare opt_pr=''

    ## This hunk of processing was written after git-clone and is an attempt to
    ## NOT have to duplicate all existing arg process, as is done in git-clone,
    ## because we only need to pick specific options.
    while [ -n "$1" ] && ((moreopts))
    do
        declare original="$1"
        shift
        if [[ "$original" =~ ^- ]]
        then
            declare option
            option=$(dashstripper "$original")
            ## This bit deals with --foo=bar instead of --foo bar
            declare okey=''
            declare ovalue=''
            ## but only deal with it if we really have an option. Otherwise you
            ## misinterpret items like this git clone option: --config
            ## "remote.origin.fetch=+refs/pull/*/head:refs/remotes/origin/pr/*'
            if [[ $option =~ ^- ]]
            then
                if [[ "$option" =~ = ]]
                then
                    okey=${option%%=*}
                    ovalue=${option#*=}
                    option="$okey"
                fi
            fi

            case $option in
                h | help )
                    usage ''
                    exit 0
                    ;;
                wc | wscl )
                    cmd-echo -- "--$option is deprecated. Use --scl in the future."
                    ;& ## bash fall through and unconditionally execute next case
                scl )
                    opt_scl=1
                    ## no pass_on_args here, we use the flag as a switch later
                    continue
                    ;;
                sclonly )
                    opt_scl=1
                    ## We DO pass this option on
                    ;;
                sclpick )
                    opt_scl=1
                    # This is a shellcheck bug. Reported https://github.com/koalaman/shellcheck/issues/1913
                    # shellcheck disable=SC2178 #https://github.com/koalaman/shellcheck/wiki/SC2178
                    opt_scl_pick=${ovalue:-$1}
                    [ -z "$ovalue" ] && shift
                    ## We DO pass this option on, but since it has its own arg, we handle it here
                    # This is a shellcheck bug. Reported https://github.com/koalaman/shellcheck/issues/1913
                    # shellcheck disable=SC2128 #https://github.com/koalaman/shellcheck/wiki/SC2128
                    pass_on_args+=("$original" "$opt_scl_pick")
                    continue
                    ;;
                eref )
                    opt_extref=" - ${ovalue:-$1}"
                    [ -z "$ovalue" ] && shift
                    ## no pass_on_args here, this is added to the message
                    continue
                    ;;
                dref )
                    opt_extref=" - $(basename "$(git root)")"
                    ## no pass_on_args here, this is added to the message
                    continue
                    ;;
                m* )
                    message=${ovalue:-$1}
                    [ -z "$ovalue" ] && shift

                    ## Amend the message
                    case $option in
                        mnew)
                            message="NEW: $message"
                            ;;
                        mimp)
                            message="IMPROVE: $message"
                            ;;
                        mfix)
                            message="FIX: $message"
                            ;;
                        mrel)
                            message="RELEASE: $message"
                            ;;
                        mdoc)
                            message="DOC: $message"
                            ;;
                        mtst)
                            message="TEST: $message"
                            ;;
                        mjira)
                            ## Currently formatted so that it's really easy to
                            ## cut 'n paste in the PR on GitHub.
                            declare limidx=49
                            message="${message:0:$limidx}
${message:$limidx} - $(git worktree get-name)"
                            pass_on_args+=('-e')
                            ;;
                    esac
                    opt_message=('-m' "$message")
                    ## no pass_on_args here, we'll build the message later
                    continue
                    ;;
                ammend )
                    cmd-echo "Can you please learn how to spell 'amend'?"
                    original='--amend'
                    ## pass this on, updated
                    ;;
                no-hooks | no-hook | nohooks | nohook | noverify )
                    cmd-echo -- "$original => --no-verify"
                    original='--no-verify'
                    ## pass this on, updated
                    ;;
                push )
                    do_push=1
                    ## no pass_on_args here, processed after commit
                    continue
                    ;;
                pr )
                    do_push=1
                    opt_pr='--pr'
                    ## no pass_on_args here, processed after commit
                    continue
                    ;;
                ## No '*)' case needed; anything else just gets passed on
            esac
        fi

        ## If we are here, pass it on
        pass_on_args+=("$original")
    done

    ((do_push)) && cmd-echo -- 'Committing...'
    if ((opt_scl))
    then
        git-commit-with-source-ctrl-log "${pass_on_args[@]}"
    else
        if [ -n "${opt_message[1]}" ]
        then
            opt_message[1]="${opt_message[1]}$opt_extref"
        fi
        "${REALGIT}" commit "${opt_message[@]}" "${pass_on_args[@]}"
    fi
    status=$?

    if ((status== 0 && do_push))
    then
        cmd-echo -- 'Pushing...'
        git push $opt_pr
        status=$?
        if [[ -z $opt_pr ]]
        then
            declare pr_or_msg
            if pr=$(git repo pr-get)
            then
                cmd-echo -- "Pull request is $pr_or_msg"
                git repo pr-store "$pr_or_msg"
            else
                cmd-echo -- "$pr_or_msg"
            fi
        fi
    fi

    return $status
}

main "$@"

exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-commit - git extention of git commit

=head1 SYNOPSIS

 git commit -scl | --sclonly | --sclpick
 git commit -m[emojid] "message" [-eref reference |-dref]
 git commit --no[[-]hook[s]|verify]
 git commit --push|--pr

=head1 DESCRIPTION

Extensions to the 'git commit' command. Any action not described here will be passed onto the actual 'git commit' command.

=head1 EXTENSIONS

=over 4

=item --scl

Use the local $GITFUNCS_SOURCE_CTRL_LOG_NAME file for commit
messages.

=item --sclonly

Only process files that have entries in $GITFUNCS_SOURCE_CTRL_LOG_NAME. The
default is to fail if a file to be considered is missing an entry in
$GITFUNCS_SOURCE_CTRL_LOG_NAME. In general, do not specify particlar files when
using this flag. Let the contents of the file determine which files to
commit. **Note** - you still need to use the '-a' flag to consider files that
have been modifed but not yet added to the index.

=item --sclpick

TBD

=item -m[emjoid]

Add a text tag to the start of the commit message. There is supposed to be an
associated emoji, but I think they are UTF 16 and the current OS settings are
using UTF 8 at best.

 mnew - NEW:

 mimp - IMPROVE:

 mfix - FIX:

 mrel - RELEASE:

 mdoc - DOC:

 mtst - TEST:

=item -eref reference

Add the text "- reference" to the end of the commit message.

=item -dref

Add the text "- $(basename $(git root))" to the end of the commit message. Good
if your repo dirs are worktrees whose names correspond to the workflow system
item id related to this work.

=item --no[[-]hooks|verify

Aliases for --no-verify.

=item --push

After a successful commit, run 'git push' using all the defaults for remote and
other push options.

=item --pr

After a successful commit, run 'git push' using all the defaults for remote and
other push options and then open up a browser to a pull request creation page.

=back

=cut

__PODUSAGE__
