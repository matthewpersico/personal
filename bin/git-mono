#!/usr/bin/env bash
# shellcheck disable=SC2164 # cd || exit

# dpkgrefrepos

# shellcheck disable=SC2034
declare DEBUG__this_script=$0

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

do-on-exit set +x

declare owd
owd=${PWD}

declare -A repos

set_repos ()
{
    declare repo=$1
    declare option=$2

    declare -a repos_tmp
    if [ "$repo" = ':all' ]
    then
        repos_tmp[0]=''
        option=pattern
    else
        IFS=, read -ra repos_tmp <<< "$repo"
    fi

    if [[ "$option" =~ (rp|patt) ]]
    then
        for repo_pattern in "${repos_tmp[@]}"
        do
            for repo in $( git go --listfull "$repo_pattern")
            do
                repos[$repo]=1
            done
        done
    else
        for repo in "${repos_tmp[@]}"
        do
            repos[$repo]=1
        done
    fi
    return 0
}

main ()
{
    declare moreopts=1
    declare quiet=0
    declare silent=0
    declare opt_repo
    declare opt_update
    declare opt_pause=0
    declare repo
    declare opt_rcge=-1
    fmt=''
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        if [[ "$option" =~ = ]]
        then
            okey=${option%%=*}
            ovalue=${option#*=}
            option="$okey"
        fi

        case $option in
            u | update )
                opt_update=1
                ;;
            r | rp | repo | repopatt )
                opt_repo=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                set_repos "$opt_repo" "$option"
                ;;
            p | pause )
                opt_pause=1
                ;;
            ## standard options
            h | help )
                bash-usage "$0"
                exit 0
                ;;
            quiet | q )
                quiet=1
                silent=0
                opt_rcge=-1
                ;;
            silent | s )
                quiet=0
                silent=1
                opt_rcge=-1
                ;;
            rcge )
                quiet=0
                silent=0
                opt_rcge=${ovalue:-$1}
                [ -z "$ovalue" ] && shift
                ;;
            x )
                set -x
                ;;
            --)
                moreopts=0
                ;;
            * )
                cmd-echo -- "$original is an invalid option. See $0 --help"
                exit 1
                ;;
        esac
    done

    if ((${#repos[@]} == 0))
    then
        ## Grab them all
        set_repos ':all' 'pattern'
    fi

    ## These commands return results with relative filenames in them. This code
    ## makes them print out as non-relative.
    if { [ "$1" = 'git' ] \
             && [[ "$2" =~ ^(find|grep|ls-files)$ ]]
       } \
           || [ "$1" = 'git-find' ] \
           || [ "$1" = 'git-grep' ]
    then
        # shellcheck disable=SC2016
        fmt='${repo}/'
    fi

    declare -a execmel
    declare -a execmer
    declare -a lsfiles
    declare need_lsfiles=0
    for arg in "$@"
    do
        if [[ $arg != 'LSFILES' ]]
        then
            if ((need_lsfiles == 1))
            then
                execmer+=("$arg")
            else
                execmel+=("$arg")
            fi
        else
            need_lsfiles=1
        fi
    done

    for repo in "${!repos[@]}"
    do
        builtin cd "$repo"
        ((opt_update)) && git pull
        declare t
        t=$(mktemp -t tmp.dpkgrefrepos.XXXXXXXXXX)
        rm-on-exit "$t"
        declare status
        if ((need_lsfiles))
        then
            mapfile -t lsfiles < <(git ls-files)
        else
            lsfiles=()
        fi
        "${execmel[@]}" "${lsfiles[@]}" "${execmer[@]}" > "$t" 2>&1
        status=$?
        if (( opt_rcge > -1 ))
        then
            if (( status >= opt_rcge ))
            then
                echo
                cmd-echo -- "*** $repo"
            fi
        elif (( quiet==0 && silent==0 ))
        then
            echo
            cmd-echo -- "*** $repo"
        fi

        ## We wc on words (-w) and not lines (-l) because some commands print
        ## blank lines instead of nothing when they do nothing.
        if (( $(wc -w 2>/dev/null < "$t") ))
        then
            if (( quiet ))
            then
                echo
                cmd-echo -- "*** $repo"
            fi
            declare line
            while read -r line
            do
                echo "$(eval echo ${fmt})${line}"
            done < "$t"
        fi
        ((opt_pause)) && cmd-pause "Return to continue..."
    done
    builtin cd "$owd"
    set +x
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git mono - run a git command over a list of repos

=head1 SYNOPSIS

 git mono [-r repo[,repo...] [ --repo repo[,repo ...] ... ] ] \
          [--quiet|--silent|--rcge n] [-u|--update] command [args...]

 git mono [--rp repopatt[,repopatt...] [ --rp repopatt[,repopatt ...] ... ] ] \
          [--quiet|--silent--rcge n] [-u|--update] command [args...]

=head1 DESCRIPTION

Run 'command' over each repo.

=head1 OPTIONS

=over 4

=item -r|--repo

An exact path to an existing repo. If the repo spec is ':all', we search all
repos found via 'gitgo --listfull'. Multiple options and comma separated lists
are both accepted. If neither --repo or --repopatt are specified, we will
execute over all repos found via 'gitgo --listfull'.

=item --rp|--repopatt

A repo spec that matches one or more repos via 'gitgo --listfull'. If the repo
spec is ':all', we search all repos we can find. Multiple options and comma
separated lists are both accepted. If neither --repo or --repopatt are
specified, we will execute over all repos found via 'gitgo --listfull'.

=item --quiet

Only print a repo header if there is output from the command executed in the repo.

=item --silent

Never print a repo header even if there is output from the command executed in the repo.

-item --rcge n

Only print a repo header if the return code from the command is greater than or
equal to 'n'. This is a good way to print headers only on failures (--rcge 1).

=item -u|--update

execute 'git pull' on each repo before executing the command

=back

=head1 ARGUMENTS

=over 4

=item command ["LSFILES"] [args...]

The command and its arguments are run in each repo specified, cd'ing to the
repo before running. If command is a git command, you need to specify the 'git'
part.

If the command needs the files of a repo as arguments, the string LSFILES will
be replaced with the output of '$(git ls-files)' before being executed.

=back



=cut

__PODUSAGE__
