#!/usr/bin/env bash

# cmd-echo

## ANSI_reset is in the env, variable is not all caps, so shellcheck
## complains.
# shellcheck disable=SC2154
declare reset_normal="${ANSI_reset}"
declare reset_title=''
declare nonl=''
declare continueline=0
declare head=0
declare title=0
declare join=0
declare id=''
declare append=0
declare prefix='>>> '
declare opt_color=0
declare -A colors
colors=([WARNING]=${ANSI_BG_orange}
        [ERROR]=${ANSI_BG_red}
        [DEBUG]=${ANSI_BG_blue})
declare msg_status=''
declare interactive=1
[ ! -t 1 ] && interactive=0

# Read the options and args from command line. Note that the long and short
# don't have to match up.
declare OPTSARGS
declare shortopts='inachfsojwedp::x'
declare longopts='head,title,id:,help,wc,ec,dc,color,oii'
OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@") ## "${FUNCNAME[0]}" -- "$@") for functions
declare status=$?
((status != 0)) && exit $status ## return $status ## in functions

# Reset the command line ($@).
eval set -- "$OPTSARGS"

# Reprocess the command line, extracting options and their arguments into
# variables.
while true
do
    declare option=$1
    shift
    [ "$option" != '--' ] && option=${option##-} && option=${option##-}
    case "$option" in
        head )
            head=1 ;;
        title )
            head=1
            title=1
            reset_title="${reset_normal}"
            reset_normal=''
            ;;
        id )
            # shellcheck disable=SC2034 # id is referenced indirectly below:
            ##                               for i in "id" "msg_status"
            id="$1"; shift ;;
        i )
            interactive=1 ;;
        n )
            nonl='-n' ;;
        a )
            append=1 ;;
        c )
            continueline=1 ;;
        h | help )
            script-usage cmd-echo && exit 0;;
        f | s | o )
            echo "cmd-echo: -f, -s and -o are no longer used. Ignored..." ;;
        j )
            join=1 ;;
        wc )
            opt_color=1
            ;&
        w )
            msg_status='WARNING' ;;
        ec )
            opt_color=1
            ;&
        e )
            msg_status='ERROR' ;;
        dc )
            opt_color=1
            ;&
        d )
            msg_status='DEBUG' ;;
        color )
            echo "cmd-echo: --color is no longer used. Ignored..." ;;
        oii | only-if-interactive )
            ((interactive==0)) && exit 0 ;;
        p )
            prefix=$1; shift ;;
        x )
            set -x;;
        -- ) break ;; ## ## VITAL!!! Exits the while loop, no more options,
                      ## remaining $*, if any, are args
        * )
            echo "cmd-echo: '$option' is an invalid option."
            exit 1
            ;;
    esac
done

declare docolor=${ANSI_reverse}
declare dorest=${reset_title}
declare doresn=${reset_normal}
if ((! interactive ))
then
    ## STDOUT is redirected away from the terminal, assume it's a file, don't
    ## print the colorizing sequences.
    docolor=''
    dorest=''
    doresn=''
else
    if((opt_color)) && [[ -n $msg_status ]]
    then
        docolor=${colors[$msg_status]}
    fi
fi
((head)) && echo
for arg in "$@"
do
    if [ -n "${id}" ]
    then
        prefix="$prefix${id} - "
        id=''
    fi
    if [ -n "${msg_status}" ]
    then
        prefix="$prefix${msg_status}:"
        msg_status=''
    fi

    if ((append))
    then
        prefix=''
    fi

    if ((continueline))
    then
        ## Substitutes all characters for spaces, giving us a properly
        ## spaced indent, which indicates a continuation of the prior line.
        # shellcheck disable=SC2001
        prefix=$(echo "$prefix" | sed 's/./ /g')
    fi

    if ((join))
    then
        echo $nonl -e "${docolor}${prefix}$*${dorest}${doresn}"
    else
        echo $nonl -e "${docolor}${prefix}${arg}${dorest}${doresn}"
    fi

    ## If there is a next line, it should be a continue line
    ((continueline)) || continueline=1

    ## Reset out of title
    if ((title))
    then
        title=0 ## no need to reset for ever
        reset_normal="${doresn}"
        reset_title=''
    fi
    if ((join))
    then
        break
    fi
done

exit 0 ## USAGE guard during sourcing this file.

:<<'__PODUSAGE__'
=head1 NAME

  cmd-echo - label echo with some prefix and highlighting

=head1 SYNOPSIS

cmd-echo [--oii] [--head] [--title] [-n] [-a] [-c] [-i] [-id "id" ] \
         [j] [ [-w[c]|-e[c]|-d[c]] [-p 'prefix' ] -- "text" ["text"...]

=head1 DESCRIPTION

Call 'cmd-echo' to print the first "text" on a line with a reversed-color
prefix. Print subsequent lines indented with reversed color spaces, indicating
continuation. The name of the calling script is no longer printed. Too
difficult get it right with a mixture of functions and scripts at different
nesting levels. It is sufficient just to be able to pick out our messages vs
those printed by the utilities we call.

The reverse coloring is skipped if the output is not a terminal; i.e., a log
file.

=head1 OPTIONS

=over 4

=item --

Indicates end of options to 'cmd-echo' so that all subsequent arguments are
taken as text to print. Technically not necessary UNLESS your first argument to
print happens to match one of the options to 'cmd-echo'.

=item --oii|--only-if-interactive

If --oii is specified and cmd-echo is called in a non-interactive mode (calling
script output is redirected to a file, for example), exit 0 without printing
anything.  When this flag is not used, then non-interactive prints are still
performed, but the ascii control codes for colorization are not printed.

=item --head

Print a blank line for spacing before printing any text.

=item --title

Print a blank line for spacing before printing any text and then print the
entire first text line as reversed, not just the prefix.

=item -n

Do not print a new line at the end of each line.

-item -a

Do not print the prefix when printing these lines. Using in conjunction with -n
and specifying only one line for each call allows you 'a'ppend to a single line
as progress takes place in your process.

=item -c

Print the first "text" element as a continuation line.

=item -i

Force interactive mode to force the colorization strings. Used when the output
is being passed onto some other command as a prompt.

=item -id

Prefix the first line of the message with this text and a ": " and indent
subsequent lines accordingly.

=item -j

Instead of printing each argument on its own line, print them all on one line,
separated by one space each.

=item -w|-e|-d

Print the string 'WARNING', 'ERROR', or 'DEBUG' before the message.

=item -wc|-ec|-dc

Print the string 'WARNING', 'ERROR', or 'DEBUG' before the message with an
orange (easier to read than yellow), red or blue background, respectively.

=item -p

Instead of '>>> ' printed before each line, print this instead. A blank prefix
('') does what you'd expect.

=back

=cut

__PODUSAGE__

#  LocalWords:  funcname shellcheck util func
