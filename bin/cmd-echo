#!/usr/bin/env bash

# cmd-echo

## ANSI_reset is in the env, variable is not all caps, so shellcheck
## complains.
# shellcheck disable=SC2154
declare reset_normal
reset_normal="${ANSI_reset}"
declare reset_title
reset_title=''
declare moreopts
moreopts=1
declare nonl
nonl=''
declare continueline
continueline=0
declare head
head=0
declare title
title=0
declare join
join=0
declare id
id=''
declare append=0

declare opt_color=0
declare -A colors
colors=([WARNING]=${ANSI_BG_orange}
        [ERROR]=${ANSI_BG_red})

declare msg_status
msg_status=''
declare interactive=1
[ ! -t 1 ] && interactive=0
while [[ "$1" =~ ^- ]] && ((moreopts))
do
    declare original="$1"
    shift
    declare option
    option=$(dashstripper "$original")
    ## This bit deals with --foo=bar instead of --foo bar
    declare okey=''
    declare ovalue=''
    if [[ "$option" =~ = ]]
    then
        okey=${option%%=*}
        ovalue=${option#*=}
        option="$okey"
    fi

    case $option in
        head ) head=1 ;;
        title )
            head=1
            title=1
            reset_title="${reset_normal}"
            reset_normal=''
            ;;
        id )
            # shellcheck disable=SC2034 # see line 101
            id=${ovalue:-$1}
            [ -z "$ovalue" ] && shift
            ;;
        i ) interactive=1 ;;
        n ) nonl='-n' ;;
        a ) append=1 ;;
        c ) continueline=1 ;;
        h | help ) script-usage cmd-echo && exit 0;;
        f | s | o )
            echo "-f, -s and -o are no longer used. Ignored..."
            ;;
        j ) join=1 ;;
        w ) msg_status='WARNING'
            ;;
        e ) # shellcheck disable=SC2034 # see line 101
            msg_status='ERROR'
            ;;
        color )
            opt_color=1
            ;;
        oii | \
            only-if-interactive )
            ((interactive==0)) && exit 0
            ;;
        --)
            moreopts=0 ;;
        -* )
            echo "cmd-echo: '$original' is an invalid option."
            exit 1
            ;;
    esac
done

declare prefix
prefix='>>> '
declare docolor=${ANSI_reverse}
declare dorest=${reset_title}
declare doresn=${reset_normal}
if ((! interactive ))
then
    ## STDOUT is redirected away from the terminal, assume it's a file, don't
    ## print the colorizing sequences.
    docolor=''
    dorest=''
    doresn=''
else
    if((opt_color)) && [[ -n $msg_status ]]
    then
        docolor=${colors[$msg_status]}
    fi
fi
((head)) && echo
for p in "$@"
do
    for i in "id" "msg_status"
    do
        if [ -n "${!i}" ]
        then
            prefix="$prefix${!i}:"
            eval ${i}=''
        fi
    done

    if ((append))
    then
        prefix=''
    fi

    if ((continueline))
    then
        ## Substitutes all characters for spaces, giving us a properly
        ## spaced indent, which indicates a continuation of the prior line.
        # shellcheck disable=SC2001
        prefix=$(echo "$prefix" | sed 's/./ /g')
    fi

    if ((join))
    then
        echo $nonl -e "${docolor}${prefix}$*${dorest}${doresn}"
    else
        echo $nonl -e "${docolor}${prefix}$p${dorest}${doresn}"
    fi

    ## If there is a next line, it should be a continue line
    ((continueline)) || continueline=1

    ## Reset out of title
    if ((title))
    then
        title=0 ## no need to reset for ever
        reset_normal="${doresn}"
        reset_title=''
    fi
    if ((join))
    then
        break
    fi
done

exit 0 ## USAGE guard during sourcing this file.

:<<'__PODUSAGE__'
=head1 NAME

  cmd-echo - label echo with some prefix and highlighting

=head1 SYNOPSIS

cmd-echo [--oii] [--head] [--title] [-n] [-a] [-c] [-i] [-id "id" ] -- "text" ["text"...]

=head1 DESCRIPTION

Call 'cmd-echo' to print the first "text" on a line with a reversed-color
prefix. Print subsequent lines indented with reversed color spaces, indicating
continuation. The name of the calling script is no longer printed. Too
difficult get it right with a mixture of functions and scripts at different
nesting levels. It is sufficient just to be able to pick out our messages vs
those printed by the utilities we call.

The reverse coloring is skipped if the output is not a terminal; i.e., a log
file.

=head1 OPTIONS

=over 4

=item --

Indicates end of options to 'cmd-echo' so that all subsequent arguments are
taken as text to print. Technically not necessary UNLESS your first argument to
print happens to match one of the options to 'cmd-echo'.

=item --oii|--only-if-interactive

If --oii is specified and cmd-echo is called in a non-interactive mode (calling
script output is redirected to a file, for example), exit 0 without printing
anything.  When this flag is not used, then non-interactive prints are still
performed, but the ascii control codes for colorization are not printed.

=item --head

Print a blank line for spacing before printing any text.

=item --title

Print a blank line for spacing before printing any text and then print the
entire first text line as reversed, not just the prefix.

=item -n

Do not print a new line at the end of each line.

-item -a

Do not print the prefix when printing these lines. Using in conjunction with -n
and specifying only one line for each call allows you 'a'ppend to a single line
as progress takes place in your process.

=item -c

Print the first "text" element as a continuation line.

=item -i

Force interactive mode to force the colorization strings. Used when the output
is being passed onto some other command as a prompt.

=item -id

Prefix the first line of the message with this text and a ": " and indent
subsequent lines accordingly.

=item -j

Join?

=item -w|-e

Print WARNING or ERROR before the message

=back

=cut

__PODUSAGE__

#  LocalWords:  funcname shellcheck util func
