# -*- sh -*-
# shellcheck shell=bash

# cmd-echo

## ANSI_reset is in the env, variable is not all caps, so shellcheck
## complains.
declare reset_normal="${ANSI_RESET}"
declare reset_title=''
declare nonl=''
declare local_nonl=''
declare continuation_line=0
declare no_continuation_line=0
declare append=0
declare prefix='>>> '

declare opt_title=0
declare opt_head=0
declare opt_id=''
declare opt_lineno=''
declare opt_interactive=1
[[ ! -t 1 ]] && opt_interactive=0
declare opt_join=0
declare opt_color=0
declare opt_reverse=0
declare opt_inverse=0
declare color=NONE

## Colors for statuses. Others are added as needed on the fly.
declare -A colors
colors=(
    [NONE]=''
    [REVERSE]="${ANSI_REVERSE}"

    [RED]="${ANSI_FG_RED}"
    [REVRED]="${ANSI_FG_RED}${ANSI_REVERSE}"
    [INVRED]="${ANSI_FG_WHITE}${ANSI_BG_RED}" # Sometimes, just doesn't show up
                                              # well, so we define and inverse
                                              # for these statuses.

    [ORANGE]="${ANSI_FG_ORANGE}"
    [REVORANGE]="${ANSI_FG_ORANGE}${ANSI_REVERSE}"
    [INVORANGE]="${ANSI_FG_BLACK}${ANSI_BG_ORANGE}"

    [GREEN]="${ANSI_FG_GREEN}"
    [REVGREEN]="${ANSI_FG_GREEN}${ANSI_REVERSE}"
    [INVGREEN]="${ANSI_FG_WHITE}${ANSI_BG_GREEN}"

    [BLUE]="${ANSI_FG_BLUE}"
    [REVBLUE]="${ANSI_FG_BLUE}${ANSI_REVERSE}"
    [INVBLUE]="${ANSI_FG_WHITE}${ANSI_BG_BLUE}"

    [WARNING]="${colors[ORANGE]}" # Yellow
    [ERROR]="${colors[RED]}"
    [INFO]="${colors[GREEN]}"
    [DEBUG]="${colors[BLUE]}"

    [REVWARNING]="${colors[REVORANGE]}"
    [REVERROR]="${colors[REVRED]}"
    [REVINFO]="${colors[REVGREEN]}"
    [REVDEBUG]="${colors[REVBLUE]}"

    [INVWARNING]="${colors[INVORANGE]}"
    [INVERROR]="${colors[INVRED]}"
    [INVINFO]="${colors[INVGREEN]}"
    [INVDEBUG]="${colors[INVBLUE]}"
)

declare -A revinvmap
revinvmap=([r]="opt_reverse" [i]="opt_inverse")

declare msg_status=''

# Read the options and args from command line. Note that the long and short
# don't have to match up.
declare OPTSARGS
declare shortopts='inachfsojwedp::xl:'
declare longopts
longopts='head,title,id:,help,ec,wc,ic,dc,color:'
longopts="${longopts},oii,noreverse,norev,reverse,rev,noc,lineno:,nolineno:"
longopts="${longopts},err,error,ERR,ERROR,warn,warning,WARN,WARNING,info,INFO,debug,DEBUG"
longopts="${longopts},join,ecr,wcr,icr,dcr,eci,eci,ici,dci"
longopts="${longopts},interactive"
OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@") || exit

# Reset the command line ($@).
eval set -- "$OPTSARGS"

# Reprocess the command line, extracting options and their arguments into
# variables.
while true; do
    declare option=${1,,}
    shift
    [[ "$option" != '--' ]] && option=${option##-} && option=${option##-}
    case "$option" in
        head )
            opt_head=1 ;;
        title )
            opt_head=1
            opt_title=1
            reset_title="${reset_normal}"
            reset_normal=''
            ;;
        id )
            opt_id="$1"; shift ;;
        l | lineno )
            opt_lineno="$1";shift
            ;;
        nolineno )
            opt_lineno=''
            ;;
        interactive )
            opt_interactive=1 ;;
        n )
            nonl='-n' ;;
        a )
            append=1 ;;
        c )
            continuation_line=1 ;;
        noc )
            no_continuation_line=1 ;;
        h | help )
            bash-usage "$0"
            true; exit
            ;;
        f | s | o )
            echo "cmd-echo: -f, -s and -o are no longer used. Ignored..." ;;
        j | join )
            opt_join=1 ;;
        wc*)
            [[ -n ${option#wc} ]] && eval "${revinvmap[${option#wc}]}"=1
            ;&
        wc )
            opt_color=1
            ;& # <- UNCONDITIONAL fallthrough
        w | warn* )
            msg_status='WARNING'
            ;;
        ec*)
            [[ -n ${option#ec} ]] && eval "${revinvmap[${option#ec}]}"=1
            ;&
        ec )
            opt_color=1
            ;&
        e | err* )
            msg_status='ERROR'
            ;;
        dc*)
            [[ -n ${option#dc} ]] && eval "${revinvmap[${option#dc}]}"=1
            ;&
        dc )
            opt_color=1
            ;&
        d | debug )
            msg_status='DEBUG'
            ;;
        infoc*)
            [[ -n ${option#infoc} ]] && eval "${revinvmap[${option#infoc}]}"=1
            ;&
        infoc )
            opt_color=1
            ;&
        info )
            msg_status='INFO'
            ;;
        color )
            opt_color=1
            color="${1^^}"; shift  # Uppercase
            declare norev=${color#REV} # Strip off any previx
            case "$norev" in
                BLACK | BLUE | CYAN | GREEN | MAGENTA \
                    | ORANGE | RED | WHITE | YELLOW )
                    # Add the color to our map so we do not have to hardcode it
                    # in this script.
                    declare fgvar="ANSI_FG_${norev}"
                    colors+=(["$norev"]="${!fgvar}"
                             ["REV${norev}"]="${!fgvar}${ANSI_REVERSE}")
                    # Set the flag for later use.
                    if [[ $color =~ ^rev ]]; then
                        opt_reverse=1
                    fi
                    ;;
                * )
                    echo "cmd-echo: $color is not one of BLACK, BLUE, CYAN, GREEN, MAGENTA, ORANGE, RED, WHITE, or YELLOW"
                    false; exit
                    ;;
            esac
            ;;
        norev* )
            opt_reverse=0 ;;
        rev* )
            opt_reverse=1 ;;
        oii | only-if-interactive )
            ((opt_interactive==0)) && { true; exit; } ;;
        x )
            set -x;; # OK if you are grepping
        -- ) break ;; ## ## VITAL!!! Exits the while loop, no more options,
                      ## remaining $*, if any, are args
        * )
            echo "cmd-echo: '$option' is an invalid option."
            false; exit
            ;;
    esac
done

if [[ -n $opt_lineno ]] && [[ -z $opt_id ]]; then
    cmd-echo --id cmd-echo --wc "Won't print line number without --id option"
    opt_lineno=''
fi

declare dorest
declare doresn
declare docolor=${colors[$color]}
if ((opt_color)); then
    ((opt_reverse)) && docolor=${colors["REV${color}"]}
    dorest=${reset_title}
    doresn=${reset_normal}
fi

if ((! opt_interactive )); then
    ## If STDOUT is being redirected away from the terminal, then let's assume
    ## it's a file and don't print the colorizing sequences.
    docolor=''
    dorest=''
    doresn=''
elif((opt_color)) && [[ -n $msg_status ]]; then
    docolor=${colors[$msg_status]}
    ((opt_reverse)) && docolor=${colors["REV${msg_status}"]}
    ((opt_inverse)) && docolor=${colors["INV${msg_status}"]}
    dorest=${reset_title}
    doresn=${reset_normal}
fi

declare argcnt="$#"
if [[ -n "${opt_id}" ]]; then
    [[ -n $opt_lineno ]] && opt_id="$opt_id:$opt_lineno"
    prefix="${prefix/% / [${opt_id}]} "
    opt_id=''
fi
if [[ -n "${msg_status}" ]]; then
    prefix="${prefix/% / ${msg_status}:} "
    msg_status=''
fi
if ((append)); then
    prefix=''
fi

##
## Start printing
##
((opt_head)) && echo
for arg in "$@"; do
    if ((continuation_line == 1)); then
        # shellcheck disable=SC2001 #https://github.com/koalaman/shellcheck/wiki/SC2001
        prefix=$(echo "$prefix" | sed 's/./ /g')
    fi

    ## If there is a next line, it should be a continuation line, so let's set
    ## it up ahead of time.
    ((no_continuation_line == 0)) && continuation_line=1

    if ((opt_join)); then
        echo $nonl -e "${docolor}${prefix}$*${dorest}${doresn}"
    else
        if((argcnt==1)); then
            local_nonl=$nonl
        fi
        ((argcnt-=1))
        echo $local_nonl -e "${docolor}${prefix}${arg}${dorest}${doresn}"
    fi

    ## Reset out of title
    if ((opt_title)); then
        opt_title=0 ## no need to reset for ever
        ((opt_color)) && reset_normal="${doresn}"
        reset_title=''
    fi
    if ((opt_join)); then
        break
    fi
done

##eval "exec 2>&$holdstderr $holdstderr>&-"      ## Restore stderr and close file descriptor.

exit

# shellcheck disable=SC2317 #https://github.com/koalaman/shellcheck/wiki/SC2317
:<<__PODUSAGE__
=head1 NAME

  cmd-echo - label echo with some prefix and highlighting

=head1 SYNOPSIS

cmd-echo [--oii] [--head] [--title] [-n] [-a] [-c|--noc] [-i] [-id "id" ] \
         [j] [--rev] [-w[c]|-e[c]|-d[c]|--info[c]|--color [REV]COLOR] -- "text" ["text"...]

=head1 DESCRIPTION

Call "cmd-echo" to print the first "text" on a line with a prefix
'>>>'. Subsequent lines are printed indented with spaces, indicating
continuation.

Reversed and color adornments, if any, are skipped if we think the output is
not a terminal; i.e., a log file.

The text is echo-ed to STDOUT. Redirect the command yourself if you want to put
the output on a different output descriptor (i.e., STDERR).

=head1 OPTIONS

=over 4

=item --

Indicates end of options to 'cmd-echo' so that all subsequent arguments are
taken as text to print. Technically not necessary UNLESS your first argument to
print happens to match one of the options to 'cmd-echo'.

=item --interactive

Force interactive mode to force the colorization strings. Use when you know
that the context of usage is not interactive (assuming being redirected to a
file) yet you want the colorization.

=item --oii|--only-if-interactive

If --oii is specified and cmd-echo is called in a non-interactive mode (calling
script output is redirected to a file, for example), exit true, without
printing anything.  When this flag is not used, then non-interactive prints are
still performed, but the ascii control codes for colorization are not printed.

=item --head

Print a blank line for spacing before printing any text.

=item --title

Print a blank line for spacing before printing any text and then print the
entire first text line as reversed, not just the prefix.

=item -n

Do not print a new line after printing the last argument.

-item -a

Do not print the prefix when printing these lines. Using in conjunction with -n
and specifying only one line for each call allows you (a)ppend to a single line
as progress takes place in your process.

=item -c

Print all lines as continuation lines, substituting spaces1 for the prefix. You
must provide the same prefix that you used in prior calls if you are trying to
get multiple calls to line up.

=item -noc

Print no lines as continuation lines; all lines get the prefix.

=item --id "text"

Prefix the first line of the message with this text, followed by a ": " and
indent subsequent lines accordingly.

Note: The original purpose of this function was to determine what
function/script was making the 'cmd-echo' call and print **that** as the id
text ('cmd'-echo; get it?). Turns out that this piece of information is
ambiguous when you start defining functions both outside your script and inside
your script, and then you start calling one from the other, and then you call
them in subshells to capture output. So, don't try to add the
auto-determination to the code. We've already ripped it out once. If you want
to know what function/script is printing a message, explicitly use --id in it.

=item -l|--lineno $LINENO

Print the line number where cmd-line was called. Specified as $LINENO in
bash. Will not print if --id is not specified.

Note: As above, don't try to auto-determine the line number in this code; pass
it in.

=item --nolineno $LINENO

Provided for you to globally change the flag in your code to stop line numbers
from printing when you've finished debugging your problem.

=item -j|--join

Instead of printing each argument on its own line, print them all on one line,
separated by one space each.

=item --color [REV]COLOR

Print the message in color. COLOR is one of BLACK, BLUE, CYAN, GREEN, MAGENTA,
ORANGE, RED, WHITE, or YELLOW. Adding the 'REV' prefix prints in reverse,
switching the background and foreground.

=item --rev

If printing in color, prints in reverse, switching the background and
foreground. Alternative to specifying REVcolor.

=item [-e|-w|-i|-d][c[r|i]]

Put the string 'ERROR', WARNING', 'INFO', or 'DEBUG' before the message. The
following synonyms are accepted:

 -e: --err   --ERR  --error   --ERROR
 -w: --warn  --WARN --warning --WARNING
 -1: --info  --INFO
 -d: --debug --DEBUG

Appending a 'c' to the option prints the error message in color:

 ERROR:   red
 WARNING: orange, displays better than yellow
 INFO:    green
 DEBUG:   blue

Appending an 'r' uses an ANSI reverse sequence to swap background and
foreground.

Appending an 'i' "inverts" the colors; the given color is used
for the background, but either white or black is used for text.

=back

=cut

__PODUSAGE__

#  LocalWords:  funcname shellcheck util func PODUSAGE STDOUT cmd args usr
#  LocalWords:  LocalWords
