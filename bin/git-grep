#!/usr/bin/env bash

# git-grep

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

if ! git-version-verify 'git-grep'; then
    exit 1
fi

main ()
{
    local opt_edit=0
    local -a pass_on_args

    for i in $(git config --get "$(basename "$0").opts"); do
        pass_on_args+=("$i")
    done

    while [ -n "$1" ]; do
        local original="$1"
        shift
        if [[ "$original" =~ ^- ]]; then
            local option
            option=$(dashstripper "$original")

            ## All of the --foo=bar processing is stripped away because we
            ## don't need it for the limited set of options we are processing.

            case $option in
                h | help )
                    git-usage "$0"
                    exit 0
                    ;;
                edit )
                    opt_edit=1
                    continue
                    ;;
                ## No '*)' case needed; anything else just gets passed on
            esac
        fi

        ## If we are here, pass it on
        pass_on_args+=("$original")
    done

    if ((opt_edit)); then
        local -a files
        readarray -t files < <($REALGIT grep -l "${pass_on_args[@]}")
        if [ -n "${files[0]}" ]; then
            $EDITOR "${files[@]}"
        else
            echo "Pattern not found; no files to edit."
        fi
    else
        $REALGIT grep "${pass_on_args[@]}"
    fi
    return $?
}

main "$@"

exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-grep - git extention of git grep

=head1 SYNOPSIS

 git grep --edit

=head1 DESCRIPTION

Extensions to the 'git grep' command. Any action not described here will be passed onto the actual 'git grep' command.

=head1 EXTENSIONS

=over 4

=item --edit

Instead of displaying the results of the grep, edit all the files containing the pattern. Functionally equivilent to

 $EDITOR $(git grep -l pattern)

=back

=cut

__PODUSAGE__
