#!/usr/bin/env bash

# makesymlink

# Symlink $2 to $1, but do so relatively if they share a common root directory

declare backup_dir
declare relink=0
declare relative=1
declare moreopts=1
declare verbosity=2
declare interactive=0
declare copy=0
declare recopy=0
declare transform=''
# Define the options. ':' suffix for a mandatory value to an option, '::' for
# an optional one. Note that the long and short don't have to match up.
declare OPTSARGS
# Single letter options. No separator.
declare shortopts='i'
# Word options. Comma separator.
declare longopts='backup:,transform:,recopy,copy,relink,no-relative,relative,verbose,quiet,slient,interactive,help'

# Process the command line.
OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@") ## "${FUNCNAME[0]}" -- "$@") ## in functions
declare status=$?
((status != 0)) && exit $status ## return $status ## in functions

# Reset the command line ($@).
eval set -- "$OPTSARGS"

# Reprocess the command line, extracting options and their arguments into
# variables.
while true
do
    declare option=$1
    shift
    [ "$option" != '--' ] && option=${option##-} && option=${option##-}
    case "$option" in
        backup)
            backup_dir=$1 && shift;;
        transform)
            transform=$1 && shift;;
        recopy) recopy=1;&
        copy) copy=1;;
        relink) relink=1 ;;
        no-relative) relative=0 ;;
        relative) relative=1 ;;
        verbose) verbosity=2 ;;
        quiet) verbosity=1 ;;
        slient) verbosity=0 ;;
        i | interactive) interactive=1;;
        help)
            bash-usage "$0"
            exit 0
            ;;
        --) break ;; ## VITAL!!! Exits the while loop, no more options,
                     ## remaining $*, if any, are args
        *)
            cmd-echo -e -- "$option is an invalid option. See $0 --help"
            exit 1
            ;;
    esac
done

declare fullsrc=$1
declare fulltgt=$2
if [ ! -e "$fullsrc" ]; then
    (( verbosity > 0 )) && cmd-echo -- "'$fullsrc' not found. Skipping processing of '$fulltgt'."
elif [ -h "$fulltgt" ]; then
    if ((relink)); then
        (( verbosity > 1 )) && cmd-echo -- "'$fulltgt' is already a link. --relink specified; relinking."
    else
        (( verbosity > 0 )) && cmd-echo -- "'$fulltgt' is already a link. Skipping processing of '$fulltgt'."
    fi
elif [ -f "$fulltgt" ]; then
    if ((recopy)); then
        (( verbosity > 1 )) && cmd-echo -- "'$fulltgt' is already a copy. --recopy specified; recopying."
    else
        (( verbosity > 0 )) && cmd-echo -- "'$fulltgt' is already a copy. Skipping processing of '$fulltgt'."
    fi
else

    resp=y
    if ((interactive)); then
        if((copy)); then
            resp=$(yesno "Copy $fullsrc to $fulltgt")
        else
            resp=$(yesno "Link $fulltgt -> $fullsrc")
        fi
    fi

    [ "$resp" = 'n' ] && exit 0
    if [ -n "$backup_dir" ]; then
        if [ -f "$fulltgt" ] || [ -d "$fulltgt" ]; then
            srctype='directory'; if [ -f "$fulltgt" ]; then srctype='file'; fi
            (( verbosity > 1 )) && cmd-echo -- "Moving existing $srctype '$fulltgt' to $backup_dir so we can link it to '$fullsrc'."
            mv "$fulltgt" "$backup_dir/$(basename "$fulltgt").$(date '+%Y%m%d%H%M%S.%N')"
        fi
    fi
    if ((copy)); then
        (( verbosity > 1 )) && cmd-echo -- "Copying '$fullsrc' to '$fulltgt'."
        \cp -v "$fullsrc" "$fulltgt"
        if [[ -n $transform ]]; then
            declare -a transforms
            asplit "$transform" -s '#' -a transforms
            (( verbosity > 1 )) && cmd-echo -- "Transforming '$fulltgt'."
            sedinplace "${transforms[@]}" "$fulltgt"
            diff "$fullsrc" "$fulltgt"
        fi
    elif ((relative)); then
        (( verbosity > 1 )) && cmd-echo -- "Relativizing src and link"
        declare -a paths
        asplit "$(relativize_two_paths "$fullsrc" "$fulltgt")" -s : -a paths
        (( verbosity > 1 )) && cmd-echo -- "Creating symlink '${paths[2]}' to '${paths[1]}' in '${paths[0]}'."
        (builtin cd "${paths[0]}" || exit 1
         ln -s "${paths[1]}" "${paths[2]}")
    else
        (( verbosity > 1 )) && cmd-echo -- "Creating symlink '$fulltgt' to '$fullsrc'."
        ln -s "$fullsrc" "$fulltgt"
    fi
fi

exit $?

:<<'__PODUSAGE__'
=head1 NAME

makesymlink - make a symlink, with relativization and backup

=head1 SYNOPSIS

 makesymlink [--backup backup_dir] [--relink] [--[no-]relative] \
             [ --[verbose|quiet|slient]} \
             source link

=head1 DESCRIPTION

Make a symlink, but with some smarts

=head1 ARGUMENTS

=over 4

=item source, link

The original file and the link to it.

=back

=head1 OPTIONS

=over 4

=item --backup

If the link location is currently a file or directory, move it the the
backup_dir.

=item --relink

If the link already exists, it will not be recreated unless this option is
specfied.

=item --[no-]relative

If the source and the link share a directory tree (below /), then the link will
be created relative to the source with respect to that tree. If no- is
specfied, the link will be the absolute path to the source. The default is
--relative. The purpose is to create links that can still work when the link
and its source are copied or rsync'ed to a different location in the
filesystem, typically for hot-backup purposes.

=item --[verbose|quiet|slient

'verbose' prints everything, 'quiet' prints only errors, 'silent' prints
nothing. The default is 'verbose'.

=back

=cut

__PODUSAGE__
