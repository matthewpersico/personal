## -*- sh -*-

## Grabs all my processes that have emacs in the command.
## Filters out the grep command
## Filters in where parent ppid is 1 (in case emacs is running a perl debugger
## or some other subprocess)

debug=0
forceX=0
if [ "$1" = --debug ]
then
    set -x ## Set by option
    debug=1
    shift
fi
if [ "$1" = --forceX ]
then
    forceX=1
    shift
fi

## Temp file for processing and diagnostic messages.
procs=$(mktemp --suffix=.xo)

## Set up a trap for cleanup.
trap finish EXIT SIGINT
finish ()
{
    if [ -e $procs ]
    then
        rm -rf $procs
    fi
}

##
## Main
##

OS=$(uname -o)
case $OS in
    GNU/Linux )
        pscmd="ps lx -U ${USER}"
        grepargs='emacs'
        cutrange='15-20'
        ;;
    Cygwin )
        pscmd="ps -l -u ${USER}"
        grepargs='-- emacs-w32'
        cutrange='13-18'
        ;;
    * )
        echo "ps command for $OS not defined"
        exit 1
        ;;
esac

## Assume X or some other windowing system is available and do the needful if
## not.
hasX=1
if [ "$forceX" = '1' ]
then
    hasX=1
elif [ ! "$OS" = 'Cygwin' ]
then
    pinged=$(which xmodmap 2>&1 | grep 'no xmodmap')
    if [ -n "$pinged" ]
    then
        hasX=0
    else
        pinged=$(xmodmap 2>&1 | grep 'unable to open display')
        if [ -n "$pinged" ]
        then
            hasX=0
        fi
    fi
fi

## Get potential emacs server processes
$pscmd | grep $grepargs | grep -v grep | grep -vi 'emacs -Q' | grep -vi 'emacsclient -c' >$procs 2>&1
if ((debug))
then
    cat $procs
fi

## Count how many
if((hasX))
then
    serverup=$(cut -c $cutrange $procs | grep '    1' | wc -l)
else
    serverup=$(cat $procs | grep 'emacs -nw' | wc -l)
fi

## If we are being used as the git editor or EDITOR, we don't want to start up
## such that the underlying process thinks we're done editing before we are.
as_visual=0
new_frame=0
if [ "$1" = '--visual' ]
then
    as_visual=1
    shift
elif [ "$1" = '--nf' ] || [ "$1" = '-nf' ]
then
    new_frame=1
    shift
fi

if ((serverup==0))
then
    if ((as_visual==0)) && ((new_frame==0))
    then
        if (( hasX ))
        then
            emacs "$@" &
        else
            emacs -nw "$@" < /dev/tty
        fi
    else
        echo "No emacs server found. Start one and try again or use -m."
    fi
elif ((serverup==1))
then
    if [ ! "$#" = 0 ]
    then
        if ((new_frame))
        then
            emacsclient -c "$@" | grep -v 'Waiting for Emacs' &
        elif ((as_visual==1))
        then
            emacsclient -c "$@"
        else
            emacsclient -n -a emacs "$@"
        fi
    else
        echo "Server already up. Specify a file to edit."
    fi
else
    echo "More than one potential emacs server process found:"
    cat $procs
fi

alias xonf 2>/dev/null 1>&2 || alias xonf='xo -nf '
