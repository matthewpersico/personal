#!/usr/bin/env bash

## Grabs all my processes that have emacs in the command.
## Filters out the grep command
## Filters in where parent ppid is 1 (in case emacs is running a perl debugger
## or some other subprocess)

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

debug=0
forceX=0
emacs_exe=$(type -P emacs)
emacsclient_exe=$(type -P emacsclient)
declare -a gim
declare -a which ## We used to use the 'which' utility to find these
declare as_visual=0
declare new_frame=0
declare more_opts=1
declare -a emacs_opts
while ((more_opts)) && [[ "$1" =~ ^- ]]
do
    original="$1"
    option=$(dashstripper "$1")
    shift ## That way you avoid endless loops on invalid options.

    case $option in
        debug-init )
            emacs_opts+=('--debug-init') ;;
        debug | x ) set -x; debug=1 ;;
        forceX ) forceX=1 ;;
        which )
            declare tmp
            tmp=$(type -P "$1")
            shift
            if [ -z "$tmp" ]
            then
                cmd-echo -wc -- "$1 not found; skipping"
            else
                which+=("$tmp")
            fi
            ;;
        root )
            emacs_exe="$1/emacs"
            emacsclient_exe="$1/emacsclient"
            for i in $emacs_exe $emacsclient_exe
            do
                [ -x "$i" ] || (cmd-echo "Cannot find '$i'. --root cannot be used." && exit 1);
            done
            shift
            ;;
        gim )
            mapfile -t gim < <(git what is mod 2>/dev/null)
            if [ -z "${gim[0]}" ]
            then
                if ! git root 2>/dev/null 1>&2
                then
                    cmd-echo -- "--gim not allowed; not in a git repo"
                else
                    cmd-echo -- "No modified git files found."
                fi
                exit 1
            fi
            ;;
        nf )
            new_frame=1
            ;;
        help )
            bash-usage "$0"; exit 0;;
        -- )
            more_opts=0
            ;;
        * )
            cmd-echo -- "$original is an invalid option. See $0 --help"; exit 1;;
    esac
done

## Temp file for processing and diagnostic messages.
procs=$(mktemp -t tmp.xo.XXXXXXXXXX)
rm-on-exit "$procs"

##
## Main
##

OS=$(uname -s)
case $OS in
    Linux | \
    GNU/Linux )
        pscmd="ps -o pid,ppid,command -U ${USER}"
        grepargs='emacs'
        ;;
    Darwin )
        pscmd="ps -o pid,ppid,command -U ${USER}"
        grepargs='Applications/Emacs.app'
        ;;
    Cygwin )
        pscmd="ps -l -u ${USER}"
        grepargs='-- emacs-w32'
        ;;
    * )
        cmd-echo "ps command for $OS not defined"
        exit 1
        ;;
esac
cutstart=$($pscmd | head -1 | sed 's/ PID.*/ PID/')
cutstart=${#cutstart}
((cutstart+=1))
cutend=$($pscmd | head -1 | sed 's/PPID.*/PPID/')
cutend=${#cutend}
cutrange="${cutstart}-${cutend}"

## Assume X or some other windowing system is available and do the needful if
## not.
hasX=1
if [ "$forceX" = '1' ]
then
    hasX=1
elif [ ! "$OS" = 'Cygwin' ]
then
    if ! type -P xmodmap >/dev/null
    then
        hasX=0
    else
        if xmodmap 2>&1 | grep -q 'unable to open display'
        then
            hasX=0
        fi
    fi
fi

## Get potential emacs server processes. The last grep is because emacsclient
## is called usually directly (no path, no processing by this script) when the
## $EDITOR command is used.
$pscmd | grep "$grepargs" | grep -v grep | \
    grep -vi "$emacs_exe -Q" | \
    grep -vi "$emacsclient_exe -c" | \
    grep -vi "$emacsclient_exe -c" | \
    grep -vi " emacsclient -c " | \
    grep -i '/emacs' >"$procs" 2>&1
if ((debug))
then
    cat "$procs"
fi

## Count how many
if((hasX))
then
    serverup=$(cut -c "$cutrange" "$procs" | sed 's/ //g' | grep -c -E '^1$')
else
    serverup=$(grep -c "$emacs_exe -nw" "$procs")
fi
if ((debug))
then
    echo "serverup = $serverup"
fi

## If we are being used as the git editor or EDITOR, we don't want to start up
## such that the underlying process thinks we're done editing before we are.
if [ "$1" = '--visual' ]
then
    as_visual=1
    shift
elif [ "$1" = '--nf' ] || [ "$1" = '-nf' ]
then
    new_frame=1
    shift
fi

if ((serverup==0))
then
    if ((as_visual==0)) && ((new_frame==0))
    then
        if (( hasX ))
        then
            $emacs_exe "$@" "${gim[@]}" "${which[@]}" &
        else
            $emacs_exe -nw "$@" "${gim[@]}" "${which[@]}"  < /dev/tty
        fi
    else
        cmd-echo "No emacs server found. Start one and try again or use -m."
    fi
elif ((serverup==1))
then
    if [ ! "$#" = 0 ] || ((${#gim[@]})) || ((${#which[@]}))
    then
        if ((new_frame))
        then
            $emacsclient_exe -c "$@" "${gim[@]}" "${which[@]}" | grep -v 'Waiting for Emacs' &
        elif ((as_visual==1))
        then
            $emacsclient_exe -c "$@" "${gim[@]}" "${which[@]}"
        else
            $emacsclient_exe -n -a "$emacs_exe" "$@" "${gim[@]}" "${which[@]}"
        fi
    else
        cmd-echo "Server already up. Specify a file to edit."
        $pscmd | head -1
        cat "$procs"
    fi
else
    cmd-echo "More than one potential emacs server process found:"
    cat "$procs"
fi

exit 0

:<<'__USAGE__'
usage: xo [--debug] [--forceX] [--root] \\
          [--gim] [--which file[,file...]] \\
          [-- any-emacs-opts] [file [file...]]
       xo --help

       Start up emacs, using client mode where possible.

       --debug
           'xo' is a shell script. Run with 'set -x' to see what's borken.

       --forceX
           'xo' tries hard to find X. If it can't but you know it's available,
           tell 'xo' to use it anyway.

       --root
           Root directory of the emacs install, if you are using multiple
           version in places other than the default.

       --gim
           Stands for GIM or Git Is Modified. Find all the files that look
           like they have been modified (not committed) in the current
           directory (if it is a git repo) and edit those.

       --which
           Look up the files specified on PATH.

       --nf
           New frame. Open this file in a new frame.

       -- any-emacs-opts
           Notice this is '-- any-emacs-opts' and not '--any-emacs-opts'.  The
           '--' signals that there are no more options for 'xo'. All subsequent
           '-' and '--' flags, if any, (represented by -any-emacs-opts') are
           passed directly to emacs. Some of the more useful are:

           +l[:c] - open the file at line l, column c, where the column
                    is optional.
                    Note: Since we do not process + options, you could
                    use this without the intervening --, as in:

                    $ xo +123:45 some.file
__USAGE__
