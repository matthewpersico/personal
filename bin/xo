## -*- sh -*-

## Grabs all my processes that have emacs in the command.
## Filters out the grep command
## Filters in where parent ppid is 1 (in case emacs is running a perl debugger
## or some other subprocess)

xo-usage()
{
    cat <<EOF
usage: xo [--debug] [--forceX] [--root] [--gim] [-- emacs_opts] [file [file...]]
       xo --help

       Start up emacs, using client mode where possible.

       --debug
           'xo' is a shell script. Run with 'set -x' to see what's borken.

       --forceX
           'xo' tries hard to find X. If it can't but you know it's available,
           tell 'xo' to use it anyway.

       --root
           Root directory of the emacs install, if you are using multiple
           version in places other than the default.

       --gim
           Stands for GIM or Git Is Modified. Find all the files that look
           like they have been modified (not committed) in the current
           directory (if it is a git repo) and edit those.

       -- emacs_opts
          The -- signals that there are no more options for 'xo'. All
          subsequent - and -- flags are passed directly to emacs.
EOF
}

debug=0
forceX=0
emacs_exe=$(which emacs)
emacsclient_exe=$(which emacsclient)
gim=''
more_opts=1
while ((more_opts)) && [[ "$1" =~ ^- ]]
do
    case "$1" in
        --debug )
            set -x ## Set by option
            debug=1
            shift
            ;;
        --forceX )
            forceX=1
            shift
            ;;
        --root )
            emacs_exe="$2/emacs"
            emacsclient_exe="$2/emacsclient"
            shift;shift;
            for i in $emacs_exe $emacsclient_exe
            do
                [ -x $i ] || (echo "Cannot find '$i'. --root cannot be used." && exit 1);
            done
            ;;
        --gim )
            gim=$(git-is-mod)
            shift
            ;;
        --help )
            xo-usage; exit 0;;
        -- )
            more_opts=0
            shift
            ;;
    esac
done

## Temp file for processing and diagnostic messages.
procs=$(mktemp --suffix=.xo)

## Set up a trap for cleanup.
trap finish EXIT SIGINT
finish ()
{
    if [ -e $procs ]
    then
        rm -rf $procs
    fi
}

##
## Main
##

OS=$(uname -o)
case $OS in
    GNU/Linux )
        pscmd="ps lx -U ${USER}"
        grepargs='emacs'
        cutrange='15-20'
        ;;
    Cygwin )
        pscmd="ps -l -u ${USER}"
        grepargs='-- emacs-w32'
        cutrange='13-18'
        ;;
    * )
        echo "ps command for $OS not defined"
        exit 1
        ;;
esac

## Assume X or some other windowing system is available and do the needful if
## not.
hasX=1
if [ "$forceX" = '1' ]
then
    hasX=1
elif [ ! "$OS" = 'Cygwin' ]
then
    pinged=$(which xmodmap 2>&1 | grep 'no xmodmap')
    if [ -n "$pinged" ]
    then
        hasX=0
    else
        pinged=$(xmodmap 2>&1 | grep 'unable to open display')
        if [ -n "$pinged" ]
        then
            hasX=0
        fi
    fi
fi

## Get potential emacs server processes
$pscmd | grep $grepargs | grep -v grep | grep -vi "$emacs_exe -Q" | grep -vi "$emacsclient_exe -c" >$procs 2>&1
if ((debug))
then
    cat $procs
fi

## Count how many
if((hasX))
then
    serverup=$(cut -c $cutrange $procs | grep '    1' | wc -l)
else
    serverup=$(cat $procs | grep "$emacs_exe -nw" | wc -l)
fi

## If we are being used as the git editor or EDITOR, we don't want to start up
## such that the underlying process thinks we're done editing before we are.
as_visual=0
new_frame=0
if [ "$1" = '--visual' ]
then
    as_visual=1
    shift
elif [ "$1" = '--nf' ] || [ "$1" = '-nf' ]
then
    new_frame=1
    shift
fi

if ((serverup==0))
then
    if ((as_visual==0)) && ((new_frame==0))
    then
        if (( hasX ))
        then
            $emacs_exe "$@" $gim &
        else
            $emacs_exe -nw "$@" $gim < /dev/tty
        fi
    else
        echo "No emacs server found. Start one and try again or use -m."
    fi
elif ((serverup==1))
then
    if [ ! "$#" = 0 ] || [ -n "$gim" ]
    then
        if ((new_frame))
        then
            $emacsclient_exe -c "$@" $gim | grep -v 'Waiting for Emacs' &
        elif ((as_visual==1))
        then
            $emacsclient_exe -c "$@" $gim
        else
            $emacsclient_exe -n -a $emacs_exe "$@" $gim
        fi
    else
        echo "Server already up. Specify a file to edit."
    fi
else
    echo "More than one potential emacs server process found:"
    cat $procs
fi

alias xonf 2>/dev/null 1>&2 || alias xonf='xo -nf '
