# -*- sh -*-

# histfuncs

auditfuncs-init
. $(which controlfuncs_build)

histinit ()
{
    histfuncs_audit "$@"
    if [ -z "$histinited" ] ||  [ "$1" = '--force' ]
    then
        histinited=1
        HISTSIZE=9000
        HISTFILESIZE=$HISTSIZE
        HISTTIMEFORMAT="%m/%d - %H:%M:%S "
        HISTFILE=~/.bash_histories/hist.$(hostname).$(date +%Y_%m_%d_%H_%M_%S).$$
        if [ ! -d ~/.bash_histories ]
        then
            echo "Initializing bash command history setup..."
            mkdir -p ~/.bash_histories
        fi
        cat <<EOF >>$HISTFILE
#$(date +%s)
## pwd => The current directory AFTER the command. 'AFTER' only matters if a cd was involved.
EOF
        if [ "$1" = '--force' ]
        then
           echo "History inited."
        fi
    fi
}

_bash_history_index ()
{
    local files="$@"
    [ -z "$files" ] && files=$HISTFILE
    for i in $files
    do
        local index_file=$(dirname $HISTFILE)/.index
        local start=$(head -1 $i)
        local end=$(tail -2 $i | head -1)

        local my_index_file=${index_file}.$(date +%s.%N).$$
        touch $my_index_file
        local min_proc_index_file
        local locktries=20
        while [ ! "$min_proc_index_file" = "$my_index_file" ] && ((locktries))
        do
            min_proc_index_file=$(ls -c1 ${index_file}.* | sort | head -1)
            ((locktries-=1))
        done
        if((locktries))
        then
            perl -MData::Dumper -e 'do $ARGV[0] if (-r $ARGV[0]);
($start=$ARGV[2])=~ s/#([0-9]+).*/$1/;
($end=$ARGV[3])=~ s/#([0-9]+).*/$1/;
$index{$ARGV[1]}={start=>$start,end=>$end};
print Data::Dumper->Dump([\%index],[qw(*index)])' \
                 $index_file $i "$start" "$end" > $my_index_file
            \mv -f $my_index_file $index_file
        else
            echo "_bash_history_index: cannot lock - skipping"
        fi
        \rm -f $my_index_file
    done
}

bash_history_reindex ()
{
    local index_file=$(dirname $HISTFILE)/.index
    \rm -f $index_file ${index_file}.*
    _bash_history_index $(dirname $HISTFILE)/hist.*
}

_bash_history_sync ()
{
  builtin history -a         #1
  HISTFILESIZE=$HISTSIZE     #2
  builtin history -c         #3
  builtin history -r         #4

  ## This one adds the pwd to the hist file
  perl -e 'open(IH, "<$ARGV[0]");@lines=<IH>;close(IH);
chomp $lines[-2];$lines[-2]=~s/ ## pwd =>.*//;$lines[-2].= " ## pwd => $ARGV[1]\n";
open(OH, ">$ARGV[0]");print OH @lines;close(OH)' $HISTFILE "$(pwd)"

  ## This one updates the hist files time index
  _bash_history_index
}

PROMPT_COMMAND=_bash_history_sync

history ()
{
    histfuncs_audit "$@"
    _bash_history_sync
    builtin history "$@"
}

stash_history ()
{
    histfuncs_audit "$@"
    cp -v $HISTFILE $(dirname $HISTFILE)/$1
}

show_history ()
{
    histfuncs_audit "$@"
    local hf=$(basename $HISTFILE)
    ls -lrt $(dirname $HISTFILE) | sed "s|$hf|${hf}=current|"
}

show_current_history ()
{
    histfuncs_audit "$@"
    ls -la $HISTFILE
}

grep_history ()
{
    histfuncs_audit "$@"
    local hostfilt=''
    local grepopts=''
    local epoch_ago=''
    local endofopts=''
    local dodir=''
    local dofile=''
    while [[ "$1" =~ ^- ]] && [ -z "$endofopts" ]
    do
        case "$1" in
            -h ) hostfilt=$2
                 shift;shift ;;
            ## Both date options imply "from this date, forward"
            -[0-9]* )
                local epoch_today=$(date --date=$(date +%Y%m%d) +%s) ## midnight today
                local days_ago=$(echo "$1" | sed 's/^-//')
                epoch_ago=$((epoch_today - (86400*days_ago)))
                shift ;;
            -d )
                epoch_ago=$(date --date=$2 +%s)
                shift; shift ;;
            -i | -l )
                grepopts="$grepopts $1"
                shift ;;
            --dir )
                dodir=--include-dir
                shift ;;
            --file )
                dofile=--include-file
                shift ;;
            -- )
                endofopts=$1
                shift ;;
            * )
                echo invalid option "$1"
                return 1
        esac
    done

    local histfs
    if [ -n "$epoch_ago" ]
    then
        local index_file=$(dirname $HISTFILE)/.index
        histfs=$(perl -MData::Dumper -e '
do $ARGV[0] if (-r $ARGV[0]);
@files = grep{ $index{$_}->{start} >= $ARGV[1] }
         keys %index;
print "@files";'  $index_file $epoch_ago)
    else
        histfs="$(dirname $HISTFILE)/*"
    fi

    if [ -z "$histfs" ]
    then
        echo "No history files found matching date params"
    else
        # DEBUG perl -d:ptkdb \
        $(dirname $HISTFUNCS_FILE)/parse_bash_hist $dodir $dofile $grepopts "$1" $histfs
    fi
}

cat_history ()
{
    histfuncs_audit "$@"
    local cathist=$1
    [ -z "$cathist" ] && cathist=$HISTFILE
    if [ "$cathist" = '--list' ]
    then
        local hf=$HISTFILE
        select cathist in $(ls -rt $(dirname $HISTFILE)/*| sed "s|$hf|${hf}=current|" )
        do
            if [ -n "$cathist" ]
            then
                break
            fi
        done
    fi
    if [ -n "$cathist" ]
    then
        cathist=$(dirname $HISTFILE)/$(basename $cathist '=current')
        cat $cathist
    fi
}

rename_history ()
{
    histfuncs_audit "$@"
    if [ -z "$1" ]
    then
        echo usage: rename_history suffix
    else
        cp $HISTFILE "${HISTFILE}.$1"
        HISTFILE="${HISTFILE}.$1"
    fi
    echo "Done"
}

new_history ()
{
    histfuncs_audit "$@"
    histdir=$(dirname $HISTFILE)
    if [ -z "$1" ]
    then
        echo "usage: new_history name"
        echo "       name should be just a filename."
        echo "       basename will be applied to it."
        echo "       It will be written in '$histdir'."
        return
    else
        HISTFILE="${histdir}/$(basename $1)"
    fi
    echo "Done"
}

hist_with_pwd ()
{
    perl -ane 'BEGIN{@out=()};
if( $_ =~ m/^#([0-9]+)( ## pwd => (.*))*/ ) {
push @out, {time=$1, pwd=$3};
} else {
$out[-1]->{cmd} = $_;
}
END {
$idxfmt="%" . scalar(split(//,scalar(@out))) . "d";

@out
printf($idxfmt . ": %s %s %s",
        $., $_);' $HISTFILE
}

load_history ()
{
    histfuncs_audit "$@"
    local loadhist=$1
    if [ -z "$1" ]
    then
        select loadhist in $(ls -rt $(dirname $HISTFILE)/*)
        do
            if [ -n "$loadhist" ]
            then
                break
            fi
        done
    fi
    if [ -n "$loadhist" ]
    then
        loadhist=$(dirname $HISTFILE)/$(basename $loadhist)
        cat $loadhist >> $HISTFILE
    fi
}

safe_func_export --this

auditfuncs-end
