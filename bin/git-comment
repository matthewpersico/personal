#!/usr/bin/env bash

# git-comment

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

if ! git-version-verify 'git-commit'
then
    exit 1
fi

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        script-usage
    ) 2>&1 | ${PAGER:-less}
}

main ()
{
    local commentdate
    commentdate="$(date "$GIT_EXT_META_DATE_FMT") - "

    declare -a orig_args
    orig_args=("$@")

    ## If there's any chance that this will be in a script that will be dotted in,
    ## remove the explicit out_cmd calls.
    declare out_cmd="exit"
    declare moreopts=1
    declare opt_show=0
    declare opt_highest_only=0
    declare opt_verbose=1
    declare opt_delete=0

    declare -A keys
    keys[repo]='core.em.em-comment'
    local branchname
    branchname="$(git branch get-current)"
    keys[branch]="branch.$branchname.em-comment"
    local worktreename
    worktreename="$(basename "$(pwd)")"
    keys[worktree]="worktree.$worktreename.em-comment"

    declare -A write_keys
    while [[ "$1" =~ ^- ]] && ((moreopts))
    do
        declare original="$1"
        shift
        declare option
        option=$(dashstripper "$original")
        ## This bit deals with --foo=bar instead of --foo bar
        declare okey=''
        declare ovalue=''
        if [[ "$option" =~ = ]]
        then
            okey=${option%%=*}
            # shellcheck disable=SC2034 # Remove this directive if we ever have
            # an option with a value
            ovalue=${option#*=}
            option="$okey"
        fi

        case $option in

            ## Option with no arg
            r* )
                write_keys[repo]=1
                ;;
            b* )
                write_keys[branch]=1
                ;;
            w* )
                write_keys[worktree]=1
                ;;
            hi* )
                opt_highest_only=1
                ;;
            nod* )
                commentdate=''
                ;;

            show | get )
                opt_show=1
                ;;

            d* )
                opt_delete=1
                ;;

            ## standard options
            h | help )
                script-usage
                return 0
                ;;
            v | verbose )
                opt_verbose=1
                ;;
            q | quiet )
                opt_verbose=0
                ;;
            --)
                moreopts=0
                ;;
            * )
                cmd-echo -- "$original is an invalid option. See $0 --help"
                $out_cmd 1
                ;;
        esac
    done

    if [[ ${#write_keys[*]} = '0' ]]
    then
        if ((opt_show)) || ( (( $# == 0 )) && ((! opt_delete)) )
        then
            exec git-comment -r -b -w --show "${orig_args[@]}"
        else
            cmd-echo -n -- "Need at least one of --repo, --branch, --worktree to determine which comment to "
            if ((opt_delete))
            then
                cmd-echo -a -- "delete."
                return 1
            else
                cmd-echo -a -- "write."
                return 1
            fi
        fi
    fi

    if ((opt_delete || opt_show )) && (( $# > 0 ))
    then
        ((opt_verbose)) && cmd-echo -e -- "Cannot provide comment text with --delete or --show."
        return 1
    fi

    declare -A output
    for configtype in repo branch worktree
    do
        if [[ ${write_keys[$configtype]} = '1' ]]
        then
            local configkey=${keys[$configtype]}
            if ((opt_show))
            then
                value="$(git config --get "$configkey")"
                [[ -n $value ]] && \
                    output[$configtype]="$(printf '%8s: %s\n' $configtype "$value")"
            elif ((opt_delete))
            then
                git config --unset "$configkey" || return $?
                ((opt_verbose)) && cmd-echo -- "Comment removed for $configtype"
            else
                git config --replace-all "$configkey" "${commentdate}$*" || return $?
                ((opt_verbose)) && cmd-echo -- "Comment added for $configtype"
            fi
        fi
    done

    if (( ${#output[@]} ))
    then
        declare -a order
        order=(repo branch worktree)
        bail='echo'
        if (( opt_highest_only ))
        then
            order=(worktree branch repo)
            bail='return 1'
        fi
        for configtype in "${order[@]}"
        do
            [[ -n ${output[$configtype]} ]] && \
                echo "${output[$configtype]}" && \
                $bail >/dev/null
        done
    fi

    return 0
}

main "$@"
set +x
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-comment - Add or show comments

=head1 SYNOPSIS

 git commit --[r[epo]|b[ranch]|w[orktree]]... [-[no]d[ate]] [--show [--hi[ghest-only] | --delete | The message to write.]

=head1 DESCRIPTION

Write or retrieve comments on the current repo, branch or worktree.

=head1 OPTIONS

=over 4

=item --repo, --branch, --worktree

Place the comment on the current version of the particular object.  You must be
in the repo, at the branch and worktree you want to comment on.

=item --[no]date

Prefix, or not, the comment with the current date. Default is to add the prefix.

=item --show, --get

Retrieve instead of write the comment. You must be in the repo, at the branch
and worktree for which you want to retrive the comment. If you do not specify
which object to search, we search all three.

=item --highest-only

In conjunction with --show, print the first message found from the list of
worktree, branch, repo, in that order.

=item --delete

Delete instead of write the comment. You must be in the repo, at the branch
and worktree for which you want to delete the comment. If you do not specify
which object to search, we delete nothing.

=back

=cut

__PODUSAGE__
