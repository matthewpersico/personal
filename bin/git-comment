#!/usr/bin/env bash

# git-comment

# shellcheck disable=SC1090
source "$BASH_INC_DIR/on_exit.binc"

if ! git-version-verify 'git-commit'
then
    exit 1
fi

usage ()
{
    (
        [ -n "$*" ] && cmd-echo -- "$@"
        bash-usage "$0"
    ) 2>&1 | ${PAGER:-less}
}

main ()
{
    declare -a orig_args
    orig_args=("$@")

    ## If there's any chance that this will be in a script that will be dotted in,
    ## remove the explicit out_cmd calls.
    declare opt_show=0
    declare opt_highest_only=0
    declare opt_verbose=1
    declare opt_delete=0
    declare opt_date=1

    declare -A keys
    keys[repo]='core.em.em-comment'
    declare branchname
    branchname="$(git branch --show-current)"
    keys[branch]="branch.$branchname.em-comment"
    declare worktreename
    worktreename="$(basename "${PWD}")"
    keys[worktree]="worktree.$worktreename.em-comment"

    declare -A write_keys

    # Read the options and args from command line. Note that the long and short
    # don't have to match up.
    declare OPTSARGS
    declare shortopts='rbwdhvq'
    declare longopts='repo,branch,worktree,highest,nodate,date,show,get,delete,help,verbose,quiet'

    # Process the command line.
    OPTSARGS=$(getopt -a -o "$shortopts" -l "$longopts" -n "$(basename "$0")" -- "$@")
    declare status=$?
    ((status != 0)) && exit $status ## return $status ## in functions

    # Reset the command line ($@).
    eval set -- "$OPTSARGS"

    # Reprocess the command line, extracting options and their arguments into
    # variables.
    while true
    do
        declare option=$1
        shift
        [ "$option" != '--' ] && option=${option##-} && option=${option##-}
        case "$option" in
            ## Option with no arg
            r | repo )
                write_keys[repo]=1
                ;;
            b | branch )
                write_keys[branch]=1
                ;;
            w | worktree )
                write_keys[worktree]=1
                ;;
            highest )
                opt_highest_only=1
                ;;
            nodate )
                opt_date=0
                ;;
            date )
                opt_date=1
                ;;
            show | get )
                opt_show=1
                ;;
            d | delete )
                opt_delete=1
                ;;
            ## standard options
            h | help )
                bash-usage "$0"
                return 0
                ;;
            v | verbose )
                opt_verbose=1
                ;;
            q | quiet )
                opt_verbose=0
                ;;
            --)  break ;; ## VITAL!!! Exits the while loop, no more options,
                          ## remaining $*, if any, are args
            *)
                cmd-echo -ec -- "$option is an invalid option. See $0 --help"
                return 1
                ;;
        esac
    done

    declare commentdate
    ((opt_date)) && commentdate="$(date "$GIT_EXT_META_DATE_FMT") - "

    if [[ ${#write_keys[*]} = '0' ]]
    then
        if ((opt_show)) || ( (( $# == 0 )) && ((! opt_delete)) )
        then
            ## With no args, no options, just show all keys.
            exec git-comment -r -b -w --show "${orig_args[@]}"
        else
            cmd-echo -n -- "Need at least one of --repo, --branch, --worktree to determine which comment to "
            if ((opt_delete))
            then
                cmd-echo -a -- "delete."
                return 1
            else
                cmd-echo -a -- "write."
                return 1
            fi
        fi
    fi

    if ((opt_delete || opt_show )) && (( $# > 0 ))
    then
        ((opt_verbose)) && cmd-echo -ec -- "Cannot provide comment text with --delete or --show."
        return 1
    fi

    declare -A output
    for configtype in repo branch worktree
    do
        if [[ ${write_keys[$configtype]} = '1' ]]
        then
            declare configkey=${keys[$configtype]}
            if ((opt_show))
            then
                value="$(git config --get "$configkey")"
                [[ -n $value ]] && \
                    output[$configtype]="$(printf '%8s: %s\n' $configtype "$value")"
            elif ((opt_delete))
            then
                git config --unset "$configkey" || return $?
                ((opt_verbose)) && cmd-echo -- "Comment removed for $configtype"
            else
                git config --replace-all "$configkey" "${commentdate}$*" || return $?
                ((opt_verbose)) && cmd-echo -- "Comment added for $configtype"
            fi
        fi
    done

    if (( ${#output[@]} ))
    then
        declare -a order
        order=(repo branch worktree)
        bail='echo'
        if (( opt_highest_only ))
        then
            order=(worktree branch repo)
            bail='return 1'
        fi
        for configtype in "${order[@]}"
        do
            [[ -n ${output[$configtype]} ]] && \
                echo "${output[$configtype]}" && \
                $bail >/dev/null
        done
    fi

    return 0
}

main "$@"
exit $?

:<<'__PODUSAGE__'
=head1 NAME

git-comment - Add or show comments

=head1 SYNOPSIS

 git commit --[r[epo]|b[ranch]|w[orktree]]... [-[no]d[ate]] [--show [--hi[ghest-only] | --delete | The message to write.]

=head1 DESCRIPTION

Write or retrieve comments on the current repo, branch or worktree.

=head1 OPTIONS

=over 4

=item --repo, --branch, --worktree

Place the comment on the current version of the particular object.  You must be
in the repo, at the branch and worktree you want to comment on.

=item --[no]date

Prefix, or not, the comment with the current date. Default is to add the prefix.

=item --show, --get

Retrieve instead of write the comment. You must be in the repo, at the branch
and worktree for which you want to retrive the comment. If you do not specify
which object to search, we search all three.

=item --highest-only

In conjunction with --show, print the first message found from the list of
worktree, branch, repo, in that order.

=item --delete

Delete instead of write the comment. You must be in the repo, at the branch
and worktree for which you want to delete the comment. If you do not specify
which object to search, we delete nothing.

=back

=cut

__PODUSAGE__
